import { i as __toESM, n as __commonJS, t as require_react } from "./react-BhPhf8gb.js";

//#region node_modules/jerrypick/dist/jerrypick.mjs
var import_react = /* @__PURE__ */ __toESM(require_react(), 1);
function _iterableToArrayLimit$5(arr, i$1) {
	var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"];
	if (null != _i) {
		var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1;
		try {
			if (_x = (_i = _i.call(arr)).next, 0 === i$1) {
				if (Object(_i) !== _i) return;
				_n = !1;
			} else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i$1); _n = !0);
		} catch (err) {
			_d = !0, _e = err;
		} finally {
			try {
				if (!_n && null != _i.return && (_r = _i.return(), Object(_r) !== _r)) return;
			} finally {
				if (_d) throw _e;
			}
		}
		return _arr;
	}
}
function _defineProperty$2(obj, key, value) {
	key = _toPropertyKey$4(key);
	if (key in obj) Object.defineProperty(obj, key, {
		value,
		enumerable: true,
		configurable: true,
		writable: true
	});
	else obj[key] = value;
	return obj;
}
function _slicedToArray$5(arr, i$1) {
	return _arrayWithHoles$5(arr) || _iterableToArrayLimit$5(arr, i$1) || _unsupportedIterableToArray$6(arr, i$1) || _nonIterableRest$5();
}
function _toConsumableArray$4(arr) {
	return _arrayWithoutHoles$4(arr) || _iterableToArray$4(arr) || _unsupportedIterableToArray$6(arr) || _nonIterableSpread$4();
}
function _arrayWithoutHoles$4(arr) {
	if (Array.isArray(arr)) return _arrayLikeToArray$6(arr);
}
function _arrayWithHoles$5(arr) {
	if (Array.isArray(arr)) return arr;
}
function _iterableToArray$4(iter) {
	if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
function _unsupportedIterableToArray$6(o$1, minLen) {
	if (!o$1) return;
	if (typeof o$1 === "string") return _arrayLikeToArray$6(o$1, minLen);
	var n$1 = Object.prototype.toString.call(o$1).slice(8, -1);
	if (n$1 === "Object" && o$1.constructor) n$1 = o$1.constructor.name;
	if (n$1 === "Map" || n$1 === "Set") return Array.from(o$1);
	if (n$1 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n$1)) return _arrayLikeToArray$6(o$1, minLen);
}
function _arrayLikeToArray$6(arr, len) {
	if (len == null || len > arr.length) len = arr.length;
	for (var i$1 = 0, arr2 = new Array(len); i$1 < len; i$1++) arr2[i$1] = arr[i$1];
	return arr2;
}
function _nonIterableSpread$4() {
	throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _nonIterableRest$5() {
	throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _toPrimitive$4(input, hint) {
	if (typeof input !== "object" || input === null) return input;
	var prim = input[Symbol.toPrimitive];
	if (prim !== void 0) {
		var res = prim.call(input, hint || "default");
		if (typeof res !== "object") return res;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return (hint === "string" ? String : Number)(input);
}
function _toPropertyKey$4(arg) {
	var key = _toPrimitive$4(arg, "string");
	return typeof key === "symbol" ? key : String(key);
}
var omit = function omit$1(obj, keys) {
	var keySet = new Set(keys);
	return Object.assign.apply(Object, [{}].concat(_toConsumableArray$4(Object.entries(obj).filter(function(_ref2) {
		var key = _slicedToArray$5(_ref2, 1)[0];
		return !keySet.has(key);
	}).map(function(_ref4) {
		var _ref5 = _slicedToArray$5(_ref4, 2), key = _ref5[0], val = _ref5[1];
		return _defineProperty$2({}, key, val);
	}))));
};

//#endregion
//#region node_modules/react-kapsule/dist/react-kapsule.mjs
function _arrayLikeToArray$5(r$1, a$2) {
	(null == a$2 || a$2 > r$1.length) && (a$2 = r$1.length);
	for (var e$1 = 0, n$1 = Array(a$2); e$1 < a$2; e$1++) n$1[e$1] = r$1[e$1];
	return n$1;
}
function _arrayWithHoles$4(r$1) {
	if (Array.isArray(r$1)) return r$1;
}
function _arrayWithoutHoles$3(r$1) {
	if (Array.isArray(r$1)) return _arrayLikeToArray$5(r$1);
}
function _iterableToArray$3(r$1) {
	if ("undefined" != typeof Symbol && null != r$1[Symbol.iterator] || null != r$1["@@iterator"]) return Array.from(r$1);
}
function _iterableToArrayLimit$4(r$1, l$1) {
	var t$2 = null == r$1 ? null : "undefined" != typeof Symbol && r$1[Symbol.iterator] || r$1["@@iterator"];
	if (null != t$2) {
		var e$1, n$1, i$1, u$1, a$2 = [], f$1 = true, o$1 = false;
		try {
			if (i$1 = (t$2 = t$2.call(r$1)).next, 0 === l$1);
			else for (; !(f$1 = (e$1 = i$1.call(t$2)).done) && (a$2.push(e$1.value), a$2.length !== l$1); f$1 = !0);
		} catch (r$2) {
			o$1 = true, n$1 = r$2;
		} finally {
			try {
				if (!f$1 && null != t$2.return && (u$1 = t$2.return(), Object(u$1) !== u$1)) return;
			} finally {
				if (o$1) throw n$1;
			}
		}
		return a$2;
	}
}
function _nonIterableRest$4() {
	throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _nonIterableSpread$3() {
	throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _slicedToArray$4(r$1, e$1) {
	return _arrayWithHoles$4(r$1) || _iterableToArrayLimit$4(r$1, e$1) || _unsupportedIterableToArray$5(r$1, e$1) || _nonIterableRest$4();
}
function _toConsumableArray$3(r$1) {
	return _arrayWithoutHoles$3(r$1) || _iterableToArray$3(r$1) || _unsupportedIterableToArray$5(r$1) || _nonIterableSpread$3();
}
function _unsupportedIterableToArray$5(r$1, a$2) {
	if (r$1) {
		if ("string" == typeof r$1) return _arrayLikeToArray$5(r$1, a$2);
		var t$2 = {}.toString.call(r$1).slice(8, -1);
		return "Object" === t$2 && r$1.constructor && (t$2 = r$1.constructor.name), "Map" === t$2 || "Set" === t$2 ? Array.from(r$1) : "Arguments" === t$2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t$2) ? _arrayLikeToArray$5(r$1, a$2) : void 0;
	}
}
function index(kapsuleComponent) {
	var _ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, _ref$wrapperElementTy = _ref.wrapperElementType, wrapperElementType = _ref$wrapperElementTy === void 0 ? "div" : _ref$wrapperElementTy, _ref$nodeMapper = _ref.nodeMapper, nodeMapper = _ref$nodeMapper === void 0 ? function(node) {
		return node;
	} : _ref$nodeMapper, _ref$methodNames = _ref.methodNames, methodNames = _ref$methodNames === void 0 ? [] : _ref$methodNames, _ref$initPropNames = _ref.initPropNames, initPropNames = _ref$initPropNames === void 0 ? [] : _ref$initPropNames;
	return /* @__PURE__ */ (0, import_react.forwardRef)(function(props, ref) {
		var domEl = (0, import_react.useRef)();
		var comp = (0, import_react.useMemo)(function() {
			return kapsuleComponent(Object.fromEntries(initPropNames.filter(function(p$1) {
				return props.hasOwnProperty(p$1);
			}).map(function(prop) {
				return [prop, props[prop]];
			})));
		}, []);
		useEffectOnce(function() {
			comp(nodeMapper(domEl.current));
		}, import_react.useLayoutEffect);
		useEffectOnce(function() {
			return comp._destructor instanceof Function ? comp._destructor : void 0;
		});
		var _call = (0, import_react.useCallback)(function(method) {
			for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) args[_key - 1] = arguments[_key];
			return comp[method] instanceof Function ? comp[method].apply(comp, args) : void 0;
		}, [comp]);
		var prevPropsRef = (0, import_react.useRef)({});
		Object.keys(omit(props, [].concat(_toConsumableArray$3(methodNames), _toConsumableArray$3(initPropNames)))).filter(function(p$1) {
			return prevPropsRef.current[p$1] !== props[p$1];
		}).forEach(function(p$1) {
			return _call(p$1, props[p$1]);
		});
		prevPropsRef.current = props;
		(0, import_react.useImperativeHandle)(ref, function() {
			return Object.fromEntries(methodNames.map(function(method) {
				return [method, function() {
					for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) args[_key2] = arguments[_key2];
					return _call.apply(void 0, [method].concat(args));
				}];
			}));
		}, [_call]);
		return /* @__PURE__ */ import_react.createElement(wrapperElementType, { ref: domEl });
	});
}
function useEffectOnce(effect) {
	var useEffectFn = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : import_react.useEffect;
	var destroyFunc = (0, import_react.useRef)();
	var effectCalled = (0, import_react.useRef)(false);
	var renderAfterCalled = (0, import_react.useRef)(false);
	var _useState2 = _slicedToArray$4((0, import_react.useState)(0), 2);
	_useState2[0];
	var setVal = _useState2[1];
	if (effectCalled.current) renderAfterCalled.current = true;
	useEffectFn(function() {
		if (!effectCalled.current) {
			destroyFunc.current = effect();
			effectCalled.current = true;
		}
		setVal(function(val) {
			return val + 1;
		});
		return function() {
			if (!renderAfterCalled.current) return;
			if (destroyFunc.current) destroyFunc.current();
		};
	}, []);
}

//#endregion
//#region node_modules/d3-selection/src/namespaces.js
var xhtml = "http://www.w3.org/1999/xhtml";
var namespaces_default = {
	svg: "http://www.w3.org/2000/svg",
	xhtml,
	xlink: "http://www.w3.org/1999/xlink",
	xml: "http://www.w3.org/XML/1998/namespace",
	xmlns: "http://www.w3.org/2000/xmlns/"
};

//#endregion
//#region node_modules/d3-selection/src/namespace.js
function namespace_default(name) {
	var prefix = name += "", i$1 = prefix.indexOf(":");
	if (i$1 >= 0 && (prefix = name.slice(0, i$1)) !== "xmlns") name = name.slice(i$1 + 1);
	return namespaces_default.hasOwnProperty(prefix) ? {
		space: namespaces_default[prefix],
		local: name
	} : name;
}

//#endregion
//#region node_modules/d3-selection/src/creator.js
function creatorInherit(name) {
	return function() {
		var document$1 = this.ownerDocument, uri = this.namespaceURI;
		return uri === xhtml && document$1.documentElement.namespaceURI === xhtml ? document$1.createElement(name) : document$1.createElementNS(uri, name);
	};
}
function creatorFixed(fullname) {
	return function() {
		return this.ownerDocument.createElementNS(fullname.space, fullname.local);
	};
}
function creator_default(name) {
	var fullname = namespace_default(name);
	return (fullname.local ? creatorFixed : creatorInherit)(fullname);
}

//#endregion
//#region node_modules/d3-selection/src/selector.js
function none() {}
function selector_default(selector) {
	return selector == null ? none : function() {
		return this.querySelector(selector);
	};
}

//#endregion
//#region node_modules/d3-selection/src/selection/select.js
function select_default$2(select) {
	if (typeof select !== "function") select = selector_default(select);
	for (var groups = this._groups, m$2 = groups.length, subgroups = new Array(m$2), j$1 = 0; j$1 < m$2; ++j$1) for (var group = groups[j$1], n$1 = group.length, subgroup = subgroups[j$1] = new Array(n$1), node, subnode, i$1 = 0; i$1 < n$1; ++i$1) if ((node = group[i$1]) && (subnode = select.call(node, node.__data__, i$1, group))) {
		if ("__data__" in node) subnode.__data__ = node.__data__;
		subgroup[i$1] = subnode;
	}
	return new Selection$1(subgroups, this._parents);
}

//#endregion
//#region node_modules/d3-selection/src/array.js
function array(x$2) {
	return x$2 == null ? [] : Array.isArray(x$2) ? x$2 : Array.from(x$2);
}

//#endregion
//#region node_modules/d3-selection/src/selectorAll.js
function empty() {
	return [];
}
function selectorAll_default(selector) {
	return selector == null ? empty : function() {
		return this.querySelectorAll(selector);
	};
}

//#endregion
//#region node_modules/d3-selection/src/selection/selectAll.js
function arrayAll(select) {
	return function() {
		return array(select.apply(this, arguments));
	};
}
function selectAll_default$1(select) {
	if (typeof select === "function") select = arrayAll(select);
	else select = selectorAll_default(select);
	for (var groups = this._groups, m$2 = groups.length, subgroups = [], parents = [], j$1 = 0; j$1 < m$2; ++j$1) for (var group = groups[j$1], n$1 = group.length, node, i$1 = 0; i$1 < n$1; ++i$1) if (node = group[i$1]) {
		subgroups.push(select.call(node, node.__data__, i$1, group));
		parents.push(node);
	}
	return new Selection$1(subgroups, parents);
}

//#endregion
//#region node_modules/d3-selection/src/matcher.js
function matcher_default(selector) {
	return function() {
		return this.matches(selector);
	};
}
function childMatcher(selector) {
	return function(node) {
		return node.matches(selector);
	};
}

//#endregion
//#region node_modules/d3-selection/src/selection/selectChild.js
var find$1 = Array.prototype.find;
function childFind(match) {
	return function() {
		return find$1.call(this.children, match);
	};
}
function childFirst() {
	return this.firstElementChild;
}
function selectChild_default(match) {
	return this.select(match == null ? childFirst : childFind(typeof match === "function" ? match : childMatcher(match)));
}

//#endregion
//#region node_modules/d3-selection/src/selection/selectChildren.js
var filter = Array.prototype.filter;
function children() {
	return Array.from(this.children);
}
function childrenFilter(match) {
	return function() {
		return filter.call(this.children, match);
	};
}
function selectChildren_default(match) {
	return this.selectAll(match == null ? children : childrenFilter(typeof match === "function" ? match : childMatcher(match)));
}

//#endregion
//#region node_modules/d3-selection/src/selection/filter.js
function filter_default$1(match) {
	if (typeof match !== "function") match = matcher_default(match);
	for (var groups = this._groups, m$2 = groups.length, subgroups = new Array(m$2), j$1 = 0; j$1 < m$2; ++j$1) for (var group = groups[j$1], n$1 = group.length, subgroup = subgroups[j$1] = [], node, i$1 = 0; i$1 < n$1; ++i$1) if ((node = group[i$1]) && match.call(node, node.__data__, i$1, group)) subgroup.push(node);
	return new Selection$1(subgroups, this._parents);
}

//#endregion
//#region node_modules/d3-selection/src/selection/sparse.js
function sparse_default(update$1) {
	return new Array(update$1.length);
}

//#endregion
//#region node_modules/d3-selection/src/selection/enter.js
function enter_default() {
	return new Selection$1(this._enter || this._groups.map(sparse_default), this._parents);
}
function EnterNode(parent, datum$1) {
	this.ownerDocument = parent.ownerDocument;
	this.namespaceURI = parent.namespaceURI;
	this._next = null;
	this._parent = parent;
	this.__data__ = datum$1;
}
EnterNode.prototype = {
	constructor: EnterNode,
	appendChild: function(child) {
		return this._parent.insertBefore(child, this._next);
	},
	insertBefore: function(child, next) {
		return this._parent.insertBefore(child, next);
	},
	querySelector: function(selector) {
		return this._parent.querySelector(selector);
	},
	querySelectorAll: function(selector) {
		return this._parent.querySelectorAll(selector);
	}
};

//#endregion
//#region node_modules/d3-selection/src/constant.js
function constant_default$4(x$2) {
	return function() {
		return x$2;
	};
}

//#endregion
//#region node_modules/d3-selection/src/selection/data.js
function bindIndex(parent, group, enter, update$1, exit, data) {
	var i$1 = 0, node, groupLength = group.length, dataLength = data.length;
	for (; i$1 < dataLength; ++i$1) if (node = group[i$1]) {
		node.__data__ = data[i$1];
		update$1[i$1] = node;
	} else enter[i$1] = new EnterNode(parent, data[i$1]);
	for (; i$1 < groupLength; ++i$1) if (node = group[i$1]) exit[i$1] = node;
}
function bindKey(parent, group, enter, update$1, exit, data, key) {
	var i$1, node, nodeByKeyValue = /* @__PURE__ */ new Map(), groupLength = group.length, dataLength = data.length, keyValues = new Array(groupLength), keyValue;
	for (i$1 = 0; i$1 < groupLength; ++i$1) if (node = group[i$1]) {
		keyValues[i$1] = keyValue = key.call(node, node.__data__, i$1, group) + "";
		if (nodeByKeyValue.has(keyValue)) exit[i$1] = node;
		else nodeByKeyValue.set(keyValue, node);
	}
	for (i$1 = 0; i$1 < dataLength; ++i$1) {
		keyValue = key.call(parent, data[i$1], i$1, data) + "";
		if (node = nodeByKeyValue.get(keyValue)) {
			update$1[i$1] = node;
			node.__data__ = data[i$1];
			nodeByKeyValue.delete(keyValue);
		} else enter[i$1] = new EnterNode(parent, data[i$1]);
	}
	for (i$1 = 0; i$1 < groupLength; ++i$1) if ((node = group[i$1]) && nodeByKeyValue.get(keyValues[i$1]) === node) exit[i$1] = node;
}
function datum(node) {
	return node.__data__;
}
function data_default$3(value, key) {
	if (!arguments.length) return Array.from(this, datum);
	var bind = key ? bindKey : bindIndex, parents = this._parents, groups = this._groups;
	if (typeof value !== "function") value = constant_default$4(value);
	for (var m$2 = groups.length, update$1 = new Array(m$2), enter = new Array(m$2), exit = new Array(m$2), j$1 = 0; j$1 < m$2; ++j$1) {
		var parent = parents[j$1], group = groups[j$1], groupLength = group.length, data = arraylike(value.call(parent, parent && parent.__data__, j$1, parents)), dataLength = data.length, enterGroup = enter[j$1] = new Array(dataLength), updateGroup = update$1[j$1] = new Array(dataLength);
		bind(parent, group, enterGroup, updateGroup, exit[j$1] = new Array(groupLength), data, key);
		for (var i0 = 0, i1 = 0, previous, next; i0 < dataLength; ++i0) if (previous = enterGroup[i0]) {
			if (i0 >= i1) i1 = i0 + 1;
			while (!(next = updateGroup[i1]) && ++i1 < dataLength);
			previous._next = next || null;
		}
	}
	update$1 = new Selection$1(update$1, parents);
	update$1._enter = enter;
	update$1._exit = exit;
	return update$1;
}
function arraylike(data) {
	return typeof data === "object" && "length" in data ? data : Array.from(data);
}

//#endregion
//#region node_modules/d3-selection/src/selection/exit.js
function exit_default() {
	return new Selection$1(this._exit || this._groups.map(sparse_default), this._parents);
}

//#endregion
//#region node_modules/d3-selection/src/selection/join.js
function join_default(onenter, onupdate, onexit) {
	var enter = this.enter(), update$1 = this, exit = this.exit();
	if (typeof onenter === "function") {
		enter = onenter(enter);
		if (enter) enter = enter.selection();
	} else enter = enter.append(onenter + "");
	if (onupdate != null) {
		update$1 = onupdate(update$1);
		if (update$1) update$1 = update$1.selection();
	}
	if (onexit == null) exit.remove();
	else onexit(exit);
	return enter && update$1 ? enter.merge(update$1).order() : update$1;
}

//#endregion
//#region node_modules/d3-selection/src/selection/merge.js
function merge_default$1(context) {
	var selection$1 = context.selection ? context.selection() : context;
	for (var groups0 = this._groups, groups1 = selection$1._groups, m0 = groups0.length, m1 = groups1.length, m$2 = Math.min(m0, m1), merges = new Array(m0), j$1 = 0; j$1 < m$2; ++j$1) for (var group0 = groups0[j$1], group1 = groups1[j$1], n$1 = group0.length, merge = merges[j$1] = new Array(n$1), node, i$1 = 0; i$1 < n$1; ++i$1) if (node = group0[i$1] || group1[i$1]) merge[i$1] = node;
	for (; j$1 < m0; ++j$1) merges[j$1] = groups0[j$1];
	return new Selection$1(merges, this._parents);
}

//#endregion
//#region node_modules/d3-selection/src/selection/order.js
function order_default() {
	for (var groups = this._groups, j$1 = -1, m$2 = groups.length; ++j$1 < m$2;) for (var group = groups[j$1], i$1 = group.length - 1, next = group[i$1], node; --i$1 >= 0;) if (node = group[i$1]) {
		if (next && node.compareDocumentPosition(next) ^ 4) next.parentNode.insertBefore(node, next);
		next = node;
	}
	return this;
}

//#endregion
//#region node_modules/d3-selection/src/selection/sort.js
function sort_default(compare) {
	if (!compare) compare = ascending;
	function compareNode(a$2, b) {
		return a$2 && b ? compare(a$2.__data__, b.__data__) : !a$2 - !b;
	}
	for (var groups = this._groups, m$2 = groups.length, sortgroups = new Array(m$2), j$1 = 0; j$1 < m$2; ++j$1) {
		for (var group = groups[j$1], n$1 = group.length, sortgroup = sortgroups[j$1] = new Array(n$1), node, i$1 = 0; i$1 < n$1; ++i$1) if (node = group[i$1]) sortgroup[i$1] = node;
		sortgroup.sort(compareNode);
	}
	return new Selection$1(sortgroups, this._parents).order();
}
function ascending(a$2, b) {
	return a$2 < b ? -1 : a$2 > b ? 1 : a$2 >= b ? 0 : NaN;
}

//#endregion
//#region node_modules/d3-selection/src/selection/call.js
function call_default() {
	var callback = arguments[0];
	arguments[0] = this;
	callback.apply(null, arguments);
	return this;
}

//#endregion
//#region node_modules/d3-selection/src/selection/nodes.js
function nodes_default() {
	return Array.from(this);
}

//#endregion
//#region node_modules/d3-selection/src/selection/node.js
function node_default() {
	for (var groups = this._groups, j$1 = 0, m$2 = groups.length; j$1 < m$2; ++j$1) for (var group = groups[j$1], i$1 = 0, n$1 = group.length; i$1 < n$1; ++i$1) {
		var node = group[i$1];
		if (node) return node;
	}
	return null;
}

//#endregion
//#region node_modules/d3-selection/src/selection/size.js
function size_default$3() {
	let size = 0;
	for (const node of this) ++size;
	return size;
}

//#endregion
//#region node_modules/d3-selection/src/selection/empty.js
function empty_default() {
	return !this.node();
}

//#endregion
//#region node_modules/d3-selection/src/selection/each.js
function each_default(callback) {
	for (var groups = this._groups, j$1 = 0, m$2 = groups.length; j$1 < m$2; ++j$1) for (var group = groups[j$1], i$1 = 0, n$1 = group.length, node; i$1 < n$1; ++i$1) if (node = group[i$1]) callback.call(node, node.__data__, i$1, group);
	return this;
}

//#endregion
//#region node_modules/d3-selection/src/selection/attr.js
function attrRemove$1(name) {
	return function() {
		this.removeAttribute(name);
	};
}
function attrRemoveNS$1(fullname) {
	return function() {
		this.removeAttributeNS(fullname.space, fullname.local);
	};
}
function attrConstant$1(name, value) {
	return function() {
		this.setAttribute(name, value);
	};
}
function attrConstantNS$1(fullname, value) {
	return function() {
		this.setAttributeNS(fullname.space, fullname.local, value);
	};
}
function attrFunction$1(name, value) {
	return function() {
		var v$1 = value.apply(this, arguments);
		if (v$1 == null) this.removeAttribute(name);
		else this.setAttribute(name, v$1);
	};
}
function attrFunctionNS$1(fullname, value) {
	return function() {
		var v$1 = value.apply(this, arguments);
		if (v$1 == null) this.removeAttributeNS(fullname.space, fullname.local);
		else this.setAttributeNS(fullname.space, fullname.local, v$1);
	};
}
function attr_default$1(name, value) {
	var fullname = namespace_default(name);
	if (arguments.length < 2) {
		var node = this.node();
		return fullname.local ? node.getAttributeNS(fullname.space, fullname.local) : node.getAttribute(fullname);
	}
	return this.each((value == null ? fullname.local ? attrRemoveNS$1 : attrRemove$1 : typeof value === "function" ? fullname.local ? attrFunctionNS$1 : attrFunction$1 : fullname.local ? attrConstantNS$1 : attrConstant$1)(fullname, value));
}

//#endregion
//#region node_modules/d3-selection/src/window.js
function window_default(node) {
	return node.ownerDocument && node.ownerDocument.defaultView || node.document && node || node.defaultView;
}

//#endregion
//#region node_modules/d3-selection/src/selection/style.js
function styleRemove$1(name) {
	return function() {
		this.style.removeProperty(name);
	};
}
function styleConstant$1(name, value, priority) {
	return function() {
		this.style.setProperty(name, value, priority);
	};
}
function styleFunction$1(name, value, priority) {
	return function() {
		var v$1 = value.apply(this, arguments);
		if (v$1 == null) this.style.removeProperty(name);
		else this.style.setProperty(name, v$1, priority);
	};
}
function style_default$1(name, value, priority) {
	return arguments.length > 1 ? this.each((value == null ? styleRemove$1 : typeof value === "function" ? styleFunction$1 : styleConstant$1)(name, value, priority == null ? "" : priority)) : styleValue(this.node(), name);
}
function styleValue(node, name) {
	return node.style.getPropertyValue(name) || window_default(node).getComputedStyle(node, null).getPropertyValue(name);
}

//#endregion
//#region node_modules/d3-selection/src/selection/property.js
function propertyRemove(name) {
	return function() {
		delete this[name];
	};
}
function propertyConstant(name, value) {
	return function() {
		this[name] = value;
	};
}
function propertyFunction(name, value) {
	return function() {
		var v$1 = value.apply(this, arguments);
		if (v$1 == null) delete this[name];
		else this[name] = v$1;
	};
}
function property_default(name, value) {
	return arguments.length > 1 ? this.each((value == null ? propertyRemove : typeof value === "function" ? propertyFunction : propertyConstant)(name, value)) : this.node()[name];
}

//#endregion
//#region node_modules/d3-selection/src/selection/classed.js
function classArray(string) {
	return string.trim().split(/^|\s+/);
}
function classList(node) {
	return node.classList || new ClassList(node);
}
function ClassList(node) {
	this._node = node;
	this._names = classArray(node.getAttribute("class") || "");
}
ClassList.prototype = {
	add: function(name) {
		if (this._names.indexOf(name) < 0) {
			this._names.push(name);
			this._node.setAttribute("class", this._names.join(" "));
		}
	},
	remove: function(name) {
		var i$1 = this._names.indexOf(name);
		if (i$1 >= 0) {
			this._names.splice(i$1, 1);
			this._node.setAttribute("class", this._names.join(" "));
		}
	},
	contains: function(name) {
		return this._names.indexOf(name) >= 0;
	}
};
function classedAdd(node, names$1) {
	var list = classList(node), i$1 = -1, n$1 = names$1.length;
	while (++i$1 < n$1) list.add(names$1[i$1]);
}
function classedRemove(node, names$1) {
	var list = classList(node), i$1 = -1, n$1 = names$1.length;
	while (++i$1 < n$1) list.remove(names$1[i$1]);
}
function classedTrue(names$1) {
	return function() {
		classedAdd(this, names$1);
	};
}
function classedFalse(names$1) {
	return function() {
		classedRemove(this, names$1);
	};
}
function classedFunction(names$1, value) {
	return function() {
		(value.apply(this, arguments) ? classedAdd : classedRemove)(this, names$1);
	};
}
function classed_default(name, value) {
	var names$1 = classArray(name + "");
	if (arguments.length < 2) {
		var list = classList(this.node()), i$1 = -1, n$1 = names$1.length;
		while (++i$1 < n$1) if (!list.contains(names$1[i$1])) return false;
		return true;
	}
	return this.each((typeof value === "function" ? classedFunction : value ? classedTrue : classedFalse)(names$1, value));
}

//#endregion
//#region node_modules/d3-selection/src/selection/text.js
function textRemove() {
	this.textContent = "";
}
function textConstant$1(value) {
	return function() {
		this.textContent = value;
	};
}
function textFunction$1(value) {
	return function() {
		var v$1 = value.apply(this, arguments);
		this.textContent = v$1 == null ? "" : v$1;
	};
}
function text_default$1(value) {
	return arguments.length ? this.each(value == null ? textRemove : (typeof value === "function" ? textFunction$1 : textConstant$1)(value)) : this.node().textContent;
}

//#endregion
//#region node_modules/d3-selection/src/selection/html.js
function htmlRemove() {
	this.innerHTML = "";
}
function htmlConstant(value) {
	return function() {
		this.innerHTML = value;
	};
}
function htmlFunction(value) {
	return function() {
		var v$1 = value.apply(this, arguments);
		this.innerHTML = v$1 == null ? "" : v$1;
	};
}
function html_default(value) {
	return arguments.length ? this.each(value == null ? htmlRemove : (typeof value === "function" ? htmlFunction : htmlConstant)(value)) : this.node().innerHTML;
}

//#endregion
//#region node_modules/d3-selection/src/selection/raise.js
function raise() {
	if (this.nextSibling) this.parentNode.appendChild(this);
}
function raise_default() {
	return this.each(raise);
}

//#endregion
//#region node_modules/d3-selection/src/selection/lower.js
function lower() {
	if (this.previousSibling) this.parentNode.insertBefore(this, this.parentNode.firstChild);
}
function lower_default() {
	return this.each(lower);
}

//#endregion
//#region node_modules/d3-selection/src/selection/append.js
function append_default(name) {
	var create$1 = typeof name === "function" ? name : creator_default(name);
	return this.select(function() {
		return this.appendChild(create$1.apply(this, arguments));
	});
}

//#endregion
//#region node_modules/d3-selection/src/selection/insert.js
function constantNull() {
	return null;
}
function insert_default(name, before) {
	var create$1 = typeof name === "function" ? name : creator_default(name), select = before == null ? constantNull : typeof before === "function" ? before : selector_default(before);
	return this.select(function() {
		return this.insertBefore(create$1.apply(this, arguments), select.apply(this, arguments) || null);
	});
}

//#endregion
//#region node_modules/d3-selection/src/selection/remove.js
function remove$1() {
	var parent = this.parentNode;
	if (parent) parent.removeChild(this);
}
function remove_default$4() {
	return this.each(remove$1);
}

//#endregion
//#region node_modules/d3-selection/src/selection/clone.js
function selection_cloneShallow() {
	var clone = this.cloneNode(false), parent = this.parentNode;
	return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
}
function selection_cloneDeep() {
	var clone = this.cloneNode(true), parent = this.parentNode;
	return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
}
function clone_default(deep) {
	return this.select(deep ? selection_cloneDeep : selection_cloneShallow);
}

//#endregion
//#region node_modules/d3-selection/src/selection/datum.js
function datum_default(value) {
	return arguments.length ? this.property("__data__", value) : this.node().__data__;
}

//#endregion
//#region node_modules/d3-selection/src/selection/on.js
function contextListener(listener) {
	return function(event) {
		listener.call(this, event, this.__data__);
	};
}
function parseTypenames$1(typenames) {
	return typenames.trim().split(/^|\s+/).map(function(t$2) {
		var name = "", i$1 = t$2.indexOf(".");
		if (i$1 >= 0) name = t$2.slice(i$1 + 1), t$2 = t$2.slice(0, i$1);
		return {
			type: t$2,
			name
		};
	});
}
function onRemove(typename) {
	return function() {
		var on = this.__on;
		if (!on) return;
		for (var j$1 = 0, i$1 = -1, m$2 = on.length, o$1; j$1 < m$2; ++j$1) if (o$1 = on[j$1], (!typename.type || o$1.type === typename.type) && o$1.name === typename.name) this.removeEventListener(o$1.type, o$1.listener, o$1.options);
		else on[++i$1] = o$1;
		if (++i$1) on.length = i$1;
		else delete this.__on;
	};
}
function onAdd(typename, value, options) {
	return function() {
		var on = this.__on, o$1, listener = contextListener(value);
		if (on) {
			for (var j$1 = 0, m$2 = on.length; j$1 < m$2; ++j$1) if ((o$1 = on[j$1]).type === typename.type && o$1.name === typename.name) {
				this.removeEventListener(o$1.type, o$1.listener, o$1.options);
				this.addEventListener(o$1.type, o$1.listener = listener, o$1.options = options);
				o$1.value = value;
				return;
			}
		}
		this.addEventListener(typename.type, listener, options);
		o$1 = {
			type: typename.type,
			name: typename.name,
			value,
			listener,
			options
		};
		if (!on) this.__on = [o$1];
		else on.push(o$1);
	};
}
function on_default$1(typename, value, options) {
	var typenames = parseTypenames$1(typename + ""), i$1, n$1 = typenames.length, t$2;
	if (arguments.length < 2) {
		var on = this.node().__on;
		if (on) {
			for (var j$1 = 0, m$2 = on.length, o$1; j$1 < m$2; ++j$1) for (i$1 = 0, o$1 = on[j$1]; i$1 < n$1; ++i$1) if ((t$2 = typenames[i$1]).type === o$1.type && t$2.name === o$1.name) return o$1.value;
		}
		return;
	}
	on = value ? onAdd : onRemove;
	for (i$1 = 0; i$1 < n$1; ++i$1) this.each(on(typenames[i$1], value, options));
	return this;
}

//#endregion
//#region node_modules/d3-selection/src/selection/dispatch.js
function dispatchEvent(node, type, params) {
	var window$1 = window_default(node), event = window$1.CustomEvent;
	if (typeof event === "function") event = new event(type, params);
	else {
		event = window$1.document.createEvent("Event");
		if (params) event.initEvent(type, params.bubbles, params.cancelable), event.detail = params.detail;
		else event.initEvent(type, false, false);
	}
	node.dispatchEvent(event);
}
function dispatchConstant(type, params) {
	return function() {
		return dispatchEvent(this, type, params);
	};
}
function dispatchFunction(type, params) {
	return function() {
		return dispatchEvent(this, type, params.apply(this, arguments));
	};
}
function dispatch_default$1(type, params) {
	return this.each((typeof params === "function" ? dispatchFunction : dispatchConstant)(type, params));
}

//#endregion
//#region node_modules/d3-selection/src/selection/iterator.js
function* iterator_default() {
	for (var groups = this._groups, j$1 = 0, m$2 = groups.length; j$1 < m$2; ++j$1) for (var group = groups[j$1], i$1 = 0, n$1 = group.length, node; i$1 < n$1; ++i$1) if (node = group[i$1]) yield node;
}

//#endregion
//#region node_modules/d3-selection/src/selection/index.js
var root$1 = [null];
function Selection$1(groups, parents) {
	this._groups = groups;
	this._parents = parents;
}
function selection() {
	return new Selection$1([[document.documentElement]], root$1);
}
function selection_selection() {
	return this;
}
Selection$1.prototype = selection.prototype = {
	constructor: Selection$1,
	select: select_default$2,
	selectAll: selectAll_default$1,
	selectChild: selectChild_default,
	selectChildren: selectChildren_default,
	filter: filter_default$1,
	data: data_default$3,
	enter: enter_default,
	exit: exit_default,
	join: join_default,
	merge: merge_default$1,
	selection: selection_selection,
	order: order_default,
	sort: sort_default,
	call: call_default,
	nodes: nodes_default,
	node: node_default,
	size: size_default$3,
	empty: empty_default,
	each: each_default,
	attr: attr_default$1,
	style: style_default$1,
	property: property_default,
	classed: classed_default,
	text: text_default$1,
	html: html_default,
	raise: raise_default,
	lower: lower_default,
	append: append_default,
	insert: insert_default,
	remove: remove_default$4,
	clone: clone_default,
	datum: datum_default,
	on: on_default$1,
	dispatch: dispatch_default$1,
	[Symbol.iterator]: iterator_default
};
var selection_default = selection;

//#endregion
//#region node_modules/d3-selection/src/select.js
function select_default(selector) {
	return typeof selector === "string" ? new Selection$1([[document.querySelector(selector)]], [document.documentElement]) : new Selection$1([[selector]], root$1);
}

//#endregion
//#region node_modules/d3-selection/src/sourceEvent.js
function sourceEvent_default(event) {
	let sourceEvent;
	while (sourceEvent = event.sourceEvent) event = sourceEvent;
	return event;
}

//#endregion
//#region node_modules/d3-selection/src/pointer.js
function pointer_default(event, node) {
	event = sourceEvent_default(event);
	if (node === void 0) node = event.currentTarget;
	if (node) {
		var svg = node.ownerSVGElement || node;
		if (svg.createSVGPoint) {
			var point = svg.createSVGPoint();
			point.x = event.clientX, point.y = event.clientY;
			point = point.matrixTransform(node.getScreenCTM().inverse());
			return [point.x, point.y];
		}
		if (node.getBoundingClientRect) {
			var rect = node.getBoundingClientRect();
			return [event.clientX - rect.left - node.clientLeft, event.clientY - rect.top - node.clientTop];
		}
	}
	return [event.pageX, event.pageY];
}

//#endregion
//#region node_modules/d3-dispatch/src/dispatch.js
var noop = { value: () => {} };
function dispatch() {
	for (var i$1 = 0, n$1 = arguments.length, _$1 = {}, t$2; i$1 < n$1; ++i$1) {
		if (!(t$2 = arguments[i$1] + "") || t$2 in _$1 || /[\s.]/.test(t$2)) throw new Error("illegal type: " + t$2);
		_$1[t$2] = [];
	}
	return new Dispatch(_$1);
}
function Dispatch(_$1) {
	this._ = _$1;
}
function parseTypenames(typenames, types) {
	return typenames.trim().split(/^|\s+/).map(function(t$2) {
		var name = "", i$1 = t$2.indexOf(".");
		if (i$1 >= 0) name = t$2.slice(i$1 + 1), t$2 = t$2.slice(0, i$1);
		if (t$2 && !types.hasOwnProperty(t$2)) throw new Error("unknown type: " + t$2);
		return {
			type: t$2,
			name
		};
	});
}
Dispatch.prototype = dispatch.prototype = {
	constructor: Dispatch,
	on: function(typename, callback) {
		var _$1 = this._, T$1 = parseTypenames(typename + "", _$1), t$2, i$1 = -1, n$1 = T$1.length;
		if (arguments.length < 2) {
			while (++i$1 < n$1) if ((t$2 = (typename = T$1[i$1]).type) && (t$2 = get$1(_$1[t$2], typename.name))) return t$2;
			return;
		}
		if (callback != null && typeof callback !== "function") throw new Error("invalid callback: " + callback);
		while (++i$1 < n$1) if (t$2 = (typename = T$1[i$1]).type) _$1[t$2] = set$1(_$1[t$2], typename.name, callback);
		else if (callback == null) for (t$2 in _$1) _$1[t$2] = set$1(_$1[t$2], typename.name, null);
		return this;
	},
	copy: function() {
		var copy = {}, _$1 = this._;
		for (var t$2 in _$1) copy[t$2] = _$1[t$2].slice();
		return new Dispatch(copy);
	},
	call: function(type, that) {
		if ((n$1 = arguments.length - 2) > 0) for (var args = new Array(n$1), i$1 = 0, n$1, t$2; i$1 < n$1; ++i$1) args[i$1] = arguments[i$1 + 2];
		if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
		for (t$2 = this._[type], i$1 = 0, n$1 = t$2.length; i$1 < n$1; ++i$1) t$2[i$1].value.apply(that, args);
	},
	apply: function(type, that, args) {
		if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
		for (var t$2 = this._[type], i$1 = 0, n$1 = t$2.length; i$1 < n$1; ++i$1) t$2[i$1].value.apply(that, args);
	}
};
function get$1(type, name) {
	for (var i$1 = 0, n$1 = type.length, c$2; i$1 < n$1; ++i$1) if ((c$2 = type[i$1]).name === name) return c$2.value;
}
function set$1(type, name, callback) {
	for (var i$1 = 0, n$1 = type.length; i$1 < n$1; ++i$1) if (type[i$1].name === name) {
		type[i$1] = noop, type = type.slice(0, i$1).concat(type.slice(i$1 + 1));
		break;
	}
	if (callback != null) type.push({
		name,
		value: callback
	});
	return type;
}
var dispatch_default = dispatch;

//#endregion
//#region node_modules/d3-drag/src/noevent.js
const nonpassive = { passive: false };
const nonpassivecapture = {
	capture: true,
	passive: false
};
function nopropagation$1(event) {
	event.stopImmediatePropagation();
}
function noevent_default$1(event) {
	event.preventDefault();
	event.stopImmediatePropagation();
}

//#endregion
//#region node_modules/d3-drag/src/nodrag.js
function nodrag_default(view) {
	var root$2 = view.document.documentElement, selection$1 = select_default(view).on("dragstart.drag", noevent_default$1, nonpassivecapture);
	if ("onselectstart" in root$2) selection$1.on("selectstart.drag", noevent_default$1, nonpassivecapture);
	else {
		root$2.__noselect = root$2.style.MozUserSelect;
		root$2.style.MozUserSelect = "none";
	}
}
function yesdrag(view, noclick) {
	var root$2 = view.document.documentElement, selection$1 = select_default(view).on("dragstart.drag", null);
	if (noclick) {
		selection$1.on("click.drag", noevent_default$1, nonpassivecapture);
		setTimeout(function() {
			selection$1.on("click.drag", null);
		}, 0);
	}
	if ("onselectstart" in root$2) selection$1.on("selectstart.drag", null);
	else {
		root$2.style.MozUserSelect = root$2.__noselect;
		delete root$2.__noselect;
	}
}

//#endregion
//#region node_modules/d3-drag/src/constant.js
var constant_default$3 = (x$2) => () => x$2;

//#endregion
//#region node_modules/d3-drag/src/event.js
function DragEvent(type, { sourceEvent, subject, target, identifier, active, x: x$2, y: y$2, dx, dy, dispatch: dispatch$1 }) {
	Object.defineProperties(this, {
		type: {
			value: type,
			enumerable: true,
			configurable: true
		},
		sourceEvent: {
			value: sourceEvent,
			enumerable: true,
			configurable: true
		},
		subject: {
			value: subject,
			enumerable: true,
			configurable: true
		},
		target: {
			value: target,
			enumerable: true,
			configurable: true
		},
		identifier: {
			value: identifier,
			enumerable: true,
			configurable: true
		},
		active: {
			value: active,
			enumerable: true,
			configurable: true
		},
		x: {
			value: x$2,
			enumerable: true,
			configurable: true
		},
		y: {
			value: y$2,
			enumerable: true,
			configurable: true
		},
		dx: {
			value: dx,
			enumerable: true,
			configurable: true
		},
		dy: {
			value: dy,
			enumerable: true,
			configurable: true
		},
		_: { value: dispatch$1 }
	});
}
DragEvent.prototype.on = function() {
	var value = this._.on.apply(this._, arguments);
	return value === this._ ? this : value;
};

//#endregion
//#region node_modules/d3-drag/src/drag.js
function defaultFilter$1(event) {
	return !event.ctrlKey && !event.button;
}
function defaultContainer() {
	return this.parentNode;
}
function defaultSubject(event, d$1) {
	return d$1 == null ? {
		x: event.x,
		y: event.y
	} : d$1;
}
function defaultTouchable$1() {
	return navigator.maxTouchPoints || "ontouchstart" in this;
}
function drag_default() {
	var filter$1 = defaultFilter$1, container = defaultContainer, subject = defaultSubject, touchable = defaultTouchable$1, gestures = {}, listeners = dispatch_default("start", "drag", "end"), active = 0, mousedownx, mousedowny, mousemoving, touchending, clickDistance2 = 0;
	function drag(selection$1) {
		selection$1.on("mousedown.drag", mousedowned).filter(touchable).on("touchstart.drag", touchstarted).on("touchmove.drag", touchmoved, nonpassive).on("touchend.drag touchcancel.drag", touchended).style("touch-action", "none").style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
	}
	function mousedowned(event, d$1) {
		if (touchending || !filter$1.call(this, event, d$1)) return;
		var gesture = beforestart(this, container.call(this, event, d$1), event, d$1, "mouse");
		if (!gesture) return;
		select_default(event.view).on("mousemove.drag", mousemoved, nonpassivecapture).on("mouseup.drag", mouseupped, nonpassivecapture);
		nodrag_default(event.view);
		nopropagation$1(event);
		mousemoving = false;
		mousedownx = event.clientX;
		mousedowny = event.clientY;
		gesture("start", event);
	}
	function mousemoved(event) {
		noevent_default$1(event);
		if (!mousemoving) {
			var dx = event.clientX - mousedownx, dy = event.clientY - mousedowny;
			mousemoving = dx * dx + dy * dy > clickDistance2;
		}
		gestures.mouse("drag", event);
	}
	function mouseupped(event) {
		select_default(event.view).on("mousemove.drag mouseup.drag", null);
		yesdrag(event.view, mousemoving);
		noevent_default$1(event);
		gestures.mouse("end", event);
	}
	function touchstarted(event, d$1) {
		if (!filter$1.call(this, event, d$1)) return;
		var touches = event.changedTouches, c$2 = container.call(this, event, d$1), n$1 = touches.length, i$1, gesture;
		for (i$1 = 0; i$1 < n$1; ++i$1) if (gesture = beforestart(this, c$2, event, d$1, touches[i$1].identifier, touches[i$1])) {
			nopropagation$1(event);
			gesture("start", event, touches[i$1]);
		}
	}
	function touchmoved(event) {
		var touches = event.changedTouches, n$1 = touches.length, i$1, gesture;
		for (i$1 = 0; i$1 < n$1; ++i$1) if (gesture = gestures[touches[i$1].identifier]) {
			noevent_default$1(event);
			gesture("drag", event, touches[i$1]);
		}
	}
	function touchended(event) {
		var touches = event.changedTouches, n$1 = touches.length, i$1, gesture;
		if (touchending) clearTimeout(touchending);
		touchending = setTimeout(function() {
			touchending = null;
		}, 500);
		for (i$1 = 0; i$1 < n$1; ++i$1) if (gesture = gestures[touches[i$1].identifier]) {
			nopropagation$1(event);
			gesture("end", event, touches[i$1]);
		}
	}
	function beforestart(that, container$1, event, d$1, identifier, touch) {
		var dispatch$1 = listeners.copy(), p$1 = pointer_default(touch || event, container$1), dx, dy, s$1;
		if ((s$1 = subject.call(that, new DragEvent("beforestart", {
			sourceEvent: event,
			target: drag,
			identifier,
			active,
			x: p$1[0],
			y: p$1[1],
			dx: 0,
			dy: 0,
			dispatch: dispatch$1
		}), d$1)) == null) return;
		dx = s$1.x - p$1[0] || 0;
		dy = s$1.y - p$1[1] || 0;
		return function gesture(type, event$1, touch$1) {
			var p0 = p$1, n$1;
			switch (type) {
				case "start":
					gestures[identifier] = gesture, n$1 = active++;
					break;
				case "end": delete gestures[identifier], --active;
				case "drag":
					p$1 = pointer_default(touch$1 || event$1, container$1), n$1 = active;
					break;
			}
			dispatch$1.call(type, that, new DragEvent(type, {
				sourceEvent: event$1,
				subject: s$1,
				target: drag,
				identifier,
				active: n$1,
				x: p$1[0] + dx,
				y: p$1[1] + dy,
				dx: p$1[0] - p0[0],
				dy: p$1[1] - p0[1],
				dispatch: dispatch$1
			}), d$1);
		};
	}
	drag.filter = function(_$1) {
		return arguments.length ? (filter$1 = typeof _$1 === "function" ? _$1 : constant_default$3(!!_$1), drag) : filter$1;
	};
	drag.container = function(_$1) {
		return arguments.length ? (container = typeof _$1 === "function" ? _$1 : constant_default$3(_$1), drag) : container;
	};
	drag.subject = function(_$1) {
		return arguments.length ? (subject = typeof _$1 === "function" ? _$1 : constant_default$3(_$1), drag) : subject;
	};
	drag.touchable = function(_$1) {
		return arguments.length ? (touchable = typeof _$1 === "function" ? _$1 : constant_default$3(!!_$1), drag) : touchable;
	};
	drag.on = function() {
		var value = listeners.on.apply(listeners, arguments);
		return value === listeners ? drag : value;
	};
	drag.clickDistance = function(_$1) {
		return arguments.length ? (clickDistance2 = (_$1 = +_$1) * _$1, drag) : Math.sqrt(clickDistance2);
	};
	return drag;
}

//#endregion
//#region node_modules/d3-color/src/define.js
function define_default(constructor, factory, prototype) {
	constructor.prototype = factory.prototype = prototype;
	prototype.constructor = constructor;
}
function extend(parent, definition) {
	var prototype = Object.create(parent.prototype);
	for (var key in definition) prototype[key] = definition[key];
	return prototype;
}

//#endregion
//#region node_modules/d3-color/src/color.js
function Color() {}
var darker = .7;
var brighter = 1 / darker;
var reI = "\\s*([+-]?\\d+)\\s*", reN = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*", reP = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*", reHex = /^#([0-9a-f]{3,8})$/, reRgbInteger = /* @__PURE__ */ new RegExp(`^rgb\\(${reI},${reI},${reI}\\)$`), reRgbPercent = /* @__PURE__ */ new RegExp(`^rgb\\(${reP},${reP},${reP}\\)$`), reRgbaInteger = /* @__PURE__ */ new RegExp(`^rgba\\(${reI},${reI},${reI},${reN}\\)$`), reRgbaPercent = /* @__PURE__ */ new RegExp(`^rgba\\(${reP},${reP},${reP},${reN}\\)$`), reHslPercent = /* @__PURE__ */ new RegExp(`^hsl\\(${reN},${reP},${reP}\\)$`), reHslaPercent = /* @__PURE__ */ new RegExp(`^hsla\\(${reN},${reP},${reP},${reN}\\)$`);
var named = {
	aliceblue: 15792383,
	antiquewhite: 16444375,
	aqua: 65535,
	aquamarine: 8388564,
	azure: 15794175,
	beige: 16119260,
	bisque: 16770244,
	black: 0,
	blanchedalmond: 16772045,
	blue: 255,
	blueviolet: 9055202,
	brown: 10824234,
	burlywood: 14596231,
	cadetblue: 6266528,
	chartreuse: 8388352,
	chocolate: 13789470,
	coral: 16744272,
	cornflowerblue: 6591981,
	cornsilk: 16775388,
	crimson: 14423100,
	cyan: 65535,
	darkblue: 139,
	darkcyan: 35723,
	darkgoldenrod: 12092939,
	darkgray: 11119017,
	darkgreen: 25600,
	darkgrey: 11119017,
	darkkhaki: 12433259,
	darkmagenta: 9109643,
	darkolivegreen: 5597999,
	darkorange: 16747520,
	darkorchid: 10040012,
	darkred: 9109504,
	darksalmon: 15308410,
	darkseagreen: 9419919,
	darkslateblue: 4734347,
	darkslategray: 3100495,
	darkslategrey: 3100495,
	darkturquoise: 52945,
	darkviolet: 9699539,
	deeppink: 16716947,
	deepskyblue: 49151,
	dimgray: 6908265,
	dimgrey: 6908265,
	dodgerblue: 2003199,
	firebrick: 11674146,
	floralwhite: 16775920,
	forestgreen: 2263842,
	fuchsia: 16711935,
	gainsboro: 14474460,
	ghostwhite: 16316671,
	gold: 16766720,
	goldenrod: 14329120,
	gray: 8421504,
	green: 32768,
	greenyellow: 11403055,
	grey: 8421504,
	honeydew: 15794160,
	hotpink: 16738740,
	indianred: 13458524,
	indigo: 4915330,
	ivory: 16777200,
	khaki: 15787660,
	lavender: 15132410,
	lavenderblush: 16773365,
	lawngreen: 8190976,
	lemonchiffon: 16775885,
	lightblue: 11393254,
	lightcoral: 15761536,
	lightcyan: 14745599,
	lightgoldenrodyellow: 16448210,
	lightgray: 13882323,
	lightgreen: 9498256,
	lightgrey: 13882323,
	lightpink: 16758465,
	lightsalmon: 16752762,
	lightseagreen: 2142890,
	lightskyblue: 8900346,
	lightslategray: 7833753,
	lightslategrey: 7833753,
	lightsteelblue: 11584734,
	lightyellow: 16777184,
	lime: 65280,
	limegreen: 3329330,
	linen: 16445670,
	magenta: 16711935,
	maroon: 8388608,
	mediumaquamarine: 6737322,
	mediumblue: 205,
	mediumorchid: 12211667,
	mediumpurple: 9662683,
	mediumseagreen: 3978097,
	mediumslateblue: 8087790,
	mediumspringgreen: 64154,
	mediumturquoise: 4772300,
	mediumvioletred: 13047173,
	midnightblue: 1644912,
	mintcream: 16121850,
	mistyrose: 16770273,
	moccasin: 16770229,
	navajowhite: 16768685,
	navy: 128,
	oldlace: 16643558,
	olive: 8421376,
	olivedrab: 7048739,
	orange: 16753920,
	orangered: 16729344,
	orchid: 14315734,
	palegoldenrod: 15657130,
	palegreen: 10025880,
	paleturquoise: 11529966,
	palevioletred: 14381203,
	papayawhip: 16773077,
	peachpuff: 16767673,
	peru: 13468991,
	pink: 16761035,
	plum: 14524637,
	powderblue: 11591910,
	purple: 8388736,
	rebeccapurple: 6697881,
	red: 16711680,
	rosybrown: 12357519,
	royalblue: 4286945,
	saddlebrown: 9127187,
	salmon: 16416882,
	sandybrown: 16032864,
	seagreen: 3050327,
	seashell: 16774638,
	sienna: 10506797,
	silver: 12632256,
	skyblue: 8900331,
	slateblue: 6970061,
	slategray: 7372944,
	slategrey: 7372944,
	snow: 16775930,
	springgreen: 65407,
	steelblue: 4620980,
	tan: 13808780,
	teal: 32896,
	thistle: 14204888,
	tomato: 16737095,
	turquoise: 4251856,
	violet: 15631086,
	wheat: 16113331,
	white: 16777215,
	whitesmoke: 16119285,
	yellow: 16776960,
	yellowgreen: 10145074
};
define_default(Color, color, {
	copy(channels) {
		return Object.assign(new this.constructor(), this, channels);
	},
	displayable() {
		return this.rgb().displayable();
	},
	hex: color_formatHex,
	formatHex: color_formatHex,
	formatHex8: color_formatHex8,
	formatHsl: color_formatHsl,
	formatRgb: color_formatRgb,
	toString: color_formatRgb
});
function color_formatHex() {
	return this.rgb().formatHex();
}
function color_formatHex8() {
	return this.rgb().formatHex8();
}
function color_formatHsl() {
	return hslConvert(this).formatHsl();
}
function color_formatRgb() {
	return this.rgb().formatRgb();
}
function color(format) {
	var m$2, l$1;
	format = (format + "").trim().toLowerCase();
	return (m$2 = reHex.exec(format)) ? (l$1 = m$2[1].length, m$2 = parseInt(m$2[1], 16), l$1 === 6 ? rgbn(m$2) : l$1 === 3 ? new Rgb(m$2 >> 8 & 15 | m$2 >> 4 & 240, m$2 >> 4 & 15 | m$2 & 240, (m$2 & 15) << 4 | m$2 & 15, 1) : l$1 === 8 ? rgba(m$2 >> 24 & 255, m$2 >> 16 & 255, m$2 >> 8 & 255, (m$2 & 255) / 255) : l$1 === 4 ? rgba(m$2 >> 12 & 15 | m$2 >> 8 & 240, m$2 >> 8 & 15 | m$2 >> 4 & 240, m$2 >> 4 & 15 | m$2 & 240, ((m$2 & 15) << 4 | m$2 & 15) / 255) : null) : (m$2 = reRgbInteger.exec(format)) ? new Rgb(m$2[1], m$2[2], m$2[3], 1) : (m$2 = reRgbPercent.exec(format)) ? new Rgb(m$2[1] * 255 / 100, m$2[2] * 255 / 100, m$2[3] * 255 / 100, 1) : (m$2 = reRgbaInteger.exec(format)) ? rgba(m$2[1], m$2[2], m$2[3], m$2[4]) : (m$2 = reRgbaPercent.exec(format)) ? rgba(m$2[1] * 255 / 100, m$2[2] * 255 / 100, m$2[3] * 255 / 100, m$2[4]) : (m$2 = reHslPercent.exec(format)) ? hsla(m$2[1], m$2[2] / 100, m$2[3] / 100, 1) : (m$2 = reHslaPercent.exec(format)) ? hsla(m$2[1], m$2[2] / 100, m$2[3] / 100, m$2[4]) : named.hasOwnProperty(format) ? rgbn(named[format]) : format === "transparent" ? new Rgb(NaN, NaN, NaN, 0) : null;
}
function rgbn(n$1) {
	return new Rgb(n$1 >> 16 & 255, n$1 >> 8 & 255, n$1 & 255, 1);
}
function rgba(r$1, g$1, b, a$2) {
	if (a$2 <= 0) r$1 = g$1 = b = NaN;
	return new Rgb(r$1, g$1, b, a$2);
}
function rgbConvert(o$1) {
	if (!(o$1 instanceof Color)) o$1 = color(o$1);
	if (!o$1) return new Rgb();
	o$1 = o$1.rgb();
	return new Rgb(o$1.r, o$1.g, o$1.b, o$1.opacity);
}
function rgb(r$1, g$1, b, opacity) {
	return arguments.length === 1 ? rgbConvert(r$1) : new Rgb(r$1, g$1, b, opacity == null ? 1 : opacity);
}
function Rgb(r$1, g$1, b, opacity) {
	this.r = +r$1;
	this.g = +g$1;
	this.b = +b;
	this.opacity = +opacity;
}
define_default(Rgb, rgb, extend(Color, {
	brighter(k$1) {
		k$1 = k$1 == null ? brighter : Math.pow(brighter, k$1);
		return new Rgb(this.r * k$1, this.g * k$1, this.b * k$1, this.opacity);
	},
	darker(k$1) {
		k$1 = k$1 == null ? darker : Math.pow(darker, k$1);
		return new Rgb(this.r * k$1, this.g * k$1, this.b * k$1, this.opacity);
	},
	rgb() {
		return this;
	},
	clamp() {
		return new Rgb(clampi(this.r), clampi(this.g), clampi(this.b), clampa(this.opacity));
	},
	displayable() {
		return -.5 <= this.r && this.r < 255.5 && -.5 <= this.g && this.g < 255.5 && -.5 <= this.b && this.b < 255.5 && 0 <= this.opacity && this.opacity <= 1;
	},
	hex: rgb_formatHex,
	formatHex: rgb_formatHex,
	formatHex8: rgb_formatHex8,
	formatRgb: rgb_formatRgb,
	toString: rgb_formatRgb
}));
function rgb_formatHex() {
	return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}`;
}
function rgb_formatHex8() {
	return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}${hex((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
}
function rgb_formatRgb() {
	const a$2 = clampa(this.opacity);
	return `${a$2 === 1 ? "rgb(" : "rgba("}${clampi(this.r)}, ${clampi(this.g)}, ${clampi(this.b)}${a$2 === 1 ? ")" : `, ${a$2})`}`;
}
function clampa(opacity) {
	return isNaN(opacity) ? 1 : Math.max(0, Math.min(1, opacity));
}
function clampi(value) {
	return Math.max(0, Math.min(255, Math.round(value) || 0));
}
function hex(value) {
	value = clampi(value);
	return (value < 16 ? "0" : "") + value.toString(16);
}
function hsla(h$1, s$1, l$1, a$2) {
	if (a$2 <= 0) h$1 = s$1 = l$1 = NaN;
	else if (l$1 <= 0 || l$1 >= 1) h$1 = s$1 = NaN;
	else if (s$1 <= 0) h$1 = NaN;
	return new Hsl(h$1, s$1, l$1, a$2);
}
function hslConvert(o$1) {
	if (o$1 instanceof Hsl) return new Hsl(o$1.h, o$1.s, o$1.l, o$1.opacity);
	if (!(o$1 instanceof Color)) o$1 = color(o$1);
	if (!o$1) return new Hsl();
	if (o$1 instanceof Hsl) return o$1;
	o$1 = o$1.rgb();
	var r$1 = o$1.r / 255, g$1 = o$1.g / 255, b = o$1.b / 255, min$2 = Math.min(r$1, g$1, b), max$2 = Math.max(r$1, g$1, b), h$1 = NaN, s$1 = max$2 - min$2, l$1 = (max$2 + min$2) / 2;
	if (s$1) {
		if (r$1 === max$2) h$1 = (g$1 - b) / s$1 + (g$1 < b) * 6;
		else if (g$1 === max$2) h$1 = (b - r$1) / s$1 + 2;
		else h$1 = (r$1 - g$1) / s$1 + 4;
		s$1 /= l$1 < .5 ? max$2 + min$2 : 2 - max$2 - min$2;
		h$1 *= 60;
	} else s$1 = l$1 > 0 && l$1 < 1 ? 0 : h$1;
	return new Hsl(h$1, s$1, l$1, o$1.opacity);
}
function hsl(h$1, s$1, l$1, opacity) {
	return arguments.length === 1 ? hslConvert(h$1) : new Hsl(h$1, s$1, l$1, opacity == null ? 1 : opacity);
}
function Hsl(h$1, s$1, l$1, opacity) {
	this.h = +h$1;
	this.s = +s$1;
	this.l = +l$1;
	this.opacity = +opacity;
}
define_default(Hsl, hsl, extend(Color, {
	brighter(k$1) {
		k$1 = k$1 == null ? brighter : Math.pow(brighter, k$1);
		return new Hsl(this.h, this.s, this.l * k$1, this.opacity);
	},
	darker(k$1) {
		k$1 = k$1 == null ? darker : Math.pow(darker, k$1);
		return new Hsl(this.h, this.s, this.l * k$1, this.opacity);
	},
	rgb() {
		var h$1 = this.h % 360 + (this.h < 0) * 360, s$1 = isNaN(h$1) || isNaN(this.s) ? 0 : this.s, l$1 = this.l, m2 = l$1 + (l$1 < .5 ? l$1 : 1 - l$1) * s$1, m1 = 2 * l$1 - m2;
		return new Rgb(hsl2rgb(h$1 >= 240 ? h$1 - 240 : h$1 + 120, m1, m2), hsl2rgb(h$1, m1, m2), hsl2rgb(h$1 < 120 ? h$1 + 240 : h$1 - 120, m1, m2), this.opacity);
	},
	clamp() {
		return new Hsl(clamph(this.h), clampt(this.s), clampt(this.l), clampa(this.opacity));
	},
	displayable() {
		return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && 0 <= this.l && this.l <= 1 && 0 <= this.opacity && this.opacity <= 1;
	},
	formatHsl() {
		const a$2 = clampa(this.opacity);
		return `${a$2 === 1 ? "hsl(" : "hsla("}${clamph(this.h)}, ${clampt(this.s) * 100}%, ${clampt(this.l) * 100}%${a$2 === 1 ? ")" : `, ${a$2})`}`;
	}
}));
function clamph(value) {
	value = (value || 0) % 360;
	return value < 0 ? value + 360 : value;
}
function clampt(value) {
	return Math.max(0, Math.min(1, value || 0));
}
function hsl2rgb(h$1, m1, m2) {
	return (h$1 < 60 ? m1 + (m2 - m1) * h$1 / 60 : h$1 < 180 ? m2 : h$1 < 240 ? m1 + (m2 - m1) * (240 - h$1) / 60 : m1) * 255;
}

//#endregion
//#region node_modules/d3-interpolate/src/basis.js
function basis(t1, v0, v1, v2, v3) {
	var t2 = t1 * t1, t3 = t2 * t1;
	return ((1 - 3 * t1 + 3 * t2 - t3) * v0 + (4 - 6 * t2 + 3 * t3) * v1 + (1 + 3 * t1 + 3 * t2 - 3 * t3) * v2 + t3 * v3) / 6;
}
function basis_default(values) {
	var n$1 = values.length - 1;
	return function(t$2) {
		var i$1 = t$2 <= 0 ? t$2 = 0 : t$2 >= 1 ? (t$2 = 1, n$1 - 1) : Math.floor(t$2 * n$1), v1 = values[i$1], v2 = values[i$1 + 1], v0 = i$1 > 0 ? values[i$1 - 1] : 2 * v1 - v2, v3 = i$1 < n$1 - 1 ? values[i$1 + 2] : 2 * v2 - v1;
		return basis((t$2 - i$1 / n$1) * n$1, v0, v1, v2, v3);
	};
}

//#endregion
//#region node_modules/d3-interpolate/src/basisClosed.js
function basisClosed_default(values) {
	var n$1 = values.length;
	return function(t$2) {
		var i$1 = Math.floor(((t$2 %= 1) < 0 ? ++t$2 : t$2) * n$1), v0 = values[(i$1 + n$1 - 1) % n$1], v1 = values[i$1 % n$1], v2 = values[(i$1 + 1) % n$1], v3 = values[(i$1 + 2) % n$1];
		return basis((t$2 - i$1 / n$1) * n$1, v0, v1, v2, v3);
	};
}

//#endregion
//#region node_modules/d3-interpolate/src/constant.js
var constant_default$2 = (x$2) => () => x$2;

//#endregion
//#region node_modules/d3-interpolate/src/color.js
function linear(a$2, d$1) {
	return function(t$2) {
		return a$2 + t$2 * d$1;
	};
}
function exponential(a$2, b, y$2) {
	return a$2 = Math.pow(a$2, y$2), b = Math.pow(b, y$2) - a$2, y$2 = 1 / y$2, function(t$2) {
		return Math.pow(a$2 + t$2 * b, y$2);
	};
}
function gamma(y$2) {
	return (y$2 = +y$2) === 1 ? nogamma : function(a$2, b) {
		return b - a$2 ? exponential(a$2, b, y$2) : constant_default$2(isNaN(a$2) ? b : a$2);
	};
}
function nogamma(a$2, b) {
	var d$1 = b - a$2;
	return d$1 ? linear(a$2, d$1) : constant_default$2(isNaN(a$2) ? b : a$2);
}

//#endregion
//#region node_modules/d3-interpolate/src/rgb.js
var rgb_default = (function rgbGamma(y$2) {
	var color$1 = gamma(y$2);
	function rgb$1(start$1, end) {
		var r$1 = color$1((start$1 = rgb(start$1)).r, (end = rgb(end)).r), g$1 = color$1(start$1.g, end.g), b = color$1(start$1.b, end.b), opacity = nogamma(start$1.opacity, end.opacity);
		return function(t$2) {
			start$1.r = r$1(t$2);
			start$1.g = g$1(t$2);
			start$1.b = b(t$2);
			start$1.opacity = opacity(t$2);
			return start$1 + "";
		};
	}
	rgb$1.gamma = rgbGamma;
	return rgb$1;
})(1);
function rgbSpline(spline) {
	return function(colors) {
		var n$1 = colors.length, r$1 = new Array(n$1), g$1 = new Array(n$1), b = new Array(n$1), i$1, color$1;
		for (i$1 = 0; i$1 < n$1; ++i$1) {
			color$1 = rgb(colors[i$1]);
			r$1[i$1] = color$1.r || 0;
			g$1[i$1] = color$1.g || 0;
			b[i$1] = color$1.b || 0;
		}
		r$1 = spline(r$1);
		g$1 = spline(g$1);
		b = spline(b);
		color$1.opacity = 1;
		return function(t$2) {
			color$1.r = r$1(t$2);
			color$1.g = g$1(t$2);
			color$1.b = b(t$2);
			return color$1 + "";
		};
	};
}
var rgbBasis = rgbSpline(basis_default);
var rgbBasisClosed = rgbSpline(basisClosed_default);

//#endregion
//#region node_modules/d3-interpolate/src/number.js
function number_default(a$2, b) {
	return a$2 = +a$2, b = +b, function(t$2) {
		return a$2 * (1 - t$2) + b * t$2;
	};
}

//#endregion
//#region node_modules/d3-interpolate/src/string.js
var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g, reB = new RegExp(reA.source, "g");
function zero(b) {
	return function() {
		return b;
	};
}
function one(b) {
	return function(t$2) {
		return b(t$2) + "";
	};
}
function string_default(a$2, b) {
	var bi = reA.lastIndex = reB.lastIndex = 0, am, bm, bs, i$1 = -1, s$1 = [], q$1 = [];
	a$2 = a$2 + "", b = b + "";
	while ((am = reA.exec(a$2)) && (bm = reB.exec(b))) {
		if ((bs = bm.index) > bi) {
			bs = b.slice(bi, bs);
			if (s$1[i$1]) s$1[i$1] += bs;
			else s$1[++i$1] = bs;
		}
		if ((am = am[0]) === (bm = bm[0])) if (s$1[i$1]) s$1[i$1] += bm;
		else s$1[++i$1] = bm;
		else {
			s$1[++i$1] = null;
			q$1.push({
				i: i$1,
				x: number_default(am, bm)
			});
		}
		bi = reB.lastIndex;
	}
	if (bi < b.length) {
		bs = b.slice(bi);
		if (s$1[i$1]) s$1[i$1] += bs;
		else s$1[++i$1] = bs;
	}
	return s$1.length < 2 ? q$1[0] ? one(q$1[0].x) : zero(b) : (b = q$1.length, function(t$2) {
		for (var i$2 = 0, o$1; i$2 < b; ++i$2) s$1[(o$1 = q$1[i$2]).i] = o$1.x(t$2);
		return s$1.join("");
	});
}

//#endregion
//#region node_modules/d3-interpolate/src/transform/decompose.js
var degrees = 180 / Math.PI;
var identity$1 = {
	translateX: 0,
	translateY: 0,
	rotate: 0,
	skewX: 0,
	scaleX: 1,
	scaleY: 1
};
function decompose_default(a$2, b, c$2, d$1, e$1, f$1) {
	var scaleX, scaleY, skewX;
	if (scaleX = Math.sqrt(a$2 * a$2 + b * b)) a$2 /= scaleX, b /= scaleX;
	if (skewX = a$2 * c$2 + b * d$1) c$2 -= a$2 * skewX, d$1 -= b * skewX;
	if (scaleY = Math.sqrt(c$2 * c$2 + d$1 * d$1)) c$2 /= scaleY, d$1 /= scaleY, skewX /= scaleY;
	if (a$2 * d$1 < b * c$2) a$2 = -a$2, b = -b, skewX = -skewX, scaleX = -scaleX;
	return {
		translateX: e$1,
		translateY: f$1,
		rotate: Math.atan2(b, a$2) * degrees,
		skewX: Math.atan(skewX) * degrees,
		scaleX,
		scaleY
	};
}

//#endregion
//#region node_modules/d3-interpolate/src/transform/parse.js
var svgNode;
function parseCss(value) {
	const m$2 = new (typeof DOMMatrix === "function" ? DOMMatrix : WebKitCSSMatrix)(value + "");
	return m$2.isIdentity ? identity$1 : decompose_default(m$2.a, m$2.b, m$2.c, m$2.d, m$2.e, m$2.f);
}
function parseSvg(value) {
	if (value == null) return identity$1;
	if (!svgNode) svgNode = document.createElementNS("http://www.w3.org/2000/svg", "g");
	svgNode.setAttribute("transform", value);
	if (!(value = svgNode.transform.baseVal.consolidate())) return identity$1;
	value = value.matrix;
	return decompose_default(value.a, value.b, value.c, value.d, value.e, value.f);
}

//#endregion
//#region node_modules/d3-interpolate/src/transform/index.js
function interpolateTransform(parse, pxComma, pxParen, degParen) {
	function pop(s$1) {
		return s$1.length ? s$1.pop() + " " : "";
	}
	function translate(xa, ya, xb, yb, s$1, q$1) {
		if (xa !== xb || ya !== yb) {
			var i$1 = s$1.push("translate(", null, pxComma, null, pxParen);
			q$1.push({
				i: i$1 - 4,
				x: number_default(xa, xb)
			}, {
				i: i$1 - 2,
				x: number_default(ya, yb)
			});
		} else if (xb || yb) s$1.push("translate(" + xb + pxComma + yb + pxParen);
	}
	function rotate(a$2, b, s$1, q$1) {
		if (a$2 !== b) {
			if (a$2 - b > 180) b += 360;
			else if (b - a$2 > 180) a$2 += 360;
			q$1.push({
				i: s$1.push(pop(s$1) + "rotate(", null, degParen) - 2,
				x: number_default(a$2, b)
			});
		} else if (b) s$1.push(pop(s$1) + "rotate(" + b + degParen);
	}
	function skewX(a$2, b, s$1, q$1) {
		if (a$2 !== b) q$1.push({
			i: s$1.push(pop(s$1) + "skewX(", null, degParen) - 2,
			x: number_default(a$2, b)
		});
		else if (b) s$1.push(pop(s$1) + "skewX(" + b + degParen);
	}
	function scale(xa, ya, xb, yb, s$1, q$1) {
		if (xa !== xb || ya !== yb) {
			var i$1 = s$1.push(pop(s$1) + "scale(", null, ",", null, ")");
			q$1.push({
				i: i$1 - 4,
				x: number_default(xa, xb)
			}, {
				i: i$1 - 2,
				x: number_default(ya, yb)
			});
		} else if (xb !== 1 || yb !== 1) s$1.push(pop(s$1) + "scale(" + xb + "," + yb + ")");
	}
	return function(a$2, b) {
		var s$1 = [], q$1 = [];
		a$2 = parse(a$2), b = parse(b);
		translate(a$2.translateX, a$2.translateY, b.translateX, b.translateY, s$1, q$1);
		rotate(a$2.rotate, b.rotate, s$1, q$1);
		skewX(a$2.skewX, b.skewX, s$1, q$1);
		scale(a$2.scaleX, a$2.scaleY, b.scaleX, b.scaleY, s$1, q$1);
		a$2 = b = null;
		return function(t$2) {
			var i$1 = -1, n$1 = q$1.length, o$1;
			while (++i$1 < n$1) s$1[(o$1 = q$1[i$1]).i] = o$1.x(t$2);
			return s$1.join("");
		};
	};
}
var interpolateTransformCss = interpolateTransform(parseCss, "px, ", "px)", "deg)");
var interpolateTransformSvg = interpolateTransform(parseSvg, ", ", ")", ")");

//#endregion
//#region node_modules/d3-interpolate/src/zoom.js
var epsilon2 = 1e-12;
function cosh(x$2) {
	return ((x$2 = Math.exp(x$2)) + 1 / x$2) / 2;
}
function sinh(x$2) {
	return ((x$2 = Math.exp(x$2)) - 1 / x$2) / 2;
}
function tanh(x$2) {
	return ((x$2 = Math.exp(2 * x$2)) - 1) / (x$2 + 1);
}
var zoom_default$1 = (function zoomRho(rho, rho2, rho4) {
	function zoom(p0, p1) {
		var ux0 = p0[0], uy0 = p0[1], w0 = p0[2], ux1 = p1[0], uy1 = p1[1], w1 = p1[2], dx = ux1 - ux0, dy = uy1 - uy0, d2 = dx * dx + dy * dy, i$1, S$1;
		if (d2 < epsilon2) {
			S$1 = Math.log(w1 / w0) / rho;
			i$1 = function(t$2) {
				return [
					ux0 + t$2 * dx,
					uy0 + t$2 * dy,
					w0 * Math.exp(rho * t$2 * S$1)
				];
			};
		} else {
			var d1 = Math.sqrt(d2), b0 = (w1 * w1 - w0 * w0 + rho4 * d2) / (2 * w0 * rho2 * d1), b1 = (w1 * w1 - w0 * w0 - rho4 * d2) / (2 * w1 * rho2 * d1), r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0);
			S$1 = (Math.log(Math.sqrt(b1 * b1 + 1) - b1) - r0) / rho;
			i$1 = function(t$2) {
				var s$1 = t$2 * S$1, coshr0 = cosh(r0), u$1 = w0 / (rho2 * d1) * (coshr0 * tanh(rho * s$1 + r0) - sinh(r0));
				return [
					ux0 + u$1 * dx,
					uy0 + u$1 * dy,
					w0 * coshr0 / cosh(rho * s$1 + r0)
				];
			};
		}
		i$1.duration = S$1 * 1e3 * rho / Math.SQRT2;
		return i$1;
	}
	zoom.rho = function(_$1) {
		var _1 = Math.max(.001, +_$1), _2 = _1 * _1;
		return zoomRho(_1, _2, _2 * _2);
	};
	return zoom;
})(Math.SQRT2, 2, 4);

//#endregion
//#region node_modules/d3-timer/src/timer.js
var frame = 0, timeout = 0, interval = 0, pokeDelay = 1e3, taskHead, taskTail, clockLast = 0, clockNow = 0, clockSkew = 0, clock = typeof performance === "object" && performance.now ? performance : Date, setFrame = typeof window === "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(f$1) {
	setTimeout(f$1, 17);
};
function now$2() {
	return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);
}
function clearNow() {
	clockNow = 0;
}
function Timer() {
	this._call = this._time = this._next = null;
}
Timer.prototype = timer.prototype = {
	constructor: Timer,
	restart: function(callback, delay, time) {
		if (typeof callback !== "function") throw new TypeError("callback is not a function");
		time = (time == null ? now$2() : +time) + (delay == null ? 0 : +delay);
		if (!this._next && taskTail !== this) {
			if (taskTail) taskTail._next = this;
			else taskHead = this;
			taskTail = this;
		}
		this._call = callback;
		this._time = time;
		sleep();
	},
	stop: function() {
		if (this._call) {
			this._call = null;
			this._time = Infinity;
			sleep();
		}
	}
};
function timer(callback, delay, time) {
	var t$2 = new Timer();
	t$2.restart(callback, delay, time);
	return t$2;
}
function timerFlush() {
	now$2();
	++frame;
	var t$2 = taskHead, e$1;
	while (t$2) {
		if ((e$1 = clockNow - t$2._time) >= 0) t$2._call.call(void 0, e$1);
		t$2 = t$2._next;
	}
	--frame;
}
function wake() {
	clockNow = (clockLast = clock.now()) + clockSkew;
	frame = timeout = 0;
	try {
		timerFlush();
	} finally {
		frame = 0;
		nap();
		clockNow = 0;
	}
}
function poke() {
	var now$3 = clock.now(), delay = now$3 - clockLast;
	if (delay > pokeDelay) clockSkew -= delay, clockLast = now$3;
}
function nap() {
	var t0, t1 = taskHead, t2, time = Infinity;
	while (t1) if (t1._call) {
		if (time > t1._time) time = t1._time;
		t0 = t1, t1 = t1._next;
	} else {
		t2 = t1._next, t1._next = null;
		t1 = t0 ? t0._next = t2 : taskHead = t2;
	}
	taskTail = t0;
	sleep(time);
}
function sleep(time) {
	if (frame) return;
	if (timeout) timeout = clearTimeout(timeout);
	if (time - clockNow > 24) {
		if (time < Infinity) timeout = setTimeout(wake, time - clock.now() - clockSkew);
		if (interval) interval = clearInterval(interval);
	} else {
		if (!interval) clockLast = clock.now(), interval = setInterval(poke, pokeDelay);
		frame = 1, setFrame(wake);
	}
}

//#endregion
//#region node_modules/d3-timer/src/timeout.js
function timeout_default(callback, delay, time) {
	var t$2 = new Timer();
	delay = delay == null ? 0 : +delay;
	t$2.restart((elapsed) => {
		t$2.stop();
		callback(elapsed + delay);
	}, delay, time);
	return t$2;
}

//#endregion
//#region node_modules/d3-transition/src/transition/schedule.js
var emptyOn = dispatch_default("start", "end", "cancel", "interrupt");
var emptyTween = [];
var CREATED = 0;
var SCHEDULED = 1;
var STARTING = 2;
var STARTED = 3;
var RUNNING = 4;
var ENDING = 5;
var ENDED = 6;
function schedule_default(node, name, id$1, index$6, group, timing) {
	var schedules = node.__transition;
	if (!schedules) node.__transition = {};
	else if (id$1 in schedules) return;
	create(node, id$1, {
		name,
		index: index$6,
		group,
		on: emptyOn,
		tween: emptyTween,
		time: timing.time,
		delay: timing.delay,
		duration: timing.duration,
		ease: timing.ease,
		timer: null,
		state: CREATED
	});
}
function init(node, id$1) {
	var schedule = get(node, id$1);
	if (schedule.state > CREATED) throw new Error("too late; already scheduled");
	return schedule;
}
function set(node, id$1) {
	var schedule = get(node, id$1);
	if (schedule.state > STARTED) throw new Error("too late; already running");
	return schedule;
}
function get(node, id$1) {
	var schedule = node.__transition;
	if (!schedule || !(schedule = schedule[id$1])) throw new Error("transition not found");
	return schedule;
}
function create(node, id$1, self$1) {
	var schedules = node.__transition, tween;
	schedules[id$1] = self$1;
	self$1.timer = timer(schedule, 0, self$1.time);
	function schedule(elapsed) {
		self$1.state = SCHEDULED;
		self$1.timer.restart(start$1, self$1.delay, self$1.time);
		if (self$1.delay <= elapsed) start$1(elapsed - self$1.delay);
	}
	function start$1(elapsed) {
		var i$1, j$1, n$1, o$1;
		if (self$1.state !== SCHEDULED) return stop();
		for (i$1 in schedules) {
			o$1 = schedules[i$1];
			if (o$1.name !== self$1.name) continue;
			if (o$1.state === STARTED) return timeout_default(start$1);
			if (o$1.state === RUNNING) {
				o$1.state = ENDED;
				o$1.timer.stop();
				o$1.on.call("interrupt", node, node.__data__, o$1.index, o$1.group);
				delete schedules[i$1];
			} else if (+i$1 < id$1) {
				o$1.state = ENDED;
				o$1.timer.stop();
				o$1.on.call("cancel", node, node.__data__, o$1.index, o$1.group);
				delete schedules[i$1];
			}
		}
		timeout_default(function() {
			if (self$1.state === STARTED) {
				self$1.state = RUNNING;
				self$1.timer.restart(tick, self$1.delay, self$1.time);
				tick(elapsed);
			}
		});
		self$1.state = STARTING;
		self$1.on.call("start", node, node.__data__, self$1.index, self$1.group);
		if (self$1.state !== STARTING) return;
		self$1.state = STARTED;
		tween = new Array(n$1 = self$1.tween.length);
		for (i$1 = 0, j$1 = -1; i$1 < n$1; ++i$1) if (o$1 = self$1.tween[i$1].value.call(node, node.__data__, self$1.index, self$1.group)) tween[++j$1] = o$1;
		tween.length = j$1 + 1;
	}
	function tick(elapsed) {
		var t$2 = elapsed < self$1.duration ? self$1.ease.call(null, elapsed / self$1.duration) : (self$1.timer.restart(stop), self$1.state = ENDING, 1), i$1 = -1, n$1 = tween.length;
		while (++i$1 < n$1) tween[i$1].call(node, t$2);
		if (self$1.state === ENDING) {
			self$1.on.call("end", node, node.__data__, self$1.index, self$1.group);
			stop();
		}
	}
	function stop() {
		self$1.state = ENDED;
		self$1.timer.stop();
		delete schedules[id$1];
		for (var i$1 in schedules) return;
		delete node.__transition;
	}
}

//#endregion
//#region node_modules/d3-transition/src/interrupt.js
function interrupt_default(node, name) {
	var schedules = node.__transition, schedule, active, empty$1 = true, i$1;
	if (!schedules) return;
	name = name == null ? null : name + "";
	for (i$1 in schedules) {
		if ((schedule = schedules[i$1]).name !== name) {
			empty$1 = false;
			continue;
		}
		active = schedule.state > STARTING && schedule.state < ENDING;
		schedule.state = ENDED;
		schedule.timer.stop();
		schedule.on.call(active ? "interrupt" : "cancel", node, node.__data__, schedule.index, schedule.group);
		delete schedules[i$1];
	}
	if (empty$1) delete node.__transition;
}

//#endregion
//#region node_modules/d3-transition/src/selection/interrupt.js
function interrupt_default$1(name) {
	return this.each(function() {
		interrupt_default(this, name);
	});
}

//#endregion
//#region node_modules/d3-transition/src/transition/tween.js
function tweenRemove(id$1, name) {
	var tween0, tween1;
	return function() {
		var schedule = set(this, id$1), tween = schedule.tween;
		if (tween !== tween0) {
			tween1 = tween0 = tween;
			for (var i$1 = 0, n$1 = tween1.length; i$1 < n$1; ++i$1) if (tween1[i$1].name === name) {
				tween1 = tween1.slice();
				tween1.splice(i$1, 1);
				break;
			}
		}
		schedule.tween = tween1;
	};
}
function tweenFunction(id$1, name, value) {
	var tween0, tween1;
	if (typeof value !== "function") throw new Error();
	return function() {
		var schedule = set(this, id$1), tween = schedule.tween;
		if (tween !== tween0) {
			tween1 = (tween0 = tween).slice();
			for (var t$2 = {
				name,
				value
			}, i$1 = 0, n$1 = tween1.length; i$1 < n$1; ++i$1) if (tween1[i$1].name === name) {
				tween1[i$1] = t$2;
				break;
			}
			if (i$1 === n$1) tween1.push(t$2);
		}
		schedule.tween = tween1;
	};
}
function tween_default(name, value) {
	var id$1 = this._id;
	name += "";
	if (arguments.length < 2) {
		var tween = get(this.node(), id$1).tween;
		for (var i$1 = 0, n$1 = tween.length, t$2; i$1 < n$1; ++i$1) if ((t$2 = tween[i$1]).name === name) return t$2.value;
		return null;
	}
	return this.each((value == null ? tweenRemove : tweenFunction)(id$1, name, value));
}
function tweenValue(transition$1, name, value) {
	var id$1 = transition$1._id;
	transition$1.each(function() {
		var schedule = set(this, id$1);
		(schedule.value || (schedule.value = {}))[name] = value.apply(this, arguments);
	});
	return function(node) {
		return get(node, id$1).value[name];
	};
}

//#endregion
//#region node_modules/d3-transition/src/transition/interpolate.js
function interpolate_default(a$2, b) {
	var c$2;
	return (typeof b === "number" ? number_default : b instanceof color ? rgb_default : (c$2 = color(b)) ? (b = c$2, rgb_default) : string_default)(a$2, b);
}

//#endregion
//#region node_modules/d3-transition/src/transition/attr.js
function attrRemove(name) {
	return function() {
		this.removeAttribute(name);
	};
}
function attrRemoveNS(fullname) {
	return function() {
		this.removeAttributeNS(fullname.space, fullname.local);
	};
}
function attrConstant(name, interpolate, value1) {
	var string00, string1 = value1 + "", interpolate0;
	return function() {
		var string0 = this.getAttribute(name);
		return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate(string00 = string0, value1);
	};
}
function attrConstantNS(fullname, interpolate, value1) {
	var string00, string1 = value1 + "", interpolate0;
	return function() {
		var string0 = this.getAttributeNS(fullname.space, fullname.local);
		return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate(string00 = string0, value1);
	};
}
function attrFunction(name, interpolate, value) {
	var string00, string10, interpolate0;
	return function() {
		var string0, value1 = value(this), string1;
		if (value1 == null) return void this.removeAttribute(name);
		string0 = this.getAttribute(name);
		string1 = value1 + "";
		return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
	};
}
function attrFunctionNS(fullname, interpolate, value) {
	var string00, string10, interpolate0;
	return function() {
		var string0, value1 = value(this), string1;
		if (value1 == null) return void this.removeAttributeNS(fullname.space, fullname.local);
		string0 = this.getAttributeNS(fullname.space, fullname.local);
		string1 = value1 + "";
		return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
	};
}
function attr_default(name, value) {
	var fullname = namespace_default(name), i$1 = fullname === "transform" ? interpolateTransformSvg : interpolate_default;
	return this.attrTween(name, typeof value === "function" ? (fullname.local ? attrFunctionNS : attrFunction)(fullname, i$1, tweenValue(this, "attr." + name, value)) : value == null ? (fullname.local ? attrRemoveNS : attrRemove)(fullname) : (fullname.local ? attrConstantNS : attrConstant)(fullname, i$1, value));
}

//#endregion
//#region node_modules/d3-transition/src/transition/attrTween.js
function attrInterpolate(name, i$1) {
	return function(t$2) {
		this.setAttribute(name, i$1.call(this, t$2));
	};
}
function attrInterpolateNS(fullname, i$1) {
	return function(t$2) {
		this.setAttributeNS(fullname.space, fullname.local, i$1.call(this, t$2));
	};
}
function attrTweenNS(fullname, value) {
	var t0, i0;
	function tween() {
		var i$1 = value.apply(this, arguments);
		if (i$1 !== i0) t0 = (i0 = i$1) && attrInterpolateNS(fullname, i$1);
		return t0;
	}
	tween._value = value;
	return tween;
}
function attrTween(name, value) {
	var t0, i0;
	function tween() {
		var i$1 = value.apply(this, arguments);
		if (i$1 !== i0) t0 = (i0 = i$1) && attrInterpolate(name, i$1);
		return t0;
	}
	tween._value = value;
	return tween;
}
function attrTween_default(name, value) {
	var key = "attr." + name;
	if (arguments.length < 2) return (key = this.tween(key)) && key._value;
	if (value == null) return this.tween(key, null);
	if (typeof value !== "function") throw new Error();
	var fullname = namespace_default(name);
	return this.tween(key, (fullname.local ? attrTweenNS : attrTween)(fullname, value));
}

//#endregion
//#region node_modules/d3-transition/src/transition/delay.js
function delayFunction(id$1, value) {
	return function() {
		init(this, id$1).delay = +value.apply(this, arguments);
	};
}
function delayConstant(id$1, value) {
	return value = +value, function() {
		init(this, id$1).delay = value;
	};
}
function delay_default(value) {
	var id$1 = this._id;
	return arguments.length ? this.each((typeof value === "function" ? delayFunction : delayConstant)(id$1, value)) : get(this.node(), id$1).delay;
}

//#endregion
//#region node_modules/d3-transition/src/transition/duration.js
function durationFunction(id$1, value) {
	return function() {
		set(this, id$1).duration = +value.apply(this, arguments);
	};
}
function durationConstant(id$1, value) {
	return value = +value, function() {
		set(this, id$1).duration = value;
	};
}
function duration_default(value) {
	var id$1 = this._id;
	return arguments.length ? this.each((typeof value === "function" ? durationFunction : durationConstant)(id$1, value)) : get(this.node(), id$1).duration;
}

//#endregion
//#region node_modules/d3-transition/src/transition/ease.js
function easeConstant(id$1, value) {
	if (typeof value !== "function") throw new Error();
	return function() {
		set(this, id$1).ease = value;
	};
}
function ease_default(value) {
	var id$1 = this._id;
	return arguments.length ? this.each(easeConstant(id$1, value)) : get(this.node(), id$1).ease;
}

//#endregion
//#region node_modules/d3-transition/src/transition/easeVarying.js
function easeVarying(id$1, value) {
	return function() {
		var v$1 = value.apply(this, arguments);
		if (typeof v$1 !== "function") throw new Error();
		set(this, id$1).ease = v$1;
	};
}
function easeVarying_default(value) {
	if (typeof value !== "function") throw new Error();
	return this.each(easeVarying(this._id, value));
}

//#endregion
//#region node_modules/d3-transition/src/transition/filter.js
function filter_default(match) {
	if (typeof match !== "function") match = matcher_default(match);
	for (var groups = this._groups, m$2 = groups.length, subgroups = new Array(m$2), j$1 = 0; j$1 < m$2; ++j$1) for (var group = groups[j$1], n$1 = group.length, subgroup = subgroups[j$1] = [], node, i$1 = 0; i$1 < n$1; ++i$1) if ((node = group[i$1]) && match.call(node, node.__data__, i$1, group)) subgroup.push(node);
	return new Transition(subgroups, this._parents, this._name, this._id);
}

//#endregion
//#region node_modules/d3-transition/src/transition/merge.js
function merge_default(transition$1) {
	if (transition$1._id !== this._id) throw new Error();
	for (var groups0 = this._groups, groups1 = transition$1._groups, m0 = groups0.length, m1 = groups1.length, m$2 = Math.min(m0, m1), merges = new Array(m0), j$1 = 0; j$1 < m$2; ++j$1) for (var group0 = groups0[j$1], group1 = groups1[j$1], n$1 = group0.length, merge = merges[j$1] = new Array(n$1), node, i$1 = 0; i$1 < n$1; ++i$1) if (node = group0[i$1] || group1[i$1]) merge[i$1] = node;
	for (; j$1 < m0; ++j$1) merges[j$1] = groups0[j$1];
	return new Transition(merges, this._parents, this._name, this._id);
}

//#endregion
//#region node_modules/d3-transition/src/transition/on.js
function start(name) {
	return (name + "").trim().split(/^|\s+/).every(function(t$2) {
		var i$1 = t$2.indexOf(".");
		if (i$1 >= 0) t$2 = t$2.slice(0, i$1);
		return !t$2 || t$2 === "start";
	});
}
function onFunction(id$1, name, listener) {
	var on0, on1, sit = start(name) ? init : set;
	return function() {
		var schedule = sit(this, id$1), on = schedule.on;
		if (on !== on0) (on1 = (on0 = on).copy()).on(name, listener);
		schedule.on = on1;
	};
}
function on_default(name, listener) {
	var id$1 = this._id;
	return arguments.length < 2 ? get(this.node(), id$1).on.on(name) : this.each(onFunction(id$1, name, listener));
}

//#endregion
//#region node_modules/d3-transition/src/transition/remove.js
function removeFunction(id$1) {
	return function() {
		var parent = this.parentNode;
		for (var i$1 in this.__transition) if (+i$1 !== id$1) return;
		if (parent) parent.removeChild(this);
	};
}
function remove_default$3() {
	return this.on("end.remove", removeFunction(this._id));
}

//#endregion
//#region node_modules/d3-transition/src/transition/select.js
function select_default$1(select) {
	var name = this._name, id$1 = this._id;
	if (typeof select !== "function") select = selector_default(select);
	for (var groups = this._groups, m$2 = groups.length, subgroups = new Array(m$2), j$1 = 0; j$1 < m$2; ++j$1) for (var group = groups[j$1], n$1 = group.length, subgroup = subgroups[j$1] = new Array(n$1), node, subnode, i$1 = 0; i$1 < n$1; ++i$1) if ((node = group[i$1]) && (subnode = select.call(node, node.__data__, i$1, group))) {
		if ("__data__" in node) subnode.__data__ = node.__data__;
		subgroup[i$1] = subnode;
		schedule_default(subgroup[i$1], name, id$1, i$1, subgroup, get(node, id$1));
	}
	return new Transition(subgroups, this._parents, name, id$1);
}

//#endregion
//#region node_modules/d3-transition/src/transition/selectAll.js
function selectAll_default(select) {
	var name = this._name, id$1 = this._id;
	if (typeof select !== "function") select = selectorAll_default(select);
	for (var groups = this._groups, m$2 = groups.length, subgroups = [], parents = [], j$1 = 0; j$1 < m$2; ++j$1) for (var group = groups[j$1], n$1 = group.length, node, i$1 = 0; i$1 < n$1; ++i$1) if (node = group[i$1]) {
		for (var children$1 = select.call(node, node.__data__, i$1, group), child, inherit$1 = get(node, id$1), k$1 = 0, l$1 = children$1.length; k$1 < l$1; ++k$1) if (child = children$1[k$1]) schedule_default(child, name, id$1, k$1, children$1, inherit$1);
		subgroups.push(children$1);
		parents.push(node);
	}
	return new Transition(subgroups, parents, name, id$1);
}

//#endregion
//#region node_modules/d3-transition/src/transition/selection.js
var Selection = selection_default.prototype.constructor;
function selection_default$1() {
	return new Selection(this._groups, this._parents);
}

//#endregion
//#region node_modules/d3-transition/src/transition/style.js
function styleNull(name, interpolate) {
	var string00, string10, interpolate0;
	return function() {
		var string0 = styleValue(this, name), string1 = (this.style.removeProperty(name), styleValue(this, name));
		return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : interpolate0 = interpolate(string00 = string0, string10 = string1);
	};
}
function styleRemove(name) {
	return function() {
		this.style.removeProperty(name);
	};
}
function styleConstant(name, interpolate, value1) {
	var string00, string1 = value1 + "", interpolate0;
	return function() {
		var string0 = styleValue(this, name);
		return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate(string00 = string0, value1);
	};
}
function styleFunction(name, interpolate, value) {
	var string00, string10, interpolate0;
	return function() {
		var string0 = styleValue(this, name), value1 = value(this), string1 = value1 + "";
		if (value1 == null) string1 = value1 = (this.style.removeProperty(name), styleValue(this, name));
		return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
	};
}
function styleMaybeRemove(id$1, name) {
	var on0, on1, listener0, key = "style." + name, event = "end." + key, remove$2;
	return function() {
		var schedule = set(this, id$1), on = schedule.on, listener = schedule.value[key] == null ? remove$2 || (remove$2 = styleRemove(name)) : void 0;
		if (on !== on0 || listener0 !== listener) (on1 = (on0 = on).copy()).on(event, listener0 = listener);
		schedule.on = on1;
	};
}
function style_default(name, value, priority) {
	var i$1 = (name += "") === "transform" ? interpolateTransformCss : interpolate_default;
	return value == null ? this.styleTween(name, styleNull(name, i$1)).on("end.style." + name, styleRemove(name)) : typeof value === "function" ? this.styleTween(name, styleFunction(name, i$1, tweenValue(this, "style." + name, value))).each(styleMaybeRemove(this._id, name)) : this.styleTween(name, styleConstant(name, i$1, value), priority).on("end.style." + name, null);
}

//#endregion
//#region node_modules/d3-transition/src/transition/styleTween.js
function styleInterpolate(name, i$1, priority) {
	return function(t$2) {
		this.style.setProperty(name, i$1.call(this, t$2), priority);
	};
}
function styleTween(name, value, priority) {
	var t$2, i0;
	function tween() {
		var i$1 = value.apply(this, arguments);
		if (i$1 !== i0) t$2 = (i0 = i$1) && styleInterpolate(name, i$1, priority);
		return t$2;
	}
	tween._value = value;
	return tween;
}
function styleTween_default(name, value, priority) {
	var key = "style." + (name += "");
	if (arguments.length < 2) return (key = this.tween(key)) && key._value;
	if (value == null) return this.tween(key, null);
	if (typeof value !== "function") throw new Error();
	return this.tween(key, styleTween(name, value, priority == null ? "" : priority));
}

//#endregion
//#region node_modules/d3-transition/src/transition/text.js
function textConstant(value) {
	return function() {
		this.textContent = value;
	};
}
function textFunction(value) {
	return function() {
		var value1 = value(this);
		this.textContent = value1 == null ? "" : value1;
	};
}
function text_default(value) {
	return this.tween("text", typeof value === "function" ? textFunction(tweenValue(this, "text", value)) : textConstant(value == null ? "" : value + ""));
}

//#endregion
//#region node_modules/d3-transition/src/transition/textTween.js
function textInterpolate(i$1) {
	return function(t$2) {
		this.textContent = i$1.call(this, t$2);
	};
}
function textTween(value) {
	var t0, i0;
	function tween() {
		var i$1 = value.apply(this, arguments);
		if (i$1 !== i0) t0 = (i0 = i$1) && textInterpolate(i$1);
		return t0;
	}
	tween._value = value;
	return tween;
}
function textTween_default(value) {
	var key = "text";
	if (arguments.length < 1) return (key = this.tween(key)) && key._value;
	if (value == null) return this.tween(key, null);
	if (typeof value !== "function") throw new Error();
	return this.tween(key, textTween(value));
}

//#endregion
//#region node_modules/d3-transition/src/transition/transition.js
function transition_default$1() {
	var name = this._name, id0 = this._id, id1 = newId();
	for (var groups = this._groups, m$2 = groups.length, j$1 = 0; j$1 < m$2; ++j$1) for (var group = groups[j$1], n$1 = group.length, node, i$1 = 0; i$1 < n$1; ++i$1) if (node = group[i$1]) {
		var inherit$1 = get(node, id0);
		schedule_default(node, name, id1, i$1, group, {
			time: inherit$1.time + inherit$1.delay + inherit$1.duration,
			delay: 0,
			duration: inherit$1.duration,
			ease: inherit$1.ease
		});
	}
	return new Transition(groups, this._parents, name, id1);
}

//#endregion
//#region node_modules/d3-transition/src/transition/end.js
function end_default() {
	var on0, on1, that = this, id$1 = that._id, size = that.size();
	return new Promise(function(resolve, reject) {
		var cancel = { value: reject }, end = { value: function() {
			if (--size === 0) resolve();
		} };
		that.each(function() {
			var schedule = set(this, id$1), on = schedule.on;
			if (on !== on0) {
				on1 = (on0 = on).copy();
				on1._.cancel.push(cancel);
				on1._.interrupt.push(cancel);
				on1._.end.push(end);
			}
			schedule.on = on1;
		});
		if (size === 0) resolve();
	});
}

//#endregion
//#region node_modules/d3-transition/src/transition/index.js
var id = 0;
function Transition(groups, parents, name, id$1) {
	this._groups = groups;
	this._parents = parents;
	this._name = name;
	this._id = id$1;
}
function transition(name) {
	return selection_default().transition(name);
}
function newId() {
	return ++id;
}
var selection_prototype = selection_default.prototype;
Transition.prototype = transition.prototype = {
	constructor: Transition,
	select: select_default$1,
	selectAll: selectAll_default,
	selectChild: selection_prototype.selectChild,
	selectChildren: selection_prototype.selectChildren,
	filter: filter_default,
	merge: merge_default,
	selection: selection_default$1,
	transition: transition_default$1,
	call: selection_prototype.call,
	nodes: selection_prototype.nodes,
	node: selection_prototype.node,
	size: selection_prototype.size,
	empty: selection_prototype.empty,
	each: selection_prototype.each,
	on: on_default,
	attr: attr_default,
	attrTween: attrTween_default,
	style: style_default,
	styleTween: styleTween_default,
	text: text_default,
	textTween: textTween_default,
	remove: remove_default$3,
	tween: tween_default,
	delay: delay_default,
	duration: duration_default,
	ease: ease_default,
	easeVarying: easeVarying_default,
	end: end_default,
	[Symbol.iterator]: selection_prototype[Symbol.iterator]
};

//#endregion
//#region node_modules/d3-ease/src/cubic.js
function cubicInOut(t$2) {
	return ((t$2 *= 2) <= 1 ? t$2 * t$2 * t$2 : (t$2 -= 2) * t$2 * t$2 + 2) / 2;
}

//#endregion
//#region node_modules/d3-transition/src/selection/transition.js
var defaultTiming = {
	time: null,
	delay: 0,
	duration: 250,
	ease: cubicInOut
};
function inherit(node, id$1) {
	var timing;
	while (!(timing = node.__transition) || !(timing = timing[id$1])) if (!(node = node.parentNode)) throw new Error(`transition ${id$1} not found`);
	return timing;
}
function transition_default(name) {
	var id$1, timing;
	if (name instanceof Transition) id$1 = name._id, name = name._name;
	else id$1 = newId(), (timing = defaultTiming).time = now$2(), name = name == null ? null : name + "";
	for (var groups = this._groups, m$2 = groups.length, j$1 = 0; j$1 < m$2; ++j$1) for (var group = groups[j$1], n$1 = group.length, node, i$1 = 0; i$1 < n$1; ++i$1) if (node = group[i$1]) schedule_default(node, name, id$1, i$1, group, timing || inherit(node, id$1));
	return new Transition(groups, this._parents, name, id$1);
}

//#endregion
//#region node_modules/d3-transition/src/selection/index.js
selection_default.prototype.interrupt = interrupt_default$1;
selection_default.prototype.transition = transition_default;

//#endregion
//#region node_modules/d3-zoom/src/constant.js
var constant_default$1 = (x$2) => () => x$2;

//#endregion
//#region node_modules/d3-zoom/src/event.js
function ZoomEvent(type, { sourceEvent, target, transform: transform$1, dispatch: dispatch$1 }) {
	Object.defineProperties(this, {
		type: {
			value: type,
			enumerable: true,
			configurable: true
		},
		sourceEvent: {
			value: sourceEvent,
			enumerable: true,
			configurable: true
		},
		target: {
			value: target,
			enumerable: true,
			configurable: true
		},
		transform: {
			value: transform$1,
			enumerable: true,
			configurable: true
		},
		_: { value: dispatch$1 }
	});
}

//#endregion
//#region node_modules/d3-zoom/src/transform.js
function Transform(k$1, x$2, y$2) {
	this.k = k$1;
	this.x = x$2;
	this.y = y$2;
}
Transform.prototype = {
	constructor: Transform,
	scale: function(k$1) {
		return k$1 === 1 ? this : new Transform(this.k * k$1, this.x, this.y);
	},
	translate: function(x$2, y$2) {
		return x$2 === 0 & y$2 === 0 ? this : new Transform(this.k, this.x + this.k * x$2, this.y + this.k * y$2);
	},
	apply: function(point) {
		return [point[0] * this.k + this.x, point[1] * this.k + this.y];
	},
	applyX: function(x$2) {
		return x$2 * this.k + this.x;
	},
	applyY: function(y$2) {
		return y$2 * this.k + this.y;
	},
	invert: function(location) {
		return [(location[0] - this.x) / this.k, (location[1] - this.y) / this.k];
	},
	invertX: function(x$2) {
		return (x$2 - this.x) / this.k;
	},
	invertY: function(y$2) {
		return (y$2 - this.y) / this.k;
	},
	rescaleX: function(x$2) {
		return x$2.copy().domain(x$2.range().map(this.invertX, this).map(x$2.invert, x$2));
	},
	rescaleY: function(y$2) {
		return y$2.copy().domain(y$2.range().map(this.invertY, this).map(y$2.invert, y$2));
	},
	toString: function() {
		return "translate(" + this.x + "," + this.y + ") scale(" + this.k + ")";
	}
};
var identity = new Transform(1, 0, 0);
transform.prototype = Transform.prototype;
function transform(node) {
	while (!node.__zoom) if (!(node = node.parentNode)) return identity;
	return node.__zoom;
}

//#endregion
//#region node_modules/d3-zoom/src/noevent.js
function nopropagation(event) {
	event.stopImmediatePropagation();
}
function noevent_default(event) {
	event.preventDefault();
	event.stopImmediatePropagation();
}

//#endregion
//#region node_modules/d3-zoom/src/zoom.js
function defaultFilter(event) {
	return (!event.ctrlKey || event.type === "wheel") && !event.button;
}
function defaultExtent() {
	var e$1 = this;
	if (e$1 instanceof SVGElement) {
		e$1 = e$1.ownerSVGElement || e$1;
		if (e$1.hasAttribute("viewBox")) {
			e$1 = e$1.viewBox.baseVal;
			return [[e$1.x, e$1.y], [e$1.x + e$1.width, e$1.y + e$1.height]];
		}
		return [[0, 0], [e$1.width.baseVal.value, e$1.height.baseVal.value]];
	}
	return [[0, 0], [e$1.clientWidth, e$1.clientHeight]];
}
function defaultTransform() {
	return this.__zoom || identity;
}
function defaultWheelDelta(event) {
	return -event.deltaY * (event.deltaMode === 1 ? .05 : event.deltaMode ? 1 : .002) * (event.ctrlKey ? 10 : 1);
}
function defaultTouchable() {
	return navigator.maxTouchPoints || "ontouchstart" in this;
}
function defaultConstrain(transform$1, extent, translateExtent) {
	var dx0 = transform$1.invertX(extent[0][0]) - translateExtent[0][0], dx1 = transform$1.invertX(extent[1][0]) - translateExtent[1][0], dy0 = transform$1.invertY(extent[0][1]) - translateExtent[0][1], dy1 = transform$1.invertY(extent[1][1]) - translateExtent[1][1];
	return transform$1.translate(dx1 > dx0 ? (dx0 + dx1) / 2 : Math.min(0, dx0) || Math.max(0, dx1), dy1 > dy0 ? (dy0 + dy1) / 2 : Math.min(0, dy0) || Math.max(0, dy1));
}
function zoom_default() {
	var filter$1 = defaultFilter, extent = defaultExtent, constrain = defaultConstrain, wheelDelta = defaultWheelDelta, touchable = defaultTouchable, scaleExtent = [0, Infinity], translateExtent = [[-Infinity, -Infinity], [Infinity, Infinity]], duration = 250, interpolate = zoom_default$1, listeners = dispatch_default("start", "zoom", "end"), touchstarting, touchfirst, touchending, touchDelay = 500, wheelDelay = 150, clickDistance2 = 0, tapDistance = 10;
	function zoom(selection$1) {
		selection$1.property("__zoom", defaultTransform).on("wheel.zoom", wheeled, { passive: false }).on("mousedown.zoom", mousedowned).on("dblclick.zoom", dblclicked).filter(touchable).on("touchstart.zoom", touchstarted).on("touchmove.zoom", touchmoved).on("touchend.zoom touchcancel.zoom", touchended).style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
	}
	zoom.transform = function(collection, transform$1, point, event) {
		var selection$1 = collection.selection ? collection.selection() : collection;
		selection$1.property("__zoom", defaultTransform);
		if (collection !== selection$1) schedule(collection, transform$1, point, event);
		else selection$1.interrupt().each(function() {
			gesture(this, arguments).event(event).start().zoom(null, typeof transform$1 === "function" ? transform$1.apply(this, arguments) : transform$1).end();
		});
	};
	zoom.scaleBy = function(selection$1, k$1, p$1, event) {
		zoom.scaleTo(selection$1, function() {
			return this.__zoom.k * (typeof k$1 === "function" ? k$1.apply(this, arguments) : k$1);
		}, p$1, event);
	};
	zoom.scaleTo = function(selection$1, k$1, p$1, event) {
		zoom.transform(selection$1, function() {
			var e$1 = extent.apply(this, arguments), t0 = this.__zoom, p0 = p$1 == null ? centroid(e$1) : typeof p$1 === "function" ? p$1.apply(this, arguments) : p$1, p1 = t0.invert(p0), k1 = typeof k$1 === "function" ? k$1.apply(this, arguments) : k$1;
			return constrain(translate(scale(t0, k1), p0, p1), e$1, translateExtent);
		}, p$1, event);
	};
	zoom.translateBy = function(selection$1, x$2, y$2, event) {
		zoom.transform(selection$1, function() {
			return constrain(this.__zoom.translate(typeof x$2 === "function" ? x$2.apply(this, arguments) : x$2, typeof y$2 === "function" ? y$2.apply(this, arguments) : y$2), extent.apply(this, arguments), translateExtent);
		}, null, event);
	};
	zoom.translateTo = function(selection$1, x$2, y$2, p$1, event) {
		zoom.transform(selection$1, function() {
			var e$1 = extent.apply(this, arguments), t$2 = this.__zoom, p0 = p$1 == null ? centroid(e$1) : typeof p$1 === "function" ? p$1.apply(this, arguments) : p$1;
			return constrain(identity.translate(p0[0], p0[1]).scale(t$2.k).translate(typeof x$2 === "function" ? -x$2.apply(this, arguments) : -x$2, typeof y$2 === "function" ? -y$2.apply(this, arguments) : -y$2), e$1, translateExtent);
		}, p$1, event);
	};
	function scale(transform$1, k$1) {
		k$1 = Math.max(scaleExtent[0], Math.min(scaleExtent[1], k$1));
		return k$1 === transform$1.k ? transform$1 : new Transform(k$1, transform$1.x, transform$1.y);
	}
	function translate(transform$1, p0, p1) {
		var x$2 = p0[0] - p1[0] * transform$1.k, y$2 = p0[1] - p1[1] * transform$1.k;
		return x$2 === transform$1.x && y$2 === transform$1.y ? transform$1 : new Transform(transform$1.k, x$2, y$2);
	}
	function centroid(extent$1) {
		return [(+extent$1[0][0] + +extent$1[1][0]) / 2, (+extent$1[0][1] + +extent$1[1][1]) / 2];
	}
	function schedule(transition$1, transform$1, point, event) {
		transition$1.on("start.zoom", function() {
			gesture(this, arguments).event(event).start();
		}).on("interrupt.zoom end.zoom", function() {
			gesture(this, arguments).event(event).end();
		}).tween("zoom", function() {
			var that = this, args = arguments, g$1 = gesture(that, args).event(event), e$1 = extent.apply(that, args), p$1 = point == null ? centroid(e$1) : typeof point === "function" ? point.apply(that, args) : point, w$1 = Math.max(e$1[1][0] - e$1[0][0], e$1[1][1] - e$1[0][1]), a$2 = that.__zoom, b = typeof transform$1 === "function" ? transform$1.apply(that, args) : transform$1, i$1 = interpolate(a$2.invert(p$1).concat(w$1 / a$2.k), b.invert(p$1).concat(w$1 / b.k));
			return function(t$2) {
				if (t$2 === 1) t$2 = b;
				else {
					var l$1 = i$1(t$2), k$1 = w$1 / l$1[2];
					t$2 = new Transform(k$1, p$1[0] - l$1[0] * k$1, p$1[1] - l$1[1] * k$1);
				}
				g$1.zoom(null, t$2);
			};
		});
	}
	function gesture(that, args, clean) {
		return !clean && that.__zooming || new Gesture(that, args);
	}
	function Gesture(that, args) {
		this.that = that;
		this.args = args;
		this.active = 0;
		this.sourceEvent = null;
		this.extent = extent.apply(that, args);
		this.taps = 0;
	}
	Gesture.prototype = {
		event: function(event) {
			if (event) this.sourceEvent = event;
			return this;
		},
		start: function() {
			if (++this.active === 1) {
				this.that.__zooming = this;
				this.emit("start");
			}
			return this;
		},
		zoom: function(key, transform$1) {
			if (this.mouse && key !== "mouse") this.mouse[1] = transform$1.invert(this.mouse[0]);
			if (this.touch0 && key !== "touch") this.touch0[1] = transform$1.invert(this.touch0[0]);
			if (this.touch1 && key !== "touch") this.touch1[1] = transform$1.invert(this.touch1[0]);
			this.that.__zoom = transform$1;
			this.emit("zoom");
			return this;
		},
		end: function() {
			if (--this.active === 0) {
				delete this.that.__zooming;
				this.emit("end");
			}
			return this;
		},
		emit: function(type) {
			var d$1 = select_default(this.that).datum();
			listeners.call(type, this.that, new ZoomEvent(type, {
				sourceEvent: this.sourceEvent,
				target: zoom,
				type,
				transform: this.that.__zoom,
				dispatch: listeners
			}), d$1);
		}
	};
	function wheeled(event, ...args) {
		if (!filter$1.apply(this, arguments)) return;
		var g$1 = gesture(this, args).event(event), t$2 = this.__zoom, k$1 = Math.max(scaleExtent[0], Math.min(scaleExtent[1], t$2.k * Math.pow(2, wheelDelta.apply(this, arguments)))), p$1 = pointer_default(event);
		if (g$1.wheel) {
			if (g$1.mouse[0][0] !== p$1[0] || g$1.mouse[0][1] !== p$1[1]) g$1.mouse[1] = t$2.invert(g$1.mouse[0] = p$1);
			clearTimeout(g$1.wheel);
		} else if (t$2.k === k$1) return;
		else {
			g$1.mouse = [p$1, t$2.invert(p$1)];
			interrupt_default(this);
			g$1.start();
		}
		noevent_default(event);
		g$1.wheel = setTimeout(wheelidled, wheelDelay);
		g$1.zoom("mouse", constrain(translate(scale(t$2, k$1), g$1.mouse[0], g$1.mouse[1]), g$1.extent, translateExtent));
		function wheelidled() {
			g$1.wheel = null;
			g$1.end();
		}
	}
	function mousedowned(event, ...args) {
		if (touchending || !filter$1.apply(this, arguments)) return;
		var currentTarget = event.currentTarget, g$1 = gesture(this, args, true).event(event), v$1 = select_default(event.view).on("mousemove.zoom", mousemoved, true).on("mouseup.zoom", mouseupped, true), p$1 = pointer_default(event, currentTarget), x0 = event.clientX, y0 = event.clientY;
		nodrag_default(event.view);
		nopropagation(event);
		g$1.mouse = [p$1, this.__zoom.invert(p$1)];
		interrupt_default(this);
		g$1.start();
		function mousemoved(event$1) {
			noevent_default(event$1);
			if (!g$1.moved) {
				var dx = event$1.clientX - x0, dy = event$1.clientY - y0;
				g$1.moved = dx * dx + dy * dy > clickDistance2;
			}
			g$1.event(event$1).zoom("mouse", constrain(translate(g$1.that.__zoom, g$1.mouse[0] = pointer_default(event$1, currentTarget), g$1.mouse[1]), g$1.extent, translateExtent));
		}
		function mouseupped(event$1) {
			v$1.on("mousemove.zoom mouseup.zoom", null);
			yesdrag(event$1.view, g$1.moved);
			noevent_default(event$1);
			g$1.event(event$1).end();
		}
	}
	function dblclicked(event, ...args) {
		if (!filter$1.apply(this, arguments)) return;
		var t0 = this.__zoom, p0 = pointer_default(event.changedTouches ? event.changedTouches[0] : event, this), p1 = t0.invert(p0), k1 = t0.k * (event.shiftKey ? .5 : 2), t1 = constrain(translate(scale(t0, k1), p0, p1), extent.apply(this, args), translateExtent);
		noevent_default(event);
		if (duration > 0) select_default(this).transition().duration(duration).call(schedule, t1, p0, event);
		else select_default(this).call(zoom.transform, t1, p0, event);
	}
	function touchstarted(event, ...args) {
		if (!filter$1.apply(this, arguments)) return;
		var touches = event.touches, n$1 = touches.length, g$1 = gesture(this, args, event.changedTouches.length === n$1).event(event), started, i$1, t$2, p$1;
		nopropagation(event);
		for (i$1 = 0; i$1 < n$1; ++i$1) {
			t$2 = touches[i$1], p$1 = pointer_default(t$2, this);
			p$1 = [
				p$1,
				this.__zoom.invert(p$1),
				t$2.identifier
			];
			if (!g$1.touch0) g$1.touch0 = p$1, started = true, g$1.taps = 1 + !!touchstarting;
			else if (!g$1.touch1 && g$1.touch0[2] !== p$1[2]) g$1.touch1 = p$1, g$1.taps = 0;
		}
		if (touchstarting) touchstarting = clearTimeout(touchstarting);
		if (started) {
			if (g$1.taps < 2) touchfirst = p$1[0], touchstarting = setTimeout(function() {
				touchstarting = null;
			}, touchDelay);
			interrupt_default(this);
			g$1.start();
		}
	}
	function touchmoved(event, ...args) {
		if (!this.__zooming) return;
		var g$1 = gesture(this, args).event(event), touches = event.changedTouches, n$1 = touches.length, i$1, t$2, p$1, l$1;
		noevent_default(event);
		for (i$1 = 0; i$1 < n$1; ++i$1) {
			t$2 = touches[i$1], p$1 = pointer_default(t$2, this);
			if (g$1.touch0 && g$1.touch0[2] === t$2.identifier) g$1.touch0[0] = p$1;
			else if (g$1.touch1 && g$1.touch1[2] === t$2.identifier) g$1.touch1[0] = p$1;
		}
		t$2 = g$1.that.__zoom;
		if (g$1.touch1) {
			var p0 = g$1.touch0[0], l0 = g$1.touch0[1], p1 = g$1.touch1[0], l1 = g$1.touch1[1], dp = (dp = p1[0] - p0[0]) * dp + (dp = p1[1] - p0[1]) * dp, dl = (dl = l1[0] - l0[0]) * dl + (dl = l1[1] - l0[1]) * dl;
			t$2 = scale(t$2, Math.sqrt(dp / dl));
			p$1 = [(p0[0] + p1[0]) / 2, (p0[1] + p1[1]) / 2];
			l$1 = [(l0[0] + l1[0]) / 2, (l0[1] + l1[1]) / 2];
		} else if (g$1.touch0) p$1 = g$1.touch0[0], l$1 = g$1.touch0[1];
		else return;
		g$1.zoom("touch", constrain(translate(t$2, p$1, l$1), g$1.extent, translateExtent));
	}
	function touchended(event, ...args) {
		if (!this.__zooming) return;
		var g$1 = gesture(this, args).event(event), touches = event.changedTouches, n$1 = touches.length, i$1, t$2;
		nopropagation(event);
		if (touchending) clearTimeout(touchending);
		touchending = setTimeout(function() {
			touchending = null;
		}, touchDelay);
		for (i$1 = 0; i$1 < n$1; ++i$1) {
			t$2 = touches[i$1];
			if (g$1.touch0 && g$1.touch0[2] === t$2.identifier) delete g$1.touch0;
			else if (g$1.touch1 && g$1.touch1[2] === t$2.identifier) delete g$1.touch1;
		}
		if (g$1.touch1 && !g$1.touch0) g$1.touch0 = g$1.touch1, delete g$1.touch1;
		if (g$1.touch0) g$1.touch0[1] = this.__zoom.invert(g$1.touch0[0]);
		else {
			g$1.end();
			if (g$1.taps === 2) {
				t$2 = pointer_default(t$2, this);
				if (Math.hypot(touchfirst[0] - t$2[0], touchfirst[1] - t$2[1]) < tapDistance) {
					var p$1 = select_default(this).on("dblclick.zoom");
					if (p$1) p$1.apply(this, arguments);
				}
			}
		}
	}
	zoom.wheelDelta = function(_$1) {
		return arguments.length ? (wheelDelta = typeof _$1 === "function" ? _$1 : constant_default$1(+_$1), zoom) : wheelDelta;
	};
	zoom.filter = function(_$1) {
		return arguments.length ? (filter$1 = typeof _$1 === "function" ? _$1 : constant_default$1(!!_$1), zoom) : filter$1;
	};
	zoom.touchable = function(_$1) {
		return arguments.length ? (touchable = typeof _$1 === "function" ? _$1 : constant_default$1(!!_$1), zoom) : touchable;
	};
	zoom.extent = function(_$1) {
		return arguments.length ? (extent = typeof _$1 === "function" ? _$1 : constant_default$1([[+_$1[0][0], +_$1[0][1]], [+_$1[1][0], +_$1[1][1]]]), zoom) : extent;
	};
	zoom.scaleExtent = function(_$1) {
		return arguments.length ? (scaleExtent[0] = +_$1[0], scaleExtent[1] = +_$1[1], zoom) : [scaleExtent[0], scaleExtent[1]];
	};
	zoom.translateExtent = function(_$1) {
		return arguments.length ? (translateExtent[0][0] = +_$1[0][0], translateExtent[1][0] = +_$1[1][0], translateExtent[0][1] = +_$1[0][1], translateExtent[1][1] = +_$1[1][1], zoom) : [[translateExtent[0][0], translateExtent[0][1]], [translateExtent[1][0], translateExtent[1][1]]];
	};
	zoom.constrain = function(_$1) {
		return arguments.length ? (constrain = _$1, zoom) : constrain;
	};
	zoom.duration = function(_$1) {
		return arguments.length ? (duration = +_$1, zoom) : duration;
	};
	zoom.interpolate = function(_$1) {
		return arguments.length ? (interpolate = _$1, zoom) : interpolate;
	};
	zoom.on = function() {
		var value = listeners.on.apply(listeners, arguments);
		return value === listeners ? zoom : value;
	};
	zoom.clickDistance = function(_$1) {
		return arguments.length ? (clickDistance2 = (_$1 = +_$1) * _$1, zoom) : Math.sqrt(clickDistance2);
	};
	zoom.tapDistance = function(_$1) {
		return arguments.length ? (tapDistance = +_$1, zoom) : tapDistance;
	};
	return zoom;
}

//#endregion
//#region node_modules/internmap/src/index.js
var InternMap = class extends Map {
	constructor(entries, key = keyof) {
		super();
		Object.defineProperties(this, {
			_intern: { value: /* @__PURE__ */ new Map() },
			_key: { value: key }
		});
		if (entries != null) for (const [key$1, value] of entries) this.set(key$1, value);
	}
	get(key) {
		return super.get(intern_get(this, key));
	}
	has(key) {
		return super.has(intern_get(this, key));
	}
	set(key, value) {
		return super.set(intern_set(this, key), value);
	}
	delete(key) {
		return super.delete(intern_delete(this, key));
	}
};
function intern_get({ _intern, _key }, value) {
	const key = _key(value);
	return _intern.has(key) ? _intern.get(key) : value;
}
function intern_set({ _intern, _key }, value) {
	const key = _key(value);
	if (_intern.has(key)) return _intern.get(key);
	_intern.set(key, value);
	return value;
}
function intern_delete({ _intern, _key }, value) {
	const key = _key(value);
	if (_intern.has(key)) {
		value = _intern.get(key);
		_intern.delete(key);
	}
	return value;
}
function keyof(value) {
	return value !== null && typeof value === "object" ? value.valueOf() : value;
}

//#endregion
//#region node_modules/d3-array/src/max.js
function max(values, valueof) {
	let max$2;
	if (valueof === void 0) {
		for (const value of values) if (value != null && (max$2 < value || max$2 === void 0 && value >= value)) max$2 = value;
	} else {
		let index$6 = -1;
		for (let value of values) if ((value = valueof(value, ++index$6, values)) != null && (max$2 < value || max$2 === void 0 && value >= value)) max$2 = value;
	}
	return max$2;
}

//#endregion
//#region node_modules/d3-array/src/min.js
function min(values, valueof) {
	let min$2;
	if (valueof === void 0) {
		for (const value of values) if (value != null && (min$2 > value || min$2 === void 0 && value >= value)) min$2 = value;
	} else {
		let index$6 = -1;
		for (let value of values) if ((value = valueof(value, ++index$6, values)) != null && (min$2 > value || min$2 === void 0 && value >= value)) min$2 = value;
	}
	return min$2;
}

//#endregion
//#region node_modules/d3-array/src/sum.js
function sum(values, valueof) {
	let sum$1 = 0;
	if (valueof === void 0) {
		for (let value of values) if (value = +value) sum$1 += value;
	} else {
		let index$6 = -1;
		for (let value of values) if (value = +valueof(value, ++index$6, values)) sum$1 += value;
	}
	return sum$1;
}

//#endregion
//#region node_modules/lodash-es/_freeGlobal.js
/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
var _freeGlobal_default = freeGlobal;

//#endregion
//#region node_modules/lodash-es/_root.js
/** Detect free variable `self`. */
var freeSelf = typeof self == "object" && self && self.Object === Object && self;
/** Used as a reference to the global object. */
var root = _freeGlobal_default || freeSelf || Function("return this")();
var _root_default = root;

//#endregion
//#region node_modules/lodash-es/_Symbol.js
/** Built-in value references. */
var Symbol$1 = _root_default.Symbol;
var _Symbol_default = Symbol$1;

//#endregion
//#region node_modules/lodash-es/_getRawTag.js
/** Used for built-in method references. */
var objectProto = Object.prototype;
/** Used to check objects for own properties. */
var hasOwnProperty$1 = objectProto.hasOwnProperty;
/**
* Used to resolve the
* [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
* of values.
*/
var nativeObjectToString$1 = objectProto.toString;
/** Built-in value references. */
var symToStringTag$1 = _Symbol_default ? _Symbol_default.toStringTag : void 0;
/**
* A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
*
* @private
* @param {*} value The value to query.
* @returns {string} Returns the raw `toStringTag`.
*/
function getRawTag(value) {
	var isOwn = hasOwnProperty$1.call(value, symToStringTag$1), tag = value[symToStringTag$1];
	try {
		value[symToStringTag$1] = void 0;
		var unmasked = true;
	} catch (e$1) {}
	var result = nativeObjectToString$1.call(value);
	if (unmasked) if (isOwn) value[symToStringTag$1] = tag;
	else delete value[symToStringTag$1];
	return result;
}
var _getRawTag_default = getRawTag;

//#endregion
//#region node_modules/lodash-es/_objectToString.js
/**
* Used to resolve the
* [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
* of values.
*/
var nativeObjectToString = Object.prototype.toString;
/**
* Converts `value` to a string using `Object.prototype.toString`.
*
* @private
* @param {*} value The value to convert.
* @returns {string} Returns the converted string.
*/
function objectToString(value) {
	return nativeObjectToString.call(value);
}
var _objectToString_default = objectToString;

//#endregion
//#region node_modules/lodash-es/_baseGetTag.js
/** `Object#toString` result references. */
var nullTag = "[object Null]", undefinedTag = "[object Undefined]";
/** Built-in value references. */
var symToStringTag = _Symbol_default ? _Symbol_default.toStringTag : void 0;
/**
* The base implementation of `getTag` without fallbacks for buggy environments.
*
* @private
* @param {*} value The value to query.
* @returns {string} Returns the `toStringTag`.
*/
function baseGetTag(value) {
	if (value == null) return value === void 0 ? undefinedTag : nullTag;
	return symToStringTag && symToStringTag in Object(value) ? _getRawTag_default(value) : _objectToString_default(value);
}
var _baseGetTag_default = baseGetTag;

//#endregion
//#region node_modules/lodash-es/isObjectLike.js
/**
* Checks if `value` is object-like. A value is object-like if it's not `null`
* and has a `typeof` result of "object".
*
* @static
* @memberOf _
* @since 4.0.0
* @category Lang
* @param {*} value The value to check.
* @returns {boolean} Returns `true` if `value` is object-like, else `false`.
* @example
*
* _.isObjectLike({});
* // => true
*
* _.isObjectLike([1, 2, 3]);
* // => true
*
* _.isObjectLike(_.noop);
* // => false
*
* _.isObjectLike(null);
* // => false
*/
function isObjectLike(value) {
	return value != null && typeof value == "object";
}
var isObjectLike_default = isObjectLike;

//#endregion
//#region node_modules/lodash-es/isSymbol.js
/** `Object#toString` result references. */
var symbolTag = "[object Symbol]";
/**
* Checks if `value` is classified as a `Symbol` primitive or object.
*
* @static
* @memberOf _
* @since 4.0.0
* @category Lang
* @param {*} value The value to check.
* @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
* @example
*
* _.isSymbol(Symbol.iterator);
* // => true
*
* _.isSymbol('abc');
* // => false
*/
function isSymbol(value) {
	return typeof value == "symbol" || isObjectLike_default(value) && _baseGetTag_default(value) == symbolTag;
}
var isSymbol_default = isSymbol;

//#endregion
//#region node_modules/lodash-es/_trimmedEndIndex.js
/** Used to match a single whitespace character. */
var reWhitespace = /\s/;
/**
* Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace
* character of `string`.
*
* @private
* @param {string} string The string to inspect.
* @returns {number} Returns the index of the last non-whitespace character.
*/
function trimmedEndIndex(string) {
	var index$6 = string.length;
	while (index$6-- && reWhitespace.test(string.charAt(index$6)));
	return index$6;
}
var _trimmedEndIndex_default = trimmedEndIndex;

//#endregion
//#region node_modules/lodash-es/_baseTrim.js
/** Used to match leading whitespace. */
var reTrimStart = /^\s+/;
/**
* The base implementation of `_.trim`.
*
* @private
* @param {string} string The string to trim.
* @returns {string} Returns the trimmed string.
*/
function baseTrim(string) {
	return string ? string.slice(0, _trimmedEndIndex_default(string) + 1).replace(reTrimStart, "") : string;
}
var _baseTrim_default = baseTrim;

//#endregion
//#region node_modules/lodash-es/isObject.js
/**
* Checks if `value` is the
* [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
* of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
*
* @static
* @memberOf _
* @since 0.1.0
* @category Lang
* @param {*} value The value to check.
* @returns {boolean} Returns `true` if `value` is an object, else `false`.
* @example
*
* _.isObject({});
* // => true
*
* _.isObject([1, 2, 3]);
* // => true
*
* _.isObject(_.noop);
* // => true
*
* _.isObject(null);
* // => false
*/
function isObject(value) {
	var type = typeof value;
	return value != null && (type == "object" || type == "function");
}
var isObject_default = isObject;

//#endregion
//#region node_modules/lodash-es/toNumber.js
/** Used as references for various `Number` constants. */
var NAN = NaN;
/** Used to detect bad signed hexadecimal string values. */
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
/** Used to detect binary string values. */
var reIsBinary = /^0b[01]+$/i;
/** Used to detect octal string values. */
var reIsOctal = /^0o[0-7]+$/i;
/** Built-in method references without a dependency on `root`. */
var freeParseInt = parseInt;
/**
* Converts `value` to a number.
*
* @static
* @memberOf _
* @since 4.0.0
* @category Lang
* @param {*} value The value to process.
* @returns {number} Returns the number.
* @example
*
* _.toNumber(3.2);
* // => 3.2
*
* _.toNumber(Number.MIN_VALUE);
* // => 5e-324
*
* _.toNumber(Infinity);
* // => Infinity
*
* _.toNumber('3.2');
* // => 3.2
*/
function toNumber(value) {
	if (typeof value == "number") return value;
	if (isSymbol_default(value)) return NAN;
	if (isObject_default(value)) {
		var other = typeof value.valueOf == "function" ? value.valueOf() : value;
		value = isObject_default(other) ? other + "" : other;
	}
	if (typeof value != "string") return value === 0 ? value : +value;
	value = _baseTrim_default(value);
	var isBinary = reIsBinary.test(value);
	return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
}
var toNumber_default = toNumber;

//#endregion
//#region node_modules/lodash-es/now.js
/**
* Gets the timestamp of the number of milliseconds that have elapsed since
* the Unix epoch (1 January 1970 00:00:00 UTC).
*
* @static
* @memberOf _
* @since 2.4.0
* @category Date
* @returns {number} Returns the timestamp.
* @example
*
* _.defer(function(stamp) {
*   console.log(_.now() - stamp);
* }, _.now());
* // => Logs the number of milliseconds it took for the deferred invocation.
*/
var now$1 = function() {
	return _root_default.Date.now();
};
var now_default = now$1;

//#endregion
//#region node_modules/lodash-es/debounce.js
/** Error message constants. */
var FUNC_ERROR_TEXT$1 = "Expected a function";
var nativeMax = Math.max, nativeMin = Math.min;
/**
* Creates a debounced function that delays invoking `func` until after `wait`
* milliseconds have elapsed since the last time the debounced function was
* invoked. The debounced function comes with a `cancel` method to cancel
* delayed `func` invocations and a `flush` method to immediately invoke them.
* Provide `options` to indicate whether `func` should be invoked on the
* leading and/or trailing edge of the `wait` timeout. The `func` is invoked
* with the last arguments provided to the debounced function. Subsequent
* calls to the debounced function return the result of the last `func`
* invocation.
*
* **Note:** If `leading` and `trailing` options are `true`, `func` is
* invoked on the trailing edge of the timeout only if the debounced function
* is invoked more than once during the `wait` timeout.
*
* If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
* until to the next tick, similar to `setTimeout` with a timeout of `0`.
*
* See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
* for details over the differences between `_.debounce` and `_.throttle`.
*
* @static
* @memberOf _
* @since 0.1.0
* @category Function
* @param {Function} func The function to debounce.
* @param {number} [wait=0] The number of milliseconds to delay.
* @param {Object} [options={}] The options object.
* @param {boolean} [options.leading=false]
*  Specify invoking on the leading edge of the timeout.
* @param {number} [options.maxWait]
*  The maximum time `func` is allowed to be delayed before it's invoked.
* @param {boolean} [options.trailing=true]
*  Specify invoking on the trailing edge of the timeout.
* @returns {Function} Returns the new debounced function.
* @example
*
* // Avoid costly calculations while the window size is in flux.
* jQuery(window).on('resize', _.debounce(calculateLayout, 150));
*
* // Invoke `sendMail` when clicked, debouncing subsequent calls.
* jQuery(element).on('click', _.debounce(sendMail, 300, {
*   'leading': true,
*   'trailing': false
* }));
*
* // Ensure `batchLog` is invoked once after 1 second of debounced calls.
* var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
* var source = new EventSource('/stream');
* jQuery(source).on('message', debounced);
*
* // Cancel the trailing debounced invocation.
* jQuery(window).on('popstate', debounced.cancel);
*/
function debounce(func, wait, options) {
	var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
	if (typeof func != "function") throw new TypeError(FUNC_ERROR_TEXT$1);
	wait = toNumber_default(wait) || 0;
	if (isObject_default(options)) {
		leading = !!options.leading;
		maxing = "maxWait" in options;
		maxWait = maxing ? nativeMax(toNumber_default(options.maxWait) || 0, wait) : maxWait;
		trailing = "trailing" in options ? !!options.trailing : trailing;
	}
	function invokeFunc(time) {
		var args = lastArgs, thisArg = lastThis;
		lastArgs = lastThis = void 0;
		lastInvokeTime = time;
		result = func.apply(thisArg, args);
		return result;
	}
	function leadingEdge(time) {
		lastInvokeTime = time;
		timerId = setTimeout(timerExpired, wait);
		return leading ? invokeFunc(time) : result;
	}
	function remainingWait(time) {
		var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
		return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
	}
	function shouldInvoke(time) {
		var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
		return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
	}
	function timerExpired() {
		var time = now_default();
		if (shouldInvoke(time)) return trailingEdge(time);
		timerId = setTimeout(timerExpired, remainingWait(time));
	}
	function trailingEdge(time) {
		timerId = void 0;
		if (trailing && lastArgs) return invokeFunc(time);
		lastArgs = lastThis = void 0;
		return result;
	}
	function cancel() {
		if (timerId !== void 0) clearTimeout(timerId);
		lastInvokeTime = 0;
		lastArgs = lastCallTime = lastThis = timerId = void 0;
	}
	function flush() {
		return timerId === void 0 ? result : trailingEdge(now_default());
	}
	function debounced() {
		var time = now_default(), isInvoking = shouldInvoke(time);
		lastArgs = arguments;
		lastThis = this;
		lastCallTime = time;
		if (isInvoking) {
			if (timerId === void 0) return leadingEdge(lastCallTime);
			if (maxing) {
				clearTimeout(timerId);
				timerId = setTimeout(timerExpired, wait);
				return invokeFunc(lastCallTime);
			}
		}
		if (timerId === void 0) timerId = setTimeout(timerExpired, wait);
		return result;
	}
	debounced.cancel = cancel;
	debounced.flush = flush;
	return debounced;
}
var debounce_default = debounce;

//#endregion
//#region node_modules/lodash-es/throttle.js
/** Error message constants. */
var FUNC_ERROR_TEXT = "Expected a function";
/**
* Creates a throttled function that only invokes `func` at most once per
* every `wait` milliseconds. The throttled function comes with a `cancel`
* method to cancel delayed `func` invocations and a `flush` method to
* immediately invoke them. Provide `options` to indicate whether `func`
* should be invoked on the leading and/or trailing edge of the `wait`
* timeout. The `func` is invoked with the last arguments provided to the
* throttled function. Subsequent calls to the throttled function return the
* result of the last `func` invocation.
*
* **Note:** If `leading` and `trailing` options are `true`, `func` is
* invoked on the trailing edge of the timeout only if the throttled function
* is invoked more than once during the `wait` timeout.
*
* If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
* until to the next tick, similar to `setTimeout` with a timeout of `0`.
*
* See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
* for details over the differences between `_.throttle` and `_.debounce`.
*
* @static
* @memberOf _
* @since 0.1.0
* @category Function
* @param {Function} func The function to throttle.
* @param {number} [wait=0] The number of milliseconds to throttle invocations to.
* @param {Object} [options={}] The options object.
* @param {boolean} [options.leading=true]
*  Specify invoking on the leading edge of the timeout.
* @param {boolean} [options.trailing=true]
*  Specify invoking on the trailing edge of the timeout.
* @returns {Function} Returns the new throttled function.
* @example
*
* // Avoid excessively updating the position while scrolling.
* jQuery(window).on('scroll', _.throttle(updatePosition, 100));
*
* // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
* var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
* jQuery(element).on('click', throttled);
*
* // Cancel the trailing throttled invocation.
* jQuery(window).on('popstate', throttled.cancel);
*/
function throttle(func, wait, options) {
	var leading = true, trailing = true;
	if (typeof func != "function") throw new TypeError(FUNC_ERROR_TEXT);
	if (isObject_default(options)) {
		leading = "leading" in options ? !!options.leading : leading;
		trailing = "trailing" in options ? !!options.trailing : trailing;
	}
	return debounce_default(func, wait, {
		"leading": leading,
		"maxWait": wait,
		"trailing": trailing
	});
}
var throttle_default = throttle;

//#endregion
//#region node_modules/@tweenjs/tween.js/dist/tween.esm.js
/**
* The Ease class provides a collection of easing functions for use with tween.js.
*/
var Easing = Object.freeze({
	Linear: Object.freeze({
		None: function(amount) {
			return amount;
		},
		In: function(amount) {
			return amount;
		},
		Out: function(amount) {
			return amount;
		},
		InOut: function(amount) {
			return amount;
		}
	}),
	Quadratic: Object.freeze({
		In: function(amount) {
			return amount * amount;
		},
		Out: function(amount) {
			return amount * (2 - amount);
		},
		InOut: function(amount) {
			if ((amount *= 2) < 1) return .5 * amount * amount;
			return -.5 * (--amount * (amount - 2) - 1);
		}
	}),
	Cubic: Object.freeze({
		In: function(amount) {
			return amount * amount * amount;
		},
		Out: function(amount) {
			return --amount * amount * amount + 1;
		},
		InOut: function(amount) {
			if ((amount *= 2) < 1) return .5 * amount * amount * amount;
			return .5 * ((amount -= 2) * amount * amount + 2);
		}
	}),
	Quartic: Object.freeze({
		In: function(amount) {
			return amount * amount * amount * amount;
		},
		Out: function(amount) {
			return 1 - --amount * amount * amount * amount;
		},
		InOut: function(amount) {
			if ((amount *= 2) < 1) return .5 * amount * amount * amount * amount;
			return -.5 * ((amount -= 2) * amount * amount * amount - 2);
		}
	}),
	Quintic: Object.freeze({
		In: function(amount) {
			return amount * amount * amount * amount * amount;
		},
		Out: function(amount) {
			return --amount * amount * amount * amount * amount + 1;
		},
		InOut: function(amount) {
			if ((amount *= 2) < 1) return .5 * amount * amount * amount * amount * amount;
			return .5 * ((amount -= 2) * amount * amount * amount * amount + 2);
		}
	}),
	Sinusoidal: Object.freeze({
		In: function(amount) {
			return 1 - Math.sin((1 - amount) * Math.PI / 2);
		},
		Out: function(amount) {
			return Math.sin(amount * Math.PI / 2);
		},
		InOut: function(amount) {
			return .5 * (1 - Math.sin(Math.PI * (.5 - amount)));
		}
	}),
	Exponential: Object.freeze({
		In: function(amount) {
			return amount === 0 ? 0 : Math.pow(1024, amount - 1);
		},
		Out: function(amount) {
			return amount === 1 ? 1 : 1 - Math.pow(2, -10 * amount);
		},
		InOut: function(amount) {
			if (amount === 0) return 0;
			if (amount === 1) return 1;
			if ((amount *= 2) < 1) return .5 * Math.pow(1024, amount - 1);
			return .5 * (-Math.pow(2, -10 * (amount - 1)) + 2);
		}
	}),
	Circular: Object.freeze({
		In: function(amount) {
			return 1 - Math.sqrt(1 - amount * amount);
		},
		Out: function(amount) {
			return Math.sqrt(1 - --amount * amount);
		},
		InOut: function(amount) {
			if ((amount *= 2) < 1) return -.5 * (Math.sqrt(1 - amount * amount) - 1);
			return .5 * (Math.sqrt(1 - (amount -= 2) * amount) + 1);
		}
	}),
	Elastic: Object.freeze({
		In: function(amount) {
			if (amount === 0) return 0;
			if (amount === 1) return 1;
			return -Math.pow(2, 10 * (amount - 1)) * Math.sin((amount - 1.1) * 5 * Math.PI);
		},
		Out: function(amount) {
			if (amount === 0) return 0;
			if (amount === 1) return 1;
			return Math.pow(2, -10 * amount) * Math.sin((amount - .1) * 5 * Math.PI) + 1;
		},
		InOut: function(amount) {
			if (amount === 0) return 0;
			if (amount === 1) return 1;
			amount *= 2;
			if (amount < 1) return -.5 * Math.pow(2, 10 * (amount - 1)) * Math.sin((amount - 1.1) * 5 * Math.PI);
			return .5 * Math.pow(2, -10 * (amount - 1)) * Math.sin((amount - 1.1) * 5 * Math.PI) + 1;
		}
	}),
	Back: Object.freeze({
		In: function(amount) {
			var s$1 = 1.70158;
			return amount === 1 ? 1 : amount * amount * ((s$1 + 1) * amount - s$1);
		},
		Out: function(amount) {
			var s$1 = 1.70158;
			return amount === 0 ? 0 : --amount * amount * ((s$1 + 1) * amount + s$1) + 1;
		},
		InOut: function(amount) {
			var s$1 = 1.70158 * 1.525;
			if ((amount *= 2) < 1) return .5 * (amount * amount * ((s$1 + 1) * amount - s$1));
			return .5 * ((amount -= 2) * amount * ((s$1 + 1) * amount + s$1) + 2);
		}
	}),
	Bounce: Object.freeze({
		In: function(amount) {
			return 1 - Easing.Bounce.Out(1 - amount);
		},
		Out: function(amount) {
			if (amount < 1 / 2.75) return 7.5625 * amount * amount;
			else if (amount < 2 / 2.75) return 7.5625 * (amount -= 1.5 / 2.75) * amount + .75;
			else if (amount < 2.5 / 2.75) return 7.5625 * (amount -= 2.25 / 2.75) * amount + .9375;
			else return 7.5625 * (amount -= 2.625 / 2.75) * amount + .984375;
		},
		InOut: function(amount) {
			if (amount < .5) return Easing.Bounce.In(amount * 2) * .5;
			return Easing.Bounce.Out(amount * 2 - 1) * .5 + .5;
		}
	}),
	generatePow: function(power) {
		if (power === void 0) power = 4;
		power = power < Number.EPSILON ? Number.EPSILON : power;
		power = power > 1e4 ? 1e4 : power;
		return {
			In: function(amount) {
				return Math.pow(amount, power);
			},
			Out: function(amount) {
				return 1 - Math.pow(1 - amount, power);
			},
			InOut: function(amount) {
				if (amount < .5) return Math.pow(amount * 2, power) / 2;
				return (1 - Math.pow(2 - amount * 2, power)) / 2 + .5;
			}
		};
	}
});
var now = function() {
	return performance.now();
};
/**
* Controlling groups of tweens
*
* Using the TWEEN singleton to manage your tweens can cause issues in large apps with many components.
* In these cases, you may want to create your own smaller groups of tween
*/
var Group = function() {
	function Group$1() {
		var tweens = [];
		for (var _i = 0; _i < arguments.length; _i++) tweens[_i] = arguments[_i];
		this._tweens = {};
		this._tweensAddedDuringUpdate = {};
		this.add.apply(this, tweens);
	}
	Group$1.prototype.getAll = function() {
		var _this = this;
		return Object.keys(this._tweens).map(function(tweenId) {
			return _this._tweens[tweenId];
		});
	};
	Group$1.prototype.removeAll = function() {
		this._tweens = {};
	};
	Group$1.prototype.add = function() {
		var _a;
		var tweens = [];
		for (var _i = 0; _i < arguments.length; _i++) tweens[_i] = arguments[_i];
		for (var _b = 0, tweens_1 = tweens; _b < tweens_1.length; _b++) {
			var tween = tweens_1[_b];
			(_a = tween._group) === null || _a === void 0 || _a.remove(tween);
			tween._group = this;
			this._tweens[tween.getId()] = tween;
			this._tweensAddedDuringUpdate[tween.getId()] = tween;
		}
	};
	Group$1.prototype.remove = function() {
		var tweens = [];
		for (var _i = 0; _i < arguments.length; _i++) tweens[_i] = arguments[_i];
		for (var _a = 0, tweens_2 = tweens; _a < tweens_2.length; _a++) {
			var tween = tweens_2[_a];
			tween._group = void 0;
			delete this._tweens[tween.getId()];
			delete this._tweensAddedDuringUpdate[tween.getId()];
		}
	};
	/** Return true if all tweens in the group are not paused or playing. */
	Group$1.prototype.allStopped = function() {
		return this.getAll().every(function(tween) {
			return !tween.isPlaying();
		});
	};
	Group$1.prototype.update = function(time, preserve) {
		if (time === void 0) time = now();
		if (preserve === void 0) preserve = true;
		var tweenIds = Object.keys(this._tweens);
		if (tweenIds.length === 0) return;
		while (tweenIds.length > 0) {
			this._tweensAddedDuringUpdate = {};
			for (var i$1 = 0; i$1 < tweenIds.length; i$1++) {
				var tween = this._tweens[tweenIds[i$1]];
				var autoStart = !preserve;
				if (tween && tween.update(time, autoStart) === false && !preserve) this.remove(tween);
			}
			tweenIds = Object.keys(this._tweensAddedDuringUpdate);
		}
	};
	return Group$1;
}();
/**
*
*/
var Interpolation = {
	Linear: function(v$1, k$1) {
		var m$2 = v$1.length - 1;
		var f$1 = m$2 * k$1;
		var i$1 = Math.floor(f$1);
		var fn = Interpolation.Utils.Linear;
		if (k$1 < 0) return fn(v$1[0], v$1[1], f$1);
		if (k$1 > 1) return fn(v$1[m$2], v$1[m$2 - 1], m$2 - f$1);
		return fn(v$1[i$1], v$1[i$1 + 1 > m$2 ? m$2 : i$1 + 1], f$1 - i$1);
	},
	Bezier: function(v$1, k$1) {
		var b = 0;
		var n$1 = v$1.length - 1;
		var pw = Math.pow;
		var bn = Interpolation.Utils.Bernstein;
		for (var i$1 = 0; i$1 <= n$1; i$1++) b += pw(1 - k$1, n$1 - i$1) * pw(k$1, i$1) * v$1[i$1] * bn(n$1, i$1);
		return b;
	},
	CatmullRom: function(v$1, k$1) {
		var m$2 = v$1.length - 1;
		var f$1 = m$2 * k$1;
		var i$1 = Math.floor(f$1);
		var fn = Interpolation.Utils.CatmullRom;
		if (v$1[0] === v$1[m$2]) {
			if (k$1 < 0) i$1 = Math.floor(f$1 = m$2 * (1 + k$1));
			return fn(v$1[(i$1 - 1 + m$2) % m$2], v$1[i$1], v$1[(i$1 + 1) % m$2], v$1[(i$1 + 2) % m$2], f$1 - i$1);
		} else {
			if (k$1 < 0) return v$1[0] - (fn(v$1[0], v$1[0], v$1[1], v$1[1], -f$1) - v$1[0]);
			if (k$1 > 1) return v$1[m$2] - (fn(v$1[m$2], v$1[m$2], v$1[m$2 - 1], v$1[m$2 - 1], f$1 - m$2) - v$1[m$2]);
			return fn(v$1[i$1 ? i$1 - 1 : 0], v$1[i$1], v$1[m$2 < i$1 + 1 ? m$2 : i$1 + 1], v$1[m$2 < i$1 + 2 ? m$2 : i$1 + 2], f$1 - i$1);
		}
	},
	Utils: {
		Linear: function(p0, p1, t$2) {
			return (p1 - p0) * t$2 + p0;
		},
		Bernstein: function(n$1, i$1) {
			var fc = Interpolation.Utils.Factorial;
			return fc(n$1) / fc(i$1) / fc(n$1 - i$1);
		},
		Factorial: (function() {
			var a$2 = [1];
			return function(n$1) {
				var s$1 = 1;
				if (a$2[n$1]) return a$2[n$1];
				for (var i$1 = n$1; i$1 > 1; i$1--) s$1 *= i$1;
				a$2[n$1] = s$1;
				return s$1;
			};
		})(),
		CatmullRom: function(p0, p1, p2, p3, t$2) {
			var v0 = (p2 - p0) * .5;
			var v1 = (p3 - p1) * .5;
			var t2 = t$2 * t$2;
			var t3 = t$2 * t2;
			return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t$2 + p1;
		}
	}
};
/**
* Utils
*/
var Sequence = function() {
	function Sequence$1() {}
	Sequence$1.nextId = function() {
		return Sequence$1._nextId++;
	};
	Sequence$1._nextId = 0;
	return Sequence$1;
}();
var mainGroup = new Group();
/**
* Tween.js - Licensed under the MIT license
* https://github.com/tweenjs/tween.js
* ----------------------------------------------
*
* See https://github.com/tweenjs/tween.js/graphs/contributors for the full list of contributors.
* Thank you all, you're awesome!
*/
var Tween = function() {
	function Tween$1(object, group) {
		this._isPaused = false;
		this._pauseStart = 0;
		this._valuesStart = {};
		this._valuesEnd = {};
		this._valuesStartRepeat = {};
		this._duration = 1e3;
		this._isDynamic = false;
		this._initialRepeat = 0;
		this._repeat = 0;
		this._yoyo = false;
		this._isPlaying = false;
		this._reversed = false;
		this._delayTime = 0;
		this._startTime = 0;
		this._easingFunction = Easing.Linear.None;
		this._interpolationFunction = Interpolation.Linear;
		this._chainedTweens = [];
		this._onStartCallbackFired = false;
		this._onEveryStartCallbackFired = false;
		this._id = Sequence.nextId();
		this._isChainStopped = false;
		this._propertiesAreSetUp = false;
		this._goToEnd = false;
		this._object = object;
		if (typeof group === "object") {
			this._group = group;
			group.add(this);
		} else if (group === true) {
			this._group = mainGroup;
			mainGroup.add(this);
		}
	}
	Tween$1.prototype.getId = function() {
		return this._id;
	};
	Tween$1.prototype.isPlaying = function() {
		return this._isPlaying;
	};
	Tween$1.prototype.isPaused = function() {
		return this._isPaused;
	};
	Tween$1.prototype.getDuration = function() {
		return this._duration;
	};
	Tween$1.prototype.to = function(target, duration) {
		if (duration === void 0) duration = 1e3;
		if (this._isPlaying) throw new Error("Can not call Tween.to() while Tween is already started or paused. Stop the Tween first.");
		this._valuesEnd = target;
		this._propertiesAreSetUp = false;
		this._duration = duration < 0 ? 0 : duration;
		return this;
	};
	Tween$1.prototype.duration = function(duration) {
		if (duration === void 0) duration = 1e3;
		this._duration = duration < 0 ? 0 : duration;
		return this;
	};
	Tween$1.prototype.dynamic = function(dynamic) {
		if (dynamic === void 0) dynamic = false;
		this._isDynamic = dynamic;
		return this;
	};
	Tween$1.prototype.start = function(time, overrideStartingValues) {
		if (time === void 0) time = now();
		if (overrideStartingValues === void 0) overrideStartingValues = false;
		if (this._isPlaying) return this;
		this._repeat = this._initialRepeat;
		if (this._reversed) {
			this._reversed = false;
			for (var property in this._valuesStartRepeat) {
				this._swapEndStartRepeatValues(property);
				this._valuesStart[property] = this._valuesStartRepeat[property];
			}
		}
		this._isPlaying = true;
		this._isPaused = false;
		this._onStartCallbackFired = false;
		this._onEveryStartCallbackFired = false;
		this._isChainStopped = false;
		this._startTime = time;
		this._startTime += this._delayTime;
		if (!this._propertiesAreSetUp || overrideStartingValues) {
			this._propertiesAreSetUp = true;
			if (!this._isDynamic) {
				var tmp = {};
				for (var prop in this._valuesEnd) tmp[prop] = this._valuesEnd[prop];
				this._valuesEnd = tmp;
			}
			this._setupProperties(this._object, this._valuesStart, this._valuesEnd, this._valuesStartRepeat, overrideStartingValues);
		}
		return this;
	};
	Tween$1.prototype.startFromCurrentValues = function(time) {
		return this.start(time, true);
	};
	Tween$1.prototype._setupProperties = function(_object, _valuesStart, _valuesEnd, _valuesStartRepeat, overrideStartingValues) {
		for (var property in _valuesEnd) {
			var startValue = _object[property];
			var startValueIsArray = Array.isArray(startValue);
			var propType = startValueIsArray ? "array" : typeof startValue;
			var isInterpolationList = !startValueIsArray && Array.isArray(_valuesEnd[property]);
			if (propType === "undefined" || propType === "function") continue;
			if (isInterpolationList) {
				var endValues = _valuesEnd[property];
				if (endValues.length === 0) continue;
				var temp = [startValue];
				for (var i$1 = 0, l$1 = endValues.length; i$1 < l$1; i$1 += 1) {
					var value = this._handleRelativeValue(startValue, endValues[i$1]);
					if (isNaN(value)) {
						isInterpolationList = false;
						console.warn("Found invalid interpolation list. Skipping.");
						break;
					}
					temp.push(value);
				}
				if (isInterpolationList) _valuesEnd[property] = temp;
			}
			if ((propType === "object" || startValueIsArray) && startValue && !isInterpolationList) {
				_valuesStart[property] = startValueIsArray ? [] : {};
				var nestedObject = startValue;
				for (var prop in nestedObject) _valuesStart[property][prop] = nestedObject[prop];
				_valuesStartRepeat[property] = startValueIsArray ? [] : {};
				var endValues = _valuesEnd[property];
				if (!this._isDynamic) {
					var tmp = {};
					for (var prop in endValues) tmp[prop] = endValues[prop];
					_valuesEnd[property] = endValues = tmp;
				}
				this._setupProperties(nestedObject, _valuesStart[property], endValues, _valuesStartRepeat[property], overrideStartingValues);
			} else {
				if (typeof _valuesStart[property] === "undefined" || overrideStartingValues) _valuesStart[property] = startValue;
				if (!startValueIsArray) _valuesStart[property] *= 1;
				if (isInterpolationList) _valuesStartRepeat[property] = _valuesEnd[property].slice().reverse();
				else _valuesStartRepeat[property] = _valuesStart[property] || 0;
			}
		}
	};
	Tween$1.prototype.stop = function() {
		if (!this._isChainStopped) {
			this._isChainStopped = true;
			this.stopChainedTweens();
		}
		if (!this._isPlaying) return this;
		this._isPlaying = false;
		this._isPaused = false;
		if (this._onStopCallback) this._onStopCallback(this._object);
		return this;
	};
	Tween$1.prototype.end = function() {
		this._goToEnd = true;
		this.update(this._startTime + this._duration);
		return this;
	};
	Tween$1.prototype.pause = function(time) {
		if (time === void 0) time = now();
		if (this._isPaused || !this._isPlaying) return this;
		this._isPaused = true;
		this._pauseStart = time;
		return this;
	};
	Tween$1.prototype.resume = function(time) {
		if (time === void 0) time = now();
		if (!this._isPaused || !this._isPlaying) return this;
		this._isPaused = false;
		this._startTime += time - this._pauseStart;
		this._pauseStart = 0;
		return this;
	};
	Tween$1.prototype.stopChainedTweens = function() {
		for (var i$1 = 0, numChainedTweens = this._chainedTweens.length; i$1 < numChainedTweens; i$1++) this._chainedTweens[i$1].stop();
		return this;
	};
	Tween$1.prototype.group = function(group) {
		if (!group) {
			console.warn("tween.group() without args has been removed, use group.add(tween) instead.");
			return this;
		}
		group.add(this);
		return this;
	};
	/**
	* Removes the tween from whichever group it is in.
	*/
	Tween$1.prototype.remove = function() {
		var _a;
		(_a = this._group) === null || _a === void 0 || _a.remove(this);
		return this;
	};
	Tween$1.prototype.delay = function(amount) {
		if (amount === void 0) amount = 0;
		this._delayTime = amount;
		return this;
	};
	Tween$1.prototype.repeat = function(times) {
		if (times === void 0) times = 0;
		this._initialRepeat = times;
		this._repeat = times;
		return this;
	};
	Tween$1.prototype.repeatDelay = function(amount) {
		this._repeatDelayTime = amount;
		return this;
	};
	Tween$1.prototype.yoyo = function(yoyo) {
		if (yoyo === void 0) yoyo = false;
		this._yoyo = yoyo;
		return this;
	};
	Tween$1.prototype.easing = function(easingFunction) {
		if (easingFunction === void 0) easingFunction = Easing.Linear.None;
		this._easingFunction = easingFunction;
		return this;
	};
	Tween$1.prototype.interpolation = function(interpolationFunction) {
		if (interpolationFunction === void 0) interpolationFunction = Interpolation.Linear;
		this._interpolationFunction = interpolationFunction;
		return this;
	};
	Tween$1.prototype.chain = function() {
		var tweens = [];
		for (var _i = 0; _i < arguments.length; _i++) tweens[_i] = arguments[_i];
		this._chainedTweens = tweens;
		return this;
	};
	Tween$1.prototype.onStart = function(callback) {
		this._onStartCallback = callback;
		return this;
	};
	Tween$1.prototype.onEveryStart = function(callback) {
		this._onEveryStartCallback = callback;
		return this;
	};
	Tween$1.prototype.onUpdate = function(callback) {
		this._onUpdateCallback = callback;
		return this;
	};
	Tween$1.prototype.onRepeat = function(callback) {
		this._onRepeatCallback = callback;
		return this;
	};
	Tween$1.prototype.onComplete = function(callback) {
		this._onCompleteCallback = callback;
		return this;
	};
	Tween$1.prototype.onStop = function(callback) {
		this._onStopCallback = callback;
		return this;
	};
	/**
	* @returns true if the tween is still playing after the update, false
	* otherwise (calling update on a paused tween still returns true because
	* it is still playing, just paused).
	*
	* @param autoStart - When true, calling update will implicitly call start()
	* as well. Note, if you stop() or end() the tween, but are still calling
	* update(), it will start again!
	*/
	Tween$1.prototype.update = function(time, autoStart) {
		var _this = this;
		var _a;
		if (time === void 0) time = now();
		if (autoStart === void 0) autoStart = Tween$1.autoStartOnUpdate;
		if (this._isPaused) return true;
		var property;
		if (!this._goToEnd && !this._isPlaying) if (autoStart) this.start(time, true);
		else return false;
		this._goToEnd = false;
		if (time < this._startTime) return true;
		if (this._onStartCallbackFired === false) {
			if (this._onStartCallback) this._onStartCallback(this._object);
			this._onStartCallbackFired = true;
		}
		if (this._onEveryStartCallbackFired === false) {
			if (this._onEveryStartCallback) this._onEveryStartCallback(this._object);
			this._onEveryStartCallbackFired = true;
		}
		var elapsedTime = time - this._startTime;
		var durationAndDelay = this._duration + ((_a = this._repeatDelayTime) !== null && _a !== void 0 ? _a : this._delayTime);
		var totalTime = this._duration + this._repeat * durationAndDelay;
		var calculateElapsedPortion = function() {
			if (_this._duration === 0) return 1;
			if (elapsedTime > totalTime) return 1;
			var timeIntoCurrentRepeat = elapsedTime - Math.trunc(elapsedTime / durationAndDelay) * durationAndDelay;
			var portion = Math.min(timeIntoCurrentRepeat / _this._duration, 1);
			if (portion === 0 && elapsedTime === _this._duration) return 1;
			return portion;
		};
		var elapsed = calculateElapsedPortion();
		var value = this._easingFunction(elapsed);
		this._updateProperties(this._object, this._valuesStart, this._valuesEnd, value);
		if (this._onUpdateCallback) this._onUpdateCallback(this._object, elapsed);
		if (this._duration === 0 || elapsedTime >= this._duration) if (this._repeat > 0) {
			var completeCount = Math.min(Math.trunc((elapsedTime - this._duration) / durationAndDelay) + 1, this._repeat);
			if (isFinite(this._repeat)) this._repeat -= completeCount;
			for (property in this._valuesStartRepeat) {
				if (!this._yoyo && typeof this._valuesEnd[property] === "string") this._valuesStartRepeat[property] = this._valuesStartRepeat[property] + parseFloat(this._valuesEnd[property]);
				if (this._yoyo) this._swapEndStartRepeatValues(property);
				this._valuesStart[property] = this._valuesStartRepeat[property];
			}
			if (this._yoyo) this._reversed = !this._reversed;
			this._startTime += durationAndDelay * completeCount;
			if (this._onRepeatCallback) this._onRepeatCallback(this._object);
			this._onEveryStartCallbackFired = false;
			return true;
		} else {
			if (this._onCompleteCallback) this._onCompleteCallback(this._object);
			for (var i$1 = 0, numChainedTweens = this._chainedTweens.length; i$1 < numChainedTweens; i$1++) this._chainedTweens[i$1].start(this._startTime + this._duration, false);
			this._isPlaying = false;
			return false;
		}
		return true;
	};
	Tween$1.prototype._updateProperties = function(_object, _valuesStart, _valuesEnd, value) {
		for (var property in _valuesEnd) {
			if (_valuesStart[property] === void 0) continue;
			var start$1 = _valuesStart[property] || 0;
			var end = _valuesEnd[property];
			if (!Array.isArray(_object[property]) && Array.isArray(end)) _object[property] = this._interpolationFunction(end, value);
			else if (typeof end === "object" && end) this._updateProperties(_object[property], start$1, end, value);
			else {
				end = this._handleRelativeValue(start$1, end);
				if (typeof end === "number") _object[property] = start$1 + (end - start$1) * value;
			}
		}
	};
	Tween$1.prototype._handleRelativeValue = function(start$1, end) {
		if (typeof end !== "string") return end;
		if (end.charAt(0) === "+" || end.charAt(0) === "-") return start$1 + parseFloat(end);
		return parseFloat(end);
	};
	Tween$1.prototype._swapEndStartRepeatValues = function(property) {
		var tmp = this._valuesStartRepeat[property];
		var endValue = this._valuesEnd[property];
		if (typeof endValue === "string") this._valuesStartRepeat[property] = this._valuesStartRepeat[property] + parseFloat(endValue);
		else this._valuesStartRepeat[property] = this._valuesEnd[property];
		this._valuesEnd[property] = tmp;
	};
	Tween$1.autoStartOnUpdate = false;
	return Tween$1;
}();
/**
* Tween.js - Licensed under the MIT license
* https://github.com/tweenjs/tween.js
* ----------------------------------------------
*
* See https://github.com/tweenjs/tween.js/graphs/contributors for the full list of contributors.
* Thank you all, you're awesome!
*/
var nextId = Sequence.nextId;
/**
* Controlling groups of tweens
*
* Using the TWEEN singleton to manage your tweens can cause issues in large apps with many components.
* In these cases, you may want to create your own smaller groups of tweens.
*/
var TWEEN = mainGroup;
/**
* @deprecated The global TWEEN Group will be removed in a following major
* release. To migrate, create a `new Group()` instead of using `TWEEN` as a
* group.
*
* Old code:
*
* ```js
* import * as TWEEN from '@tweenjs/tween.js'
*
* //...
*
* const tween = new TWEEN.Tween(obj)
* const tween2 = new TWEEN.Tween(obj2)
*
* //...
*
* requestAnimationFrame(function loop(time) {
*   TWEEN.update(time)
*   requestAnimationFrame(loop)
* })
* ```
*
* New code:
*
* ```js
* import {Tween, Group} from '@tweenjs/tween.js'
*
* //...
*
* const tween = new Tween(obj)
* const tween2 = new TWEEN.Tween(obj2)
*
* //...
*
* const group = new Group()
* group.add(tween)
* group.add(tween2)
*
* //...
*
* requestAnimationFrame(function loop(time) {
*   group.update(time)
*   requestAnimationFrame(loop)
* })
* ```
*/
var getAll = TWEEN.getAll.bind(TWEEN);
/**
* @deprecated The global TWEEN Group will be removed in a following major
* release. To migrate, create a `new Group()` instead of using `TWEEN` as a
* group.
*
* Old code:
*
* ```js
* import * as TWEEN from '@tweenjs/tween.js'
*
* //...
*
* const tween = new TWEEN.Tween(obj)
* const tween2 = new TWEEN.Tween(obj2)
*
* //...
*
* requestAnimationFrame(function loop(time) {
*   TWEEN.update(time)
*   requestAnimationFrame(loop)
* })
* ```
*
* New code:
*
* ```js
* import {Tween, Group} from '@tweenjs/tween.js'
*
* //...
*
* const tween = new Tween(obj)
* const tween2 = new TWEEN.Tween(obj2)
*
* //...
*
* const group = new Group()
* group.add(tween)
* group.add(tween2)
*
* //...
*
* requestAnimationFrame(function loop(time) {
*   group.update(time)
*   requestAnimationFrame(loop)
* })
* ```
*/
var removeAll$3 = TWEEN.removeAll.bind(TWEEN);
/**
* @deprecated The global TWEEN Group will be removed in a following major
* release. To migrate, create a `new Group()` instead of using `TWEEN` as a
* group.
*
* Old code:
*
* ```js
* import * as TWEEN from '@tweenjs/tween.js'
*
* //...
*
* const tween = new TWEEN.Tween(obj)
* const tween2 = new TWEEN.Tween(obj2)
*
* //...
*
* requestAnimationFrame(function loop(time) {
*   TWEEN.update(time)
*   requestAnimationFrame(loop)
* })
* ```
*
* New code:
*
* ```js
* import {Tween, Group} from '@tweenjs/tween.js'
*
* //...
*
* const tween = new Tween(obj)
* const tween2 = new TWEEN.Tween(obj2)
*
* //...
*
* const group = new Group()
* group.add(tween)
* group.add(tween2)
*
* //...
*
* requestAnimationFrame(function loop(time) {
*   group.update(time)
*   requestAnimationFrame(loop)
* })
* ```
*/
var add$3 = TWEEN.add.bind(TWEEN);
/**
* @deprecated The global TWEEN Group will be removed in a following major
* release. To migrate, create a `new Group()` instead of using `TWEEN` as a
* group.
*
* Old code:
*
* ```js
* import * as TWEEN from '@tweenjs/tween.js'
*
* //...
*
* const tween = new TWEEN.Tween(obj)
* const tween2 = new TWEEN.Tween(obj2)
*
* //...
*
* requestAnimationFrame(function loop(time) {
*   TWEEN.update(time)
*   requestAnimationFrame(loop)
* })
* ```
*
* New code:
*
* ```js
* import {Tween, Group} from '@tweenjs/tween.js'
*
* //...
*
* const tween = new Tween(obj)
* const tween2 = new TWEEN.Tween(obj2)
*
* //...
*
* const group = new Group()
* group.add(tween)
* group.add(tween2)
*
* //...
*
* requestAnimationFrame(function loop(time) {
*   group.update(time)
*   requestAnimationFrame(loop)
* })
* ```
*/
var remove = TWEEN.remove.bind(TWEEN);
/**
* @deprecated The global TWEEN Group will be removed in a following major
* release. To migrate, create a `new Group()` instead of using `TWEEN` as a
* group.
*
* Old code:
*
* ```js
* import * as TWEEN from '@tweenjs/tween.js'
*
* //...
*
* const tween = new TWEEN.Tween(obj)
* const tween2 = new TWEEN.Tween(obj2)
*
* //...
*
* requestAnimationFrame(function loop(time) {
*   TWEEN.update(time)
*   requestAnimationFrame(loop)
* })
* ```
*
* New code:
*
* ```js
* import {Tween, Group} from '@tweenjs/tween.js'
*
* //...
*
* const tween = new Tween(obj)
* const tween2 = new TWEEN.Tween(obj2)
*
* //...
*
* const group = new Group()
* group.add(tween)
* group.add(tween2)
*
* //...
*
* requestAnimationFrame(function loop(time) {
*   group.update(time)
*   requestAnimationFrame(loop)
* })
* ```
*/
var update = TWEEN.update.bind(TWEEN);

//#endregion
//#region node_modules/kapsule/dist/kapsule.mjs
function _arrayLikeToArray$4(r$1, a$2) {
	(null == a$2 || a$2 > r$1.length) && (a$2 = r$1.length);
	for (var e$1 = 0, n$1 = Array(a$2); e$1 < a$2; e$1++) n$1[e$1] = r$1[e$1];
	return n$1;
}
function _arrayWithHoles$3(r$1) {
	if (Array.isArray(r$1)) return r$1;
}
function _classCallCheck$1(a$2, n$1) {
	if (!(a$2 instanceof n$1)) throw new TypeError("Cannot call a class as a function");
}
function _createClass$1(e$1, r$1, t$2) {
	return Object.defineProperty(e$1, "prototype", { writable: false }), e$1;
}
function _iterableToArrayLimit$3(r$1, l$1) {
	var t$2 = null == r$1 ? null : "undefined" != typeof Symbol && r$1[Symbol.iterator] || r$1["@@iterator"];
	if (null != t$2) {
		var e$1, n$1, i$1, u$1, a$2 = [], f$1 = true, o$1 = false;
		try {
			if (i$1 = (t$2 = t$2.call(r$1)).next, 0 === l$1);
			else for (; !(f$1 = (e$1 = i$1.call(t$2)).done) && (a$2.push(e$1.value), a$2.length !== l$1); f$1 = !0);
		} catch (r$2) {
			o$1 = true, n$1 = r$2;
		} finally {
			try {
				if (!f$1 && null != t$2.return && (u$1 = t$2.return(), Object(u$1) !== u$1)) return;
			} finally {
				if (o$1) throw n$1;
			}
		}
		return a$2;
	}
}
function _nonIterableRest$3() {
	throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _slicedToArray$3(r$1, e$1) {
	return _arrayWithHoles$3(r$1) || _iterableToArrayLimit$3(r$1, e$1) || _unsupportedIterableToArray$4(r$1, e$1) || _nonIterableRest$3();
}
function _unsupportedIterableToArray$4(r$1, a$2) {
	if (r$1) {
		if ("string" == typeof r$1) return _arrayLikeToArray$4(r$1, a$2);
		var t$2 = {}.toString.call(r$1).slice(8, -1);
		return "Object" === t$2 && r$1.constructor && (t$2 = r$1.constructor.name), "Map" === t$2 || "Set" === t$2 ? Array.from(r$1) : "Arguments" === t$2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t$2) ? _arrayLikeToArray$4(r$1, a$2) : void 0;
	}
}
var Prop = /* @__PURE__ */ _createClass$1(function Prop$1(name, _ref) {
	var _ref$default = _ref["default"], defaultVal = _ref$default === void 0 ? null : _ref$default, _ref$triggerUpdate = _ref.triggerUpdate, triggerUpdate = _ref$triggerUpdate === void 0 ? true : _ref$triggerUpdate, _ref$onChange = _ref.onChange, onChange = _ref$onChange === void 0 ? function(newVal, state) {} : _ref$onChange;
	_classCallCheck$1(this, Prop$1);
	this.name = name;
	this.defaultVal = defaultVal;
	this.triggerUpdate = triggerUpdate;
	this.onChange = onChange;
});
function index$1(_ref2) {
	var _ref2$stateInit = _ref2.stateInit, stateInit = _ref2$stateInit === void 0 ? function() {
		return {};
	} : _ref2$stateInit, _ref2$props = _ref2.props, rawProps = _ref2$props === void 0 ? {} : _ref2$props, _ref2$methods = _ref2.methods, methods = _ref2$methods === void 0 ? {} : _ref2$methods, _ref2$aliases = _ref2.aliases, aliases = _ref2$aliases === void 0 ? {} : _ref2$aliases, _ref2$init = _ref2.init, initFn = _ref2$init === void 0 ? function() {} : _ref2$init, _ref2$update = _ref2.update, updateFn = _ref2$update === void 0 ? function() {} : _ref2$update;
	var props = Object.keys(rawProps).map(function(propName) {
		return new Prop(propName, rawProps[propName]);
	});
	return function KapsuleComp() {
		for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
		var classMode = !!(this instanceof KapsuleComp ? this.constructor : void 0);
		var nodeElement = classMode ? args.shift() : void 0;
		var _args$ = args[0], options = _args$ === void 0 ? {} : _args$;
		var state = Object.assign({}, stateInit instanceof Function ? stateInit(options) : stateInit, { initialised: false });
		var changedProps = {};
		function comp(nodeElement$1) {
			initStatic(nodeElement$1, options);
			digest();
			return comp;
		}
		var initStatic = function initStatic$1(nodeElement$1, options$1) {
			initFn.call(comp, nodeElement$1, state, options$1);
			state.initialised = true;
		};
		var digest = debounce_default(function() {
			if (!state.initialised) return;
			updateFn.call(comp, state, changedProps);
			changedProps = {};
		}, 1);
		props.forEach(function(prop) {
			comp[prop.name] = getSetProp(prop);
			function getSetProp(_ref3) {
				var prop$1 = _ref3.name, _ref3$triggerUpdate = _ref3.triggerUpdate, redigest = _ref3$triggerUpdate === void 0 ? false : _ref3$triggerUpdate, _ref3$onChange = _ref3.onChange, onChange = _ref3$onChange === void 0 ? function(newVal, state$1) {} : _ref3$onChange, _ref3$defaultVal = _ref3.defaultVal, defaultVal = _ref3$defaultVal === void 0 ? null : _ref3$defaultVal;
				return function(_$1) {
					var curVal = state[prop$1];
					if (!arguments.length) return curVal;
					var val = _$1 === void 0 ? defaultVal : _$1;
					state[prop$1] = val;
					onChange.call(comp, val, state, curVal);
					!changedProps.hasOwnProperty(prop$1) && (changedProps[prop$1] = curVal);
					if (redigest) digest();
					return comp;
				};
			}
		});
		Object.keys(methods).forEach(function(methodName) {
			comp[methodName] = function() {
				var _methods$methodName;
				for (var _len2 = arguments.length, args$1 = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) args$1[_key2] = arguments[_key2];
				return (_methods$methodName = methods[methodName]).call.apply(_methods$methodName, [comp, state].concat(args$1));
			};
		});
		Object.entries(aliases).forEach(function(_ref4) {
			var _ref5 = _slicedToArray$3(_ref4, 2), alias = _ref5[0];
			return comp[alias] = comp[_ref5[1]];
		});
		comp.resetProps = function() {
			props.forEach(function(prop) {
				comp[prop.name](prop.defaultVal);
			});
			return comp;
		};
		comp.resetProps();
		state._rerender = digest;
		classMode && nodeElement && comp(nodeElement);
		return comp;
	};
}

//#endregion
//#region node_modules/accessor-fn/dist/accessor-fn.mjs
var index$2 = (function(p$1) {
	return typeof p$1 === "function" ? p$1 : typeof p$1 === "string" ? function(obj) {
		return obj[p$1];
	} : function(obj) {
		return p$1;
	};
});

//#endregion
//#region node_modules/tinycolor2/esm/tinycolor.js
function _typeof$2(obj) {
	"@babel/helpers - typeof";
	return _typeof$2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj$1) {
		return typeof obj$1;
	} : function(obj$1) {
		return obj$1 && "function" == typeof Symbol && obj$1.constructor === Symbol && obj$1 !== Symbol.prototype ? "symbol" : typeof obj$1;
	}, _typeof$2(obj);
}
var trimLeft = /^\s+/;
var trimRight = /\s+$/;
function tinycolor(color$1, opts) {
	color$1 = color$1 ? color$1 : "";
	opts = opts || {};
	if (color$1 instanceof tinycolor) return color$1;
	if (!(this instanceof tinycolor)) return new tinycolor(color$1, opts);
	var rgb$1 = inputToRGB(color$1);
	this._originalInput = color$1, this._r = rgb$1.r, this._g = rgb$1.g, this._b = rgb$1.b, this._a = rgb$1.a, this._roundA = Math.round(100 * this._a) / 100, this._format = opts.format || rgb$1.format;
	this._gradientType = opts.gradientType;
	if (this._r < 1) this._r = Math.round(this._r);
	if (this._g < 1) this._g = Math.round(this._g);
	if (this._b < 1) this._b = Math.round(this._b);
	this._ok = rgb$1.ok;
}
tinycolor.prototype = {
	isDark: function isDark() {
		return this.getBrightness() < 128;
	},
	isLight: function isLight() {
		return !this.isDark();
	},
	isValid: function isValid() {
		return this._ok;
	},
	getOriginalInput: function getOriginalInput() {
		return this._originalInput;
	},
	getFormat: function getFormat() {
		return this._format;
	},
	getAlpha: function getAlpha() {
		return this._a;
	},
	getBrightness: function getBrightness() {
		var rgb$1 = this.toRgb();
		return (rgb$1.r * 299 + rgb$1.g * 587 + rgb$1.b * 114) / 1e3;
	},
	getLuminance: function getLuminance() {
		var rgb$1 = this.toRgb();
		var RsRGB = rgb$1.r / 255, GsRGB = rgb$1.g / 255, BsRGB = rgb$1.b / 255, R, G$1, B$1;
		if (RsRGB <= .03928) R = RsRGB / 12.92;
		else R = Math.pow((RsRGB + .055) / 1.055, 2.4);
		if (GsRGB <= .03928) G$1 = GsRGB / 12.92;
		else G$1 = Math.pow((GsRGB + .055) / 1.055, 2.4);
		if (BsRGB <= .03928) B$1 = BsRGB / 12.92;
		else B$1 = Math.pow((BsRGB + .055) / 1.055, 2.4);
		return .2126 * R + .7152 * G$1 + .0722 * B$1;
	},
	setAlpha: function setAlpha(value) {
		this._a = boundAlpha(value);
		this._roundA = Math.round(100 * this._a) / 100;
		return this;
	},
	toHsv: function toHsv() {
		var hsv = rgbToHsv(this._r, this._g, this._b);
		return {
			h: hsv.h * 360,
			s: hsv.s,
			v: hsv.v,
			a: this._a
		};
	},
	toHsvString: function toHsvString() {
		var hsv = rgbToHsv(this._r, this._g, this._b);
		var h$1 = Math.round(hsv.h * 360), s$1 = Math.round(hsv.s * 100), v$1 = Math.round(hsv.v * 100);
		return this._a == 1 ? "hsv(" + h$1 + ", " + s$1 + "%, " + v$1 + "%)" : "hsva(" + h$1 + ", " + s$1 + "%, " + v$1 + "%, " + this._roundA + ")";
	},
	toHsl: function toHsl() {
		var hsl$1 = rgbToHsl(this._r, this._g, this._b);
		return {
			h: hsl$1.h * 360,
			s: hsl$1.s,
			l: hsl$1.l,
			a: this._a
		};
	},
	toHslString: function toHslString() {
		var hsl$1 = rgbToHsl(this._r, this._g, this._b);
		var h$1 = Math.round(hsl$1.h * 360), s$1 = Math.round(hsl$1.s * 100), l$1 = Math.round(hsl$1.l * 100);
		return this._a == 1 ? "hsl(" + h$1 + ", " + s$1 + "%, " + l$1 + "%)" : "hsla(" + h$1 + ", " + s$1 + "%, " + l$1 + "%, " + this._roundA + ")";
	},
	toHex: function toHex(allow3Char) {
		return rgbToHex(this._r, this._g, this._b, allow3Char);
	},
	toHexString: function toHexString(allow3Char) {
		return "#" + this.toHex(allow3Char);
	},
	toHex8: function toHex8(allow4Char) {
		return rgbaToHex(this._r, this._g, this._b, this._a, allow4Char);
	},
	toHex8String: function toHex8String(allow4Char) {
		return "#" + this.toHex8(allow4Char);
	},
	toRgb: function toRgb() {
		return {
			r: Math.round(this._r),
			g: Math.round(this._g),
			b: Math.round(this._b),
			a: this._a
		};
	},
	toRgbString: function toRgbString() {
		return this._a == 1 ? "rgb(" + Math.round(this._r) + ", " + Math.round(this._g) + ", " + Math.round(this._b) + ")" : "rgba(" + Math.round(this._r) + ", " + Math.round(this._g) + ", " + Math.round(this._b) + ", " + this._roundA + ")";
	},
	toPercentageRgb: function toPercentageRgb() {
		return {
			r: Math.round(bound01(this._r, 255) * 100) + "%",
			g: Math.round(bound01(this._g, 255) * 100) + "%",
			b: Math.round(bound01(this._b, 255) * 100) + "%",
			a: this._a
		};
	},
	toPercentageRgbString: function toPercentageRgbString() {
		return this._a == 1 ? "rgb(" + Math.round(bound01(this._r, 255) * 100) + "%, " + Math.round(bound01(this._g, 255) * 100) + "%, " + Math.round(bound01(this._b, 255) * 100) + "%)" : "rgba(" + Math.round(bound01(this._r, 255) * 100) + "%, " + Math.round(bound01(this._g, 255) * 100) + "%, " + Math.round(bound01(this._b, 255) * 100) + "%, " + this._roundA + ")";
	},
	toName: function toName() {
		if (this._a === 0) return "transparent";
		if (this._a < 1) return false;
		return hexNames[rgbToHex(this._r, this._g, this._b, true)] || false;
	},
	toFilter: function toFilter(secondColor) {
		var hex8String = "#" + rgbaToArgbHex(this._r, this._g, this._b, this._a);
		var secondHex8String = hex8String;
		var gradientType = this._gradientType ? "GradientType = 1, " : "";
		if (secondColor) {
			var s$1 = tinycolor(secondColor);
			secondHex8String = "#" + rgbaToArgbHex(s$1._r, s$1._g, s$1._b, s$1._a);
		}
		return "progid:DXImageTransform.Microsoft.gradient(" + gradientType + "startColorstr=" + hex8String + ",endColorstr=" + secondHex8String + ")";
	},
	toString: function toString(format) {
		var formatSet = !!format;
		format = format || this._format;
		var formattedString = false;
		var hasAlpha = this._a < 1 && this._a >= 0;
		if (!formatSet && hasAlpha && (format === "hex" || format === "hex6" || format === "hex3" || format === "hex4" || format === "hex8" || format === "name")) {
			if (format === "name" && this._a === 0) return this.toName();
			return this.toRgbString();
		}
		if (format === "rgb") formattedString = this.toRgbString();
		if (format === "prgb") formattedString = this.toPercentageRgbString();
		if (format === "hex" || format === "hex6") formattedString = this.toHexString();
		if (format === "hex3") formattedString = this.toHexString(true);
		if (format === "hex4") formattedString = this.toHex8String(true);
		if (format === "hex8") formattedString = this.toHex8String();
		if (format === "name") formattedString = this.toName();
		if (format === "hsl") formattedString = this.toHslString();
		if (format === "hsv") formattedString = this.toHsvString();
		return formattedString || this.toHexString();
	},
	clone: function clone() {
		return tinycolor(this.toString());
	},
	_applyModification: function _applyModification(fn, args) {
		var color$1 = fn.apply(null, [this].concat([].slice.call(args)));
		this._r = color$1._r;
		this._g = color$1._g;
		this._b = color$1._b;
		this.setAlpha(color$1._a);
		return this;
	},
	lighten: function lighten() {
		return this._applyModification(_lighten, arguments);
	},
	brighten: function brighten() {
		return this._applyModification(_brighten, arguments);
	},
	darken: function darken() {
		return this._applyModification(_darken, arguments);
	},
	desaturate: function desaturate() {
		return this._applyModification(_desaturate, arguments);
	},
	saturate: function saturate() {
		return this._applyModification(_saturate, arguments);
	},
	greyscale: function greyscale() {
		return this._applyModification(_greyscale, arguments);
	},
	spin: function spin() {
		return this._applyModification(_spin, arguments);
	},
	_applyCombination: function _applyCombination(fn, args) {
		return fn.apply(null, [this].concat([].slice.call(args)));
	},
	analogous: function analogous() {
		return this._applyCombination(_analogous, arguments);
	},
	complement: function complement() {
		return this._applyCombination(_complement, arguments);
	},
	monochromatic: function monochromatic() {
		return this._applyCombination(_monochromatic, arguments);
	},
	splitcomplement: function splitcomplement() {
		return this._applyCombination(_splitcomplement, arguments);
	},
	triad: function triad() {
		return this._applyCombination(polyad, [3]);
	},
	tetrad: function tetrad() {
		return this._applyCombination(polyad, [4]);
	}
};
tinycolor.fromRatio = function(color$1, opts) {
	if (_typeof$2(color$1) == "object") {
		var newColor = {};
		for (var i$1 in color$1) if (color$1.hasOwnProperty(i$1)) if (i$1 === "a") newColor[i$1] = color$1[i$1];
		else newColor[i$1] = convertToPercentage(color$1[i$1]);
		color$1 = newColor;
	}
	return tinycolor(color$1, opts);
};
function inputToRGB(color$1) {
	var rgb$1 = {
		r: 0,
		g: 0,
		b: 0
	};
	var a$2 = 1;
	var s$1 = null;
	var v$1 = null;
	var l$1 = null;
	var ok = false;
	var format = false;
	if (typeof color$1 == "string") color$1 = stringInputToObject(color$1);
	if (_typeof$2(color$1) == "object") {
		if (isValidCSSUnit(color$1.r) && isValidCSSUnit(color$1.g) && isValidCSSUnit(color$1.b)) {
			rgb$1 = rgbToRgb(color$1.r, color$1.g, color$1.b);
			ok = true;
			format = String(color$1.r).substr(-1) === "%" ? "prgb" : "rgb";
		} else if (isValidCSSUnit(color$1.h) && isValidCSSUnit(color$1.s) && isValidCSSUnit(color$1.v)) {
			s$1 = convertToPercentage(color$1.s);
			v$1 = convertToPercentage(color$1.v);
			rgb$1 = hsvToRgb(color$1.h, s$1, v$1);
			ok = true;
			format = "hsv";
		} else if (isValidCSSUnit(color$1.h) && isValidCSSUnit(color$1.s) && isValidCSSUnit(color$1.l)) {
			s$1 = convertToPercentage(color$1.s);
			l$1 = convertToPercentage(color$1.l);
			rgb$1 = hslToRgb(color$1.h, s$1, l$1);
			ok = true;
			format = "hsl";
		}
		if (color$1.hasOwnProperty("a")) a$2 = color$1.a;
	}
	a$2 = boundAlpha(a$2);
	return {
		ok,
		format: color$1.format || format,
		r: Math.min(255, Math.max(rgb$1.r, 0)),
		g: Math.min(255, Math.max(rgb$1.g, 0)),
		b: Math.min(255, Math.max(rgb$1.b, 0)),
		a: a$2
	};
}
function rgbToRgb(r$1, g$1, b) {
	return {
		r: bound01(r$1, 255) * 255,
		g: bound01(g$1, 255) * 255,
		b: bound01(b, 255) * 255
	};
}
function rgbToHsl(r$1, g$1, b) {
	r$1 = bound01(r$1, 255);
	g$1 = bound01(g$1, 255);
	b = bound01(b, 255);
	var max$2 = Math.max(r$1, g$1, b), min$2 = Math.min(r$1, g$1, b);
	var h$1, s$1, l$1 = (max$2 + min$2) / 2;
	if (max$2 == min$2) h$1 = s$1 = 0;
	else {
		var d$1 = max$2 - min$2;
		s$1 = l$1 > .5 ? d$1 / (2 - max$2 - min$2) : d$1 / (max$2 + min$2);
		switch (max$2) {
			case r$1:
				h$1 = (g$1 - b) / d$1 + (g$1 < b ? 6 : 0);
				break;
			case g$1:
				h$1 = (b - r$1) / d$1 + 2;
				break;
			case b:
				h$1 = (r$1 - g$1) / d$1 + 4;
				break;
		}
		h$1 /= 6;
	}
	return {
		h: h$1,
		s: s$1,
		l: l$1
	};
}
function hslToRgb(h$1, s$1, l$1) {
	var r$1, g$1, b;
	h$1 = bound01(h$1, 360);
	s$1 = bound01(s$1, 100);
	l$1 = bound01(l$1, 100);
	function hue2rgb(p$2, q$2, t$2) {
		if (t$2 < 0) t$2 += 1;
		if (t$2 > 1) t$2 -= 1;
		if (t$2 < 1 / 6) return p$2 + (q$2 - p$2) * 6 * t$2;
		if (t$2 < 1 / 2) return q$2;
		if (t$2 < 2 / 3) return p$2 + (q$2 - p$2) * (2 / 3 - t$2) * 6;
		return p$2;
	}
	if (s$1 === 0) r$1 = g$1 = b = l$1;
	else {
		var q$1 = l$1 < .5 ? l$1 * (1 + s$1) : l$1 + s$1 - l$1 * s$1;
		var p$1 = 2 * l$1 - q$1;
		r$1 = hue2rgb(p$1, q$1, h$1 + 1 / 3);
		g$1 = hue2rgb(p$1, q$1, h$1);
		b = hue2rgb(p$1, q$1, h$1 - 1 / 3);
	}
	return {
		r: r$1 * 255,
		g: g$1 * 255,
		b: b * 255
	};
}
function rgbToHsv(r$1, g$1, b) {
	r$1 = bound01(r$1, 255);
	g$1 = bound01(g$1, 255);
	b = bound01(b, 255);
	var max$2 = Math.max(r$1, g$1, b), min$2 = Math.min(r$1, g$1, b);
	var h$1, s$1, v$1 = max$2;
	var d$1 = max$2 - min$2;
	s$1 = max$2 === 0 ? 0 : d$1 / max$2;
	if (max$2 == min$2) h$1 = 0;
	else {
		switch (max$2) {
			case r$1:
				h$1 = (g$1 - b) / d$1 + (g$1 < b ? 6 : 0);
				break;
			case g$1:
				h$1 = (b - r$1) / d$1 + 2;
				break;
			case b:
				h$1 = (r$1 - g$1) / d$1 + 4;
				break;
		}
		h$1 /= 6;
	}
	return {
		h: h$1,
		s: s$1,
		v: v$1
	};
}
function hsvToRgb(h$1, s$1, v$1) {
	h$1 = bound01(h$1, 360) * 6;
	s$1 = bound01(s$1, 100);
	v$1 = bound01(v$1, 100);
	var i$1 = Math.floor(h$1), f$1 = h$1 - i$1, p$1 = v$1 * (1 - s$1), q$1 = v$1 * (1 - f$1 * s$1), t$2 = v$1 * (1 - (1 - f$1) * s$1), mod = i$1 % 6, r$1 = [
		v$1,
		q$1,
		p$1,
		p$1,
		t$2,
		v$1
	][mod], g$1 = [
		t$2,
		v$1,
		v$1,
		q$1,
		p$1,
		p$1
	][mod], b = [
		p$1,
		p$1,
		t$2,
		v$1,
		v$1,
		q$1
	][mod];
	return {
		r: r$1 * 255,
		g: g$1 * 255,
		b: b * 255
	};
}
function rgbToHex(r$1, g$1, b, allow3Char) {
	var hex$1 = [
		pad2(Math.round(r$1).toString(16)),
		pad2(Math.round(g$1).toString(16)),
		pad2(Math.round(b).toString(16))
	];
	if (allow3Char && hex$1[0].charAt(0) == hex$1[0].charAt(1) && hex$1[1].charAt(0) == hex$1[1].charAt(1) && hex$1[2].charAt(0) == hex$1[2].charAt(1)) return hex$1[0].charAt(0) + hex$1[1].charAt(0) + hex$1[2].charAt(0);
	return hex$1.join("");
}
function rgbaToHex(r$1, g$1, b, a$2, allow4Char) {
	var hex$1 = [
		pad2(Math.round(r$1).toString(16)),
		pad2(Math.round(g$1).toString(16)),
		pad2(Math.round(b).toString(16)),
		pad2(convertDecimalToHex(a$2))
	];
	if (allow4Char && hex$1[0].charAt(0) == hex$1[0].charAt(1) && hex$1[1].charAt(0) == hex$1[1].charAt(1) && hex$1[2].charAt(0) == hex$1[2].charAt(1) && hex$1[3].charAt(0) == hex$1[3].charAt(1)) return hex$1[0].charAt(0) + hex$1[1].charAt(0) + hex$1[2].charAt(0) + hex$1[3].charAt(0);
	return hex$1.join("");
}
function rgbaToArgbHex(r$1, g$1, b, a$2) {
	return [
		pad2(convertDecimalToHex(a$2)),
		pad2(Math.round(r$1).toString(16)),
		pad2(Math.round(g$1).toString(16)),
		pad2(Math.round(b).toString(16))
	].join("");
}
tinycolor.equals = function(color1, color2) {
	if (!color1 || !color2) return false;
	return tinycolor(color1).toRgbString() == tinycolor(color2).toRgbString();
};
tinycolor.random = function() {
	return tinycolor.fromRatio({
		r: Math.random(),
		g: Math.random(),
		b: Math.random()
	});
};
function _desaturate(color$1, amount) {
	amount = amount === 0 ? 0 : amount || 10;
	var hsl$1 = tinycolor(color$1).toHsl();
	hsl$1.s -= amount / 100;
	hsl$1.s = clamp01(hsl$1.s);
	return tinycolor(hsl$1);
}
function _saturate(color$1, amount) {
	amount = amount === 0 ? 0 : amount || 10;
	var hsl$1 = tinycolor(color$1).toHsl();
	hsl$1.s += amount / 100;
	hsl$1.s = clamp01(hsl$1.s);
	return tinycolor(hsl$1);
}
function _greyscale(color$1) {
	return tinycolor(color$1).desaturate(100);
}
function _lighten(color$1, amount) {
	amount = amount === 0 ? 0 : amount || 10;
	var hsl$1 = tinycolor(color$1).toHsl();
	hsl$1.l += amount / 100;
	hsl$1.l = clamp01(hsl$1.l);
	return tinycolor(hsl$1);
}
function _brighten(color$1, amount) {
	amount = amount === 0 ? 0 : amount || 10;
	var rgb$1 = tinycolor(color$1).toRgb();
	rgb$1.r = Math.max(0, Math.min(255, rgb$1.r - Math.round(255 * -(amount / 100))));
	rgb$1.g = Math.max(0, Math.min(255, rgb$1.g - Math.round(255 * -(amount / 100))));
	rgb$1.b = Math.max(0, Math.min(255, rgb$1.b - Math.round(255 * -(amount / 100))));
	return tinycolor(rgb$1);
}
function _darken(color$1, amount) {
	amount = amount === 0 ? 0 : amount || 10;
	var hsl$1 = tinycolor(color$1).toHsl();
	hsl$1.l -= amount / 100;
	hsl$1.l = clamp01(hsl$1.l);
	return tinycolor(hsl$1);
}
function _spin(color$1, amount) {
	var hsl$1 = tinycolor(color$1).toHsl();
	var hue = (hsl$1.h + amount) % 360;
	hsl$1.h = hue < 0 ? 360 + hue : hue;
	return tinycolor(hsl$1);
}
function _complement(color$1) {
	var hsl$1 = tinycolor(color$1).toHsl();
	hsl$1.h = (hsl$1.h + 180) % 360;
	return tinycolor(hsl$1);
}
function polyad(color$1, number) {
	if (isNaN(number) || number <= 0) throw new Error("Argument to polyad must be a positive number");
	var hsl$1 = tinycolor(color$1).toHsl();
	var result = [tinycolor(color$1)];
	var step = 360 / number;
	for (var i$1 = 1; i$1 < number; i$1++) result.push(tinycolor({
		h: (hsl$1.h + i$1 * step) % 360,
		s: hsl$1.s,
		l: hsl$1.l
	}));
	return result;
}
function _splitcomplement(color$1) {
	var hsl$1 = tinycolor(color$1).toHsl();
	var h$1 = hsl$1.h;
	return [
		tinycolor(color$1),
		tinycolor({
			h: (h$1 + 72) % 360,
			s: hsl$1.s,
			l: hsl$1.l
		}),
		tinycolor({
			h: (h$1 + 216) % 360,
			s: hsl$1.s,
			l: hsl$1.l
		})
	];
}
function _analogous(color$1, results, slices) {
	results = results || 6;
	slices = slices || 30;
	var hsl$1 = tinycolor(color$1).toHsl();
	var part = 360 / slices;
	var ret = [tinycolor(color$1)];
	for (hsl$1.h = (hsl$1.h - (part * results >> 1) + 720) % 360; --results;) {
		hsl$1.h = (hsl$1.h + part) % 360;
		ret.push(tinycolor(hsl$1));
	}
	return ret;
}
function _monochromatic(color$1, results) {
	results = results || 6;
	var hsv = tinycolor(color$1).toHsv();
	var h$1 = hsv.h, s$1 = hsv.s, v$1 = hsv.v;
	var ret = [];
	var modification = 1 / results;
	while (results--) {
		ret.push(tinycolor({
			h: h$1,
			s: s$1,
			v: v$1
		}));
		v$1 = (v$1 + modification) % 1;
	}
	return ret;
}
tinycolor.mix = function(color1, color2, amount) {
	amount = amount === 0 ? 0 : amount || 50;
	var rgb1 = tinycolor(color1).toRgb();
	var rgb2 = tinycolor(color2).toRgb();
	var p$1 = amount / 100;
	return tinycolor({
		r: (rgb2.r - rgb1.r) * p$1 + rgb1.r,
		g: (rgb2.g - rgb1.g) * p$1 + rgb1.g,
		b: (rgb2.b - rgb1.b) * p$1 + rgb1.b,
		a: (rgb2.a - rgb1.a) * p$1 + rgb1.a
	});
};
tinycolor.readability = function(color1, color2) {
	var c1 = tinycolor(color1);
	var c2 = tinycolor(color2);
	return (Math.max(c1.getLuminance(), c2.getLuminance()) + .05) / (Math.min(c1.getLuminance(), c2.getLuminance()) + .05);
};
tinycolor.isReadable = function(color1, color2, wcag2) {
	var readability = tinycolor.readability(color1, color2);
	var wcag2Parms, out = false;
	wcag2Parms = validateWCAG2Parms(wcag2);
	switch (wcag2Parms.level + wcag2Parms.size) {
		case "AAsmall":
		case "AAAlarge":
			out = readability >= 4.5;
			break;
		case "AAlarge":
			out = readability >= 3;
			break;
		case "AAAsmall":
			out = readability >= 7;
			break;
	}
	return out;
};
tinycolor.mostReadable = function(baseColor, colorList, args) {
	var bestColor = null;
	var bestScore = 0;
	var readability;
	var includeFallbackColors, level, size;
	args = args || {};
	includeFallbackColors = args.includeFallbackColors;
	level = args.level;
	size = args.size;
	for (var i$1 = 0; i$1 < colorList.length; i$1++) {
		readability = tinycolor.readability(baseColor, colorList[i$1]);
		if (readability > bestScore) {
			bestScore = readability;
			bestColor = tinycolor(colorList[i$1]);
		}
	}
	if (tinycolor.isReadable(baseColor, bestColor, {
		level,
		size
	}) || !includeFallbackColors) return bestColor;
	else {
		args.includeFallbackColors = false;
		return tinycolor.mostReadable(baseColor, ["#fff", "#000"], args);
	}
};
var names = tinycolor.names = {
	aliceblue: "f0f8ff",
	antiquewhite: "faebd7",
	aqua: "0ff",
	aquamarine: "7fffd4",
	azure: "f0ffff",
	beige: "f5f5dc",
	bisque: "ffe4c4",
	black: "000",
	blanchedalmond: "ffebcd",
	blue: "00f",
	blueviolet: "8a2be2",
	brown: "a52a2a",
	burlywood: "deb887",
	burntsienna: "ea7e5d",
	cadetblue: "5f9ea0",
	chartreuse: "7fff00",
	chocolate: "d2691e",
	coral: "ff7f50",
	cornflowerblue: "6495ed",
	cornsilk: "fff8dc",
	crimson: "dc143c",
	cyan: "0ff",
	darkblue: "00008b",
	darkcyan: "008b8b",
	darkgoldenrod: "b8860b",
	darkgray: "a9a9a9",
	darkgreen: "006400",
	darkgrey: "a9a9a9",
	darkkhaki: "bdb76b",
	darkmagenta: "8b008b",
	darkolivegreen: "556b2f",
	darkorange: "ff8c00",
	darkorchid: "9932cc",
	darkred: "8b0000",
	darksalmon: "e9967a",
	darkseagreen: "8fbc8f",
	darkslateblue: "483d8b",
	darkslategray: "2f4f4f",
	darkslategrey: "2f4f4f",
	darkturquoise: "00ced1",
	darkviolet: "9400d3",
	deeppink: "ff1493",
	deepskyblue: "00bfff",
	dimgray: "696969",
	dimgrey: "696969",
	dodgerblue: "1e90ff",
	firebrick: "b22222",
	floralwhite: "fffaf0",
	forestgreen: "228b22",
	fuchsia: "f0f",
	gainsboro: "dcdcdc",
	ghostwhite: "f8f8ff",
	gold: "ffd700",
	goldenrod: "daa520",
	gray: "808080",
	green: "008000",
	greenyellow: "adff2f",
	grey: "808080",
	honeydew: "f0fff0",
	hotpink: "ff69b4",
	indianred: "cd5c5c",
	indigo: "4b0082",
	ivory: "fffff0",
	khaki: "f0e68c",
	lavender: "e6e6fa",
	lavenderblush: "fff0f5",
	lawngreen: "7cfc00",
	lemonchiffon: "fffacd",
	lightblue: "add8e6",
	lightcoral: "f08080",
	lightcyan: "e0ffff",
	lightgoldenrodyellow: "fafad2",
	lightgray: "d3d3d3",
	lightgreen: "90ee90",
	lightgrey: "d3d3d3",
	lightpink: "ffb6c1",
	lightsalmon: "ffa07a",
	lightseagreen: "20b2aa",
	lightskyblue: "87cefa",
	lightslategray: "789",
	lightslategrey: "789",
	lightsteelblue: "b0c4de",
	lightyellow: "ffffe0",
	lime: "0f0",
	limegreen: "32cd32",
	linen: "faf0e6",
	magenta: "f0f",
	maroon: "800000",
	mediumaquamarine: "66cdaa",
	mediumblue: "0000cd",
	mediumorchid: "ba55d3",
	mediumpurple: "9370db",
	mediumseagreen: "3cb371",
	mediumslateblue: "7b68ee",
	mediumspringgreen: "00fa9a",
	mediumturquoise: "48d1cc",
	mediumvioletred: "c71585",
	midnightblue: "191970",
	mintcream: "f5fffa",
	mistyrose: "ffe4e1",
	moccasin: "ffe4b5",
	navajowhite: "ffdead",
	navy: "000080",
	oldlace: "fdf5e6",
	olive: "808000",
	olivedrab: "6b8e23",
	orange: "ffa500",
	orangered: "ff4500",
	orchid: "da70d6",
	palegoldenrod: "eee8aa",
	palegreen: "98fb98",
	paleturquoise: "afeeee",
	palevioletred: "db7093",
	papayawhip: "ffefd5",
	peachpuff: "ffdab9",
	peru: "cd853f",
	pink: "ffc0cb",
	plum: "dda0dd",
	powderblue: "b0e0e6",
	purple: "800080",
	rebeccapurple: "663399",
	red: "f00",
	rosybrown: "bc8f8f",
	royalblue: "4169e1",
	saddlebrown: "8b4513",
	salmon: "fa8072",
	sandybrown: "f4a460",
	seagreen: "2e8b57",
	seashell: "fff5ee",
	sienna: "a0522d",
	silver: "c0c0c0",
	skyblue: "87ceeb",
	slateblue: "6a5acd",
	slategray: "708090",
	slategrey: "708090",
	snow: "fffafa",
	springgreen: "00ff7f",
	steelblue: "4682b4",
	tan: "d2b48c",
	teal: "008080",
	thistle: "d8bfd8",
	tomato: "ff6347",
	turquoise: "40e0d0",
	violet: "ee82ee",
	wheat: "f5deb3",
	white: "fff",
	whitesmoke: "f5f5f5",
	yellow: "ff0",
	yellowgreen: "9acd32"
};
var hexNames = tinycolor.hexNames = flip(names);
function flip(o$1) {
	var flipped = {};
	for (var i$1 in o$1) if (o$1.hasOwnProperty(i$1)) flipped[o$1[i$1]] = i$1;
	return flipped;
}
function boundAlpha(a$2) {
	a$2 = parseFloat(a$2);
	if (isNaN(a$2) || a$2 < 0 || a$2 > 1) a$2 = 1;
	return a$2;
}
function bound01(n$1, max$2) {
	if (isOnePointZero(n$1)) n$1 = "100%";
	var processPercent = isPercentage(n$1);
	n$1 = Math.min(max$2, Math.max(0, parseFloat(n$1)));
	if (processPercent) n$1 = parseInt(n$1 * max$2, 10) / 100;
	if (Math.abs(n$1 - max$2) < 1e-6) return 1;
	return n$1 % max$2 / parseFloat(max$2);
}
function clamp01(val) {
	return Math.min(1, Math.max(0, val));
}
function parseIntFromHex(val) {
	return parseInt(val, 16);
}
function isOnePointZero(n$1) {
	return typeof n$1 == "string" && n$1.indexOf(".") != -1 && parseFloat(n$1) === 1;
}
function isPercentage(n$1) {
	return typeof n$1 === "string" && n$1.indexOf("%") != -1;
}
function pad2(c$2) {
	return c$2.length == 1 ? "0" + c$2 : "" + c$2;
}
function convertToPercentage(n$1) {
	if (n$1 <= 1) n$1 = n$1 * 100 + "%";
	return n$1;
}
function convertDecimalToHex(d$1) {
	return Math.round(parseFloat(d$1) * 255).toString(16);
}
function convertHexToDecimal(h$1) {
	return parseIntFromHex(h$1) / 255;
}
var matchers = function() {
	var CSS_UNIT = "(?:[-\\+]?\\d*\\.\\d+%?)|(?:[-\\+]?\\d+%?)";
	var PERMISSIVE_MATCH3 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";
	var PERMISSIVE_MATCH4 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";
	return {
		CSS_UNIT: new RegExp(CSS_UNIT),
		rgb: /* @__PURE__ */ new RegExp("rgb" + PERMISSIVE_MATCH3),
		rgba: /* @__PURE__ */ new RegExp("rgba" + PERMISSIVE_MATCH4),
		hsl: /* @__PURE__ */ new RegExp("hsl" + PERMISSIVE_MATCH3),
		hsla: /* @__PURE__ */ new RegExp("hsla" + PERMISSIVE_MATCH4),
		hsv: /* @__PURE__ */ new RegExp("hsv" + PERMISSIVE_MATCH3),
		hsva: /* @__PURE__ */ new RegExp("hsva" + PERMISSIVE_MATCH4),
		hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
		hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
		hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
		hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
	};
}();
function isValidCSSUnit(color$1) {
	return !!matchers.CSS_UNIT.exec(color$1);
}
function stringInputToObject(color$1) {
	color$1 = color$1.replace(trimLeft, "").replace(trimRight, "").toLowerCase();
	var named$1 = false;
	if (names[color$1]) {
		color$1 = names[color$1];
		named$1 = true;
	} else if (color$1 == "transparent") return {
		r: 0,
		g: 0,
		b: 0,
		a: 0,
		format: "name"
	};
	var match;
	if (match = matchers.rgb.exec(color$1)) return {
		r: match[1],
		g: match[2],
		b: match[3]
	};
	if (match = matchers.rgba.exec(color$1)) return {
		r: match[1],
		g: match[2],
		b: match[3],
		a: match[4]
	};
	if (match = matchers.hsl.exec(color$1)) return {
		h: match[1],
		s: match[2],
		l: match[3]
	};
	if (match = matchers.hsla.exec(color$1)) return {
		h: match[1],
		s: match[2],
		l: match[3],
		a: match[4]
	};
	if (match = matchers.hsv.exec(color$1)) return {
		h: match[1],
		s: match[2],
		v: match[3]
	};
	if (match = matchers.hsva.exec(color$1)) return {
		h: match[1],
		s: match[2],
		v: match[3],
		a: match[4]
	};
	if (match = matchers.hex8.exec(color$1)) return {
		r: parseIntFromHex(match[1]),
		g: parseIntFromHex(match[2]),
		b: parseIntFromHex(match[3]),
		a: convertHexToDecimal(match[4]),
		format: named$1 ? "name" : "hex8"
	};
	if (match = matchers.hex6.exec(color$1)) return {
		r: parseIntFromHex(match[1]),
		g: parseIntFromHex(match[2]),
		b: parseIntFromHex(match[3]),
		format: named$1 ? "name" : "hex"
	};
	if (match = matchers.hex4.exec(color$1)) return {
		r: parseIntFromHex(match[1] + "" + match[1]),
		g: parseIntFromHex(match[2] + "" + match[2]),
		b: parseIntFromHex(match[3] + "" + match[3]),
		a: convertHexToDecimal(match[4] + "" + match[4]),
		format: named$1 ? "name" : "hex8"
	};
	if (match = matchers.hex3.exec(color$1)) return {
		r: parseIntFromHex(match[1] + "" + match[1]),
		g: parseIntFromHex(match[2] + "" + match[2]),
		b: parseIntFromHex(match[3] + "" + match[3]),
		format: named$1 ? "name" : "hex"
	};
	return false;
}
function validateWCAG2Parms(parms) {
	var level, size;
	parms = parms || {
		level: "AA",
		size: "small"
	};
	level = (parms.level || "AA").toUpperCase();
	size = (parms.size || "small").toLowerCase();
	if (level !== "AA" && level !== "AAA") level = "AA";
	if (size !== "small" && size !== "large") size = "small";
	return {
		level,
		size
	};
}

//#endregion
//#region node_modules/canvas-color-tracker/dist/canvas-color-tracker.mjs
function _arrayLikeToArray$3(r$1, a$2) {
	(null == a$2 || a$2 > r$1.length) && (a$2 = r$1.length);
	for (var e$1 = 0, n$1 = Array(a$2); e$1 < a$2; e$1++) n$1[e$1] = r$1[e$1];
	return n$1;
}
function _arrayWithoutHoles$2(r$1) {
	if (Array.isArray(r$1)) return _arrayLikeToArray$3(r$1);
}
function _assertClassBrand(e$1, t$2, n$1) {
	if ("function" == typeof e$1 ? e$1 === t$2 : e$1.has(t$2)) return arguments.length < 3 ? t$2 : n$1;
	throw new TypeError("Private element is not present on this object");
}
function _checkPrivateRedeclaration(e$1, t$2) {
	if (t$2.has(e$1)) throw new TypeError("Cannot initialize the same private elements twice on an object");
}
function _classCallCheck(a$2, n$1) {
	if (!(a$2 instanceof n$1)) throw new TypeError("Cannot call a class as a function");
}
function _classPrivateFieldGet2(s$1, a$2) {
	return s$1.get(_assertClassBrand(s$1, a$2));
}
function _classPrivateFieldInitSpec(e$1, t$2, a$2) {
	_checkPrivateRedeclaration(e$1, t$2), t$2.set(e$1, a$2);
}
function _classPrivateFieldSet2(s$1, a$2, r$1) {
	return s$1.set(_assertClassBrand(s$1, a$2), r$1), r$1;
}
function _defineProperties(e$1, r$1) {
	for (var t$2 = 0; t$2 < r$1.length; t$2++) {
		var o$1 = r$1[t$2];
		o$1.enumerable = o$1.enumerable || false, o$1.configurable = true, "value" in o$1 && (o$1.writable = true), Object.defineProperty(e$1, _toPropertyKey$3(o$1.key), o$1);
	}
}
function _createClass(e$1, r$1, t$2) {
	return r$1 && _defineProperties(e$1.prototype, r$1), Object.defineProperty(e$1, "prototype", { writable: false }), e$1;
}
function _iterableToArray$2(r$1) {
	if ("undefined" != typeof Symbol && null != r$1[Symbol.iterator] || null != r$1["@@iterator"]) return Array.from(r$1);
}
function _nonIterableSpread$2() {
	throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _toConsumableArray$2(r$1) {
	return _arrayWithoutHoles$2(r$1) || _iterableToArray$2(r$1) || _unsupportedIterableToArray$3(r$1) || _nonIterableSpread$2();
}
function _toPrimitive$3(t$2, r$1) {
	if ("object" != typeof t$2 || !t$2) return t$2;
	var e$1 = t$2[Symbol.toPrimitive];
	if (void 0 !== e$1) {
		var i$1 = e$1.call(t$2, r$1);
		if ("object" != typeof i$1) return i$1;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return String(t$2);
}
function _toPropertyKey$3(t$2) {
	var i$1 = _toPrimitive$3(t$2, "string");
	return "symbol" == typeof i$1 ? i$1 : i$1 + "";
}
function _unsupportedIterableToArray$3(r$1, a$2) {
	if (r$1) {
		if ("string" == typeof r$1) return _arrayLikeToArray$3(r$1, a$2);
		var t$2 = {}.toString.call(r$1).slice(8, -1);
		return "Object" === t$2 && r$1.constructor && (t$2 = r$1.constructor.name), "Map" === t$2 || "Set" === t$2 ? Array.from(r$1) : "Arguments" === t$2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t$2) ? _arrayLikeToArray$3(r$1, a$2) : void 0;
	}
}
var ENTROPY = 123;
var int2HexColor = function int2HexColor$1(num) {
	return "#".concat(Math.min(num, Math.pow(2, 24)).toString(16).padStart(6, "0"));
};
var rgb2Int = function rgb2Int$1(r$1, g$1, b) {
	return (r$1 << 16) + (g$1 << 8) + b;
};
var colorStr2Int = function colorStr2Int$1(str) {
	var _tinyColor$toRgb = tinycolor(str).toRgb(), r$1 = _tinyColor$toRgb.r, g$1 = _tinyColor$toRgb.g, b = _tinyColor$toRgb.b;
	return rgb2Int(r$1, g$1, b);
};
var checksum = function checksum$1(n$1, csBits) {
	return n$1 * ENTROPY % Math.pow(2, csBits);
};
var _registry = /* @__PURE__ */ new WeakMap();
var _csBits = /* @__PURE__ */ new WeakMap();
var _default = /* @__PURE__ */ function() {
	function _default$1() {
		var csBits = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 6;
		_classCallCheck(this, _default$1);
		_classPrivateFieldInitSpec(this, _registry, void 0);
		_classPrivateFieldInitSpec(this, _csBits, void 0);
		_classPrivateFieldSet2(_csBits, this, csBits);
		this.reset();
	}
	return _createClass(_default$1, [
		{
			key: "reset",
			value: function reset() {
				_classPrivateFieldSet2(_registry, this, ["__reserved for background__"]);
			}
		},
		{
			key: "register",
			value: function register(obj) {
				if (_classPrivateFieldGet2(_registry, this).length >= Math.pow(2, 24 - _classPrivateFieldGet2(_csBits, this))) return null;
				var idx = _classPrivateFieldGet2(_registry, this).length;
				var color$1 = int2HexColor(idx + (checksum(idx, _classPrivateFieldGet2(_csBits, this)) << 24 - _classPrivateFieldGet2(_csBits, this)));
				_classPrivateFieldGet2(_registry, this).push(obj);
				return color$1;
			}
		},
		{
			key: "lookup",
			value: function lookup(color$1) {
				if (!color$1) return null;
				var n$1 = typeof color$1 === "string" ? colorStr2Int(color$1) : rgb2Int.apply(void 0, _toConsumableArray$2(color$1));
				if (!n$1) return null;
				var idx = n$1 & Math.pow(2, 24 - _classPrivateFieldGet2(_csBits, this)) - 1;
				var cs = n$1 >> 24 - _classPrivateFieldGet2(_csBits, this) & Math.pow(2, _classPrivateFieldGet2(_csBits, this)) - 1;
				if (checksum(idx, _classPrivateFieldGet2(_csBits, this)) !== cs || idx >= _classPrivateFieldGet2(_registry, this).length) return null;
				return _classPrivateFieldGet2(_registry, this)[idx];
			}
		}
	]);
}();

//#endregion
//#region node_modules/preact/dist/preact.module.js
var n, l, u, t$1, i, r, o, e, f, c$1, s, a$1, h, p = {}, v = [], y$1 = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i, w = Array.isArray;
function d(n$1, l$1) {
	for (var u$1 in l$1) n$1[u$1] = l$1[u$1];
	return n$1;
}
function g(n$1) {
	n$1 && n$1.parentNode && n$1.parentNode.removeChild(n$1);
}
function _(l$1, u$1, t$2) {
	var i$1, r$1, o$1, e$1 = {};
	for (o$1 in u$1) "key" == o$1 ? i$1 = u$1[o$1] : "ref" == o$1 ? r$1 = u$1[o$1] : e$1[o$1] = u$1[o$1];
	if (arguments.length > 2 && (e$1.children = arguments.length > 3 ? n.call(arguments, 2) : t$2), "function" == typeof l$1 && null != l$1.defaultProps) for (o$1 in l$1.defaultProps) void 0 === e$1[o$1] && (e$1[o$1] = l$1.defaultProps[o$1]);
	return m$1(l$1, e$1, i$1, r$1, null);
}
function m$1(n$1, t$2, i$1, r$1, o$1) {
	var e$1 = {
		type: n$1,
		props: t$2,
		key: i$1,
		ref: r$1,
		__k: null,
		__: null,
		__b: 0,
		__e: null,
		__c: null,
		constructor: void 0,
		__v: null == o$1 ? ++u : o$1,
		__i: -1,
		__u: 0
	};
	return null == o$1 && null != l.vnode && l.vnode(e$1), e$1;
}
function k(n$1) {
	return n$1.children;
}
function x$1(n$1, l$1) {
	this.props = n$1, this.context = l$1;
}
function S(n$1, l$1) {
	if (null == l$1) return n$1.__ ? S(n$1.__, n$1.__i + 1) : null;
	for (var u$1; l$1 < n$1.__k.length; l$1++) if (null != (u$1 = n$1.__k[l$1]) && null != u$1.__e) return u$1.__e;
	return "function" == typeof n$1.type ? S(n$1) : null;
}
function C(n$1) {
	var l$1, u$1;
	if (null != (n$1 = n$1.__) && null != n$1.__c) {
		for (n$1.__e = n$1.__c.base = null, l$1 = 0; l$1 < n$1.__k.length; l$1++) if (null != (u$1 = n$1.__k[l$1]) && null != u$1.__e) {
			n$1.__e = n$1.__c.base = u$1.__e;
			break;
		}
		return C(n$1);
	}
}
function M(n$1) {
	(!n$1.__d && (n$1.__d = !0) && i.push(n$1) && !$.__r++ || r != l.debounceRendering) && ((r = l.debounceRendering) || o)($);
}
function $() {
	for (var n$1, u$1, t$2, r$1, o$1, f$1, c$2, s$1 = 1; i.length;) i.length > s$1 && i.sort(e), n$1 = i.shift(), s$1 = i.length, n$1.__d && (t$2 = void 0, r$1 = void 0, o$1 = (r$1 = (u$1 = n$1).__v).__e, f$1 = [], c$2 = [], u$1.__P && ((t$2 = d({}, r$1)).__v = r$1.__v + 1, l.vnode && l.vnode(t$2), O(u$1.__P, t$2, r$1, u$1.__n, u$1.__P.namespaceURI, 32 & r$1.__u ? [o$1] : null, f$1, null == o$1 ? S(r$1) : o$1, !!(32 & r$1.__u), c$2), t$2.__v = r$1.__v, t$2.__.__k[t$2.__i] = t$2, N(f$1, t$2, c$2), r$1.__e = r$1.__ = null, t$2.__e != o$1 && C(t$2)));
	$.__r = 0;
}
function I(n$1, l$1, u$1, t$2, i$1, r$1, o$1, e$1, f$1, c$2, s$1) {
	var a$2, h$1, y$2, w$1, d$1, g$1, _$1, m$2 = t$2 && t$2.__k || v, b = l$1.length;
	for (f$1 = P(u$1, l$1, m$2, f$1, b), a$2 = 0; a$2 < b; a$2++) null != (y$2 = u$1.__k[a$2]) && (h$1 = -1 == y$2.__i ? p : m$2[y$2.__i] || p, y$2.__i = a$2, g$1 = O(n$1, y$2, h$1, i$1, r$1, o$1, e$1, f$1, c$2, s$1), w$1 = y$2.__e, y$2.ref && h$1.ref != y$2.ref && (h$1.ref && B(h$1.ref, null, y$2), s$1.push(y$2.ref, y$2.__c || w$1, y$2)), null == d$1 && null != w$1 && (d$1 = w$1), (_$1 = !!(4 & y$2.__u)) || h$1.__k === y$2.__k ? f$1 = A(y$2, f$1, n$1, _$1) : "function" == typeof y$2.type && void 0 !== g$1 ? f$1 = g$1 : w$1 && (f$1 = w$1.nextSibling), y$2.__u &= -7);
	return u$1.__e = d$1, f$1;
}
function P(n$1, l$1, u$1, t$2, i$1) {
	var r$1, o$1, e$1, f$1, c$2, s$1 = u$1.length, a$2 = s$1, h$1 = 0;
	for (n$1.__k = new Array(i$1), r$1 = 0; r$1 < i$1; r$1++) null != (o$1 = l$1[r$1]) && "boolean" != typeof o$1 && "function" != typeof o$1 ? ("string" == typeof o$1 || "number" == typeof o$1 || "bigint" == typeof o$1 || o$1.constructor == String ? o$1 = n$1.__k[r$1] = m$1(null, o$1, null, null, null) : w(o$1) ? o$1 = n$1.__k[r$1] = m$1(k, { children: o$1 }, null, null, null) : null == o$1.constructor && o$1.__b > 0 ? o$1 = n$1.__k[r$1] = m$1(o$1.type, o$1.props, o$1.key, o$1.ref ? o$1.ref : null, o$1.__v) : n$1.__k[r$1] = o$1, f$1 = r$1 + h$1, o$1.__ = n$1, o$1.__b = n$1.__b + 1, -1 != (c$2 = o$1.__i = L(o$1, u$1, f$1, a$2)) && (a$2--, (e$1 = u$1[c$2]) && (e$1.__u |= 2)), null == e$1 || null == e$1.__v ? (-1 == c$2 && (i$1 > s$1 ? h$1-- : i$1 < s$1 && h$1++), "function" != typeof o$1.type && (o$1.__u |= 4)) : c$2 != f$1 && (c$2 == f$1 - 1 ? h$1-- : c$2 == f$1 + 1 ? h$1++ : (c$2 > f$1 ? h$1-- : h$1++, o$1.__u |= 4))) : n$1.__k[r$1] = null;
	if (a$2) for (r$1 = 0; r$1 < s$1; r$1++) null != (e$1 = u$1[r$1]) && 0 == (2 & e$1.__u) && (e$1.__e == t$2 && (t$2 = S(e$1)), D(e$1, e$1));
	return t$2;
}
function A(n$1, l$1, u$1, t$2) {
	var i$1, r$1;
	if ("function" == typeof n$1.type) {
		for (i$1 = n$1.__k, r$1 = 0; i$1 && r$1 < i$1.length; r$1++) i$1[r$1] && (i$1[r$1].__ = n$1, l$1 = A(i$1[r$1], l$1, u$1, t$2));
		return l$1;
	}
	n$1.__e != l$1 && (t$2 && (l$1 && n$1.type && !l$1.parentNode && (l$1 = S(n$1)), u$1.insertBefore(n$1.__e, l$1 || null)), l$1 = n$1.__e);
	do
		l$1 = l$1 && l$1.nextSibling;
	while (null != l$1 && 8 == l$1.nodeType);
	return l$1;
}
function L(n$1, l$1, u$1, t$2) {
	var i$1, r$1, o$1, e$1 = n$1.key, f$1 = n$1.type, c$2 = l$1[u$1], s$1 = null != c$2 && 0 == (2 & c$2.__u);
	if (null === c$2 && null == e$1 || s$1 && e$1 == c$2.key && f$1 == c$2.type) return u$1;
	if (t$2 > (s$1 ? 1 : 0)) {
		for (i$1 = u$1 - 1, r$1 = u$1 + 1; i$1 >= 0 || r$1 < l$1.length;) if (null != (c$2 = l$1[o$1 = i$1 >= 0 ? i$1-- : r$1++]) && 0 == (2 & c$2.__u) && e$1 == c$2.key && f$1 == c$2.type) return o$1;
	}
	return -1;
}
function T(n$1, l$1, u$1) {
	"-" == l$1[0] ? n$1.setProperty(l$1, null == u$1 ? "" : u$1) : n$1[l$1] = null == u$1 ? "" : "number" != typeof u$1 || y$1.test(l$1) ? u$1 : u$1 + "px";
}
function j(n$1, l$1, u$1, t$2, i$1) {
	var r$1, o$1;
	n: if ("style" == l$1) if ("string" == typeof u$1) n$1.style.cssText = u$1;
	else {
		if ("string" == typeof t$2 && (n$1.style.cssText = t$2 = ""), t$2) for (l$1 in t$2) u$1 && l$1 in u$1 || T(n$1.style, l$1, "");
		if (u$1) for (l$1 in u$1) t$2 && u$1[l$1] == t$2[l$1] || T(n$1.style, l$1, u$1[l$1]);
	}
	else if ("o" == l$1[0] && "n" == l$1[1]) r$1 = l$1 != (l$1 = l$1.replace(f, "$1")), o$1 = l$1.toLowerCase(), l$1 = o$1 in n$1 || "onFocusOut" == l$1 || "onFocusIn" == l$1 ? o$1.slice(2) : l$1.slice(2), n$1.l || (n$1.l = {}), n$1.l[l$1 + r$1] = u$1, u$1 ? t$2 ? u$1.u = t$2.u : (u$1.u = c$1, n$1.addEventListener(l$1, r$1 ? a$1 : s, r$1)) : n$1.removeEventListener(l$1, r$1 ? a$1 : s, r$1);
	else {
		if ("http://www.w3.org/2000/svg" == i$1) l$1 = l$1.replace(/xlink(H|:h)/, "h").replace(/sName$/, "s");
		else if ("width" != l$1 && "height" != l$1 && "href" != l$1 && "list" != l$1 && "form" != l$1 && "tabIndex" != l$1 && "download" != l$1 && "rowSpan" != l$1 && "colSpan" != l$1 && "role" != l$1 && "popover" != l$1 && l$1 in n$1) try {
			n$1[l$1] = null == u$1 ? "" : u$1;
			break n;
		} catch (n$2) {}
		"function" == typeof u$1 || (null == u$1 || !1 === u$1 && "-" != l$1[4] ? n$1.removeAttribute(l$1) : n$1.setAttribute(l$1, "popover" == l$1 && 1 == u$1 ? "" : u$1));
	}
}
function F(n$1) {
	return function(u$1) {
		if (this.l) {
			var t$2 = this.l[u$1.type + n$1];
			if (null == u$1.t) u$1.t = c$1++;
			else if (u$1.t < t$2.u) return;
			return t$2(l.event ? l.event(u$1) : u$1);
		}
	};
}
function O(n$1, u$1, t$2, i$1, r$1, o$1, e$1, f$1, c$2, s$1) {
	var a$2, h$1, p$1, v$1, y$2, _$1, m$2, b, S$1, C$1, M$1, $$1, P$1, A$1, H, L$1, T$1, j$1 = u$1.type;
	if (null != u$1.constructor) return null;
	128 & t$2.__u && (c$2 = !!(32 & t$2.__u), o$1 = [f$1 = u$1.__e = t$2.__e]), (a$2 = l.__b) && a$2(u$1);
	n: if ("function" == typeof j$1) try {
		if (b = u$1.props, S$1 = "prototype" in j$1 && j$1.prototype.render, C$1 = (a$2 = j$1.contextType) && i$1[a$2.__c], M$1 = a$2 ? C$1 ? C$1.props.value : a$2.__ : i$1, t$2.__c ? m$2 = (h$1 = u$1.__c = t$2.__c).__ = h$1.__E : (S$1 ? u$1.__c = h$1 = new j$1(b, M$1) : (u$1.__c = h$1 = new x$1(b, M$1), h$1.constructor = j$1, h$1.render = E), C$1 && C$1.sub(h$1), h$1.state || (h$1.state = {}), h$1.__n = i$1, p$1 = h$1.__d = !0, h$1.__h = [], h$1._sb = []), S$1 && null == h$1.__s && (h$1.__s = h$1.state), S$1 && null != j$1.getDerivedStateFromProps && (h$1.__s == h$1.state && (h$1.__s = d({}, h$1.__s)), d(h$1.__s, j$1.getDerivedStateFromProps(b, h$1.__s))), v$1 = h$1.props, y$2 = h$1.state, h$1.__v = u$1, p$1) S$1 && null == j$1.getDerivedStateFromProps && null != h$1.componentWillMount && h$1.componentWillMount(), S$1 && null != h$1.componentDidMount && h$1.__h.push(h$1.componentDidMount);
		else {
			if (S$1 && null == j$1.getDerivedStateFromProps && b !== v$1 && null != h$1.componentWillReceiveProps && h$1.componentWillReceiveProps(b, M$1), u$1.__v == t$2.__v || !h$1.__e && null != h$1.shouldComponentUpdate && !1 === h$1.shouldComponentUpdate(b, h$1.__s, M$1)) {
				for (u$1.__v != t$2.__v && (h$1.props = b, h$1.state = h$1.__s, h$1.__d = !1), u$1.__e = t$2.__e, u$1.__k = t$2.__k, u$1.__k.some(function(n$2) {
					n$2 && (n$2.__ = u$1);
				}), $$1 = 0; $$1 < h$1._sb.length; $$1++) h$1.__h.push(h$1._sb[$$1]);
				h$1._sb = [], h$1.__h.length && e$1.push(h$1);
				break n;
			}
			null != h$1.componentWillUpdate && h$1.componentWillUpdate(b, h$1.__s, M$1), S$1 && null != h$1.componentDidUpdate && h$1.__h.push(function() {
				h$1.componentDidUpdate(v$1, y$2, _$1);
			});
		}
		if (h$1.context = M$1, h$1.props = b, h$1.__P = n$1, h$1.__e = !1, P$1 = l.__r, A$1 = 0, S$1) {
			for (h$1.state = h$1.__s, h$1.__d = !1, P$1 && P$1(u$1), a$2 = h$1.render(h$1.props, h$1.state, h$1.context), H = 0; H < h$1._sb.length; H++) h$1.__h.push(h$1._sb[H]);
			h$1._sb = [];
		} else do
			h$1.__d = !1, P$1 && P$1(u$1), a$2 = h$1.render(h$1.props, h$1.state, h$1.context), h$1.state = h$1.__s;
		while (h$1.__d && ++A$1 < 25);
		h$1.state = h$1.__s, null != h$1.getChildContext && (i$1 = d(d({}, i$1), h$1.getChildContext())), S$1 && !p$1 && null != h$1.getSnapshotBeforeUpdate && (_$1 = h$1.getSnapshotBeforeUpdate(v$1, y$2)), L$1 = a$2, null != a$2 && a$2.type === k && null == a$2.key && (L$1 = V(a$2.props.children)), f$1 = I(n$1, w(L$1) ? L$1 : [L$1], u$1, t$2, i$1, r$1, o$1, e$1, f$1, c$2, s$1), h$1.base = u$1.__e, u$1.__u &= -161, h$1.__h.length && e$1.push(h$1), m$2 && (h$1.__E = h$1.__ = null);
	} catch (n$2) {
		if (u$1.__v = null, c$2 || null != o$1) if (n$2.then) {
			for (u$1.__u |= c$2 ? 160 : 128; f$1 && 8 == f$1.nodeType && f$1.nextSibling;) f$1 = f$1.nextSibling;
			o$1[o$1.indexOf(f$1)] = null, u$1.__e = f$1;
		} else {
			for (T$1 = o$1.length; T$1--;) g(o$1[T$1]);
			z$1(u$1);
		}
		else u$1.__e = t$2.__e, u$1.__k = t$2.__k, n$2.then || z$1(u$1);
		l.__e(n$2, u$1, t$2);
	}
	else null == o$1 && u$1.__v == t$2.__v ? (u$1.__k = t$2.__k, u$1.__e = t$2.__e) : f$1 = u$1.__e = q(t$2.__e, u$1, t$2, i$1, r$1, o$1, e$1, c$2, s$1);
	return (a$2 = l.diffed) && a$2(u$1), 128 & u$1.__u ? void 0 : f$1;
}
function z$1(n$1) {
	n$1 && n$1.__c && (n$1.__c.__e = !0), n$1 && n$1.__k && n$1.__k.forEach(z$1);
}
function N(n$1, u$1, t$2) {
	for (var i$1 = 0; i$1 < t$2.length; i$1++) B(t$2[i$1], t$2[++i$1], t$2[++i$1]);
	l.__c && l.__c(u$1, n$1), n$1.some(function(u$2) {
		try {
			n$1 = u$2.__h, u$2.__h = [], n$1.some(function(n$2) {
				n$2.call(u$2);
			});
		} catch (n$2) {
			l.__e(n$2, u$2.__v);
		}
	});
}
function V(n$1) {
	return "object" != typeof n$1 || null == n$1 || n$1.__b && n$1.__b > 0 ? n$1 : w(n$1) ? n$1.map(V) : d({}, n$1);
}
function q(u$1, t$2, i$1, r$1, o$1, e$1, f$1, c$2, s$1) {
	var a$2, h$1, v$1, y$2, d$1, _$1, m$2, b = i$1.props || p, k$1 = t$2.props, x$2 = t$2.type;
	if ("svg" == x$2 ? o$1 = "http://www.w3.org/2000/svg" : "math" == x$2 ? o$1 = "http://www.w3.org/1998/Math/MathML" : o$1 || (o$1 = "http://www.w3.org/1999/xhtml"), null != e$1) {
		for (a$2 = 0; a$2 < e$1.length; a$2++) if ((d$1 = e$1[a$2]) && "setAttribute" in d$1 == !!x$2 && (x$2 ? d$1.localName == x$2 : 3 == d$1.nodeType)) {
			u$1 = d$1, e$1[a$2] = null;
			break;
		}
	}
	if (null == u$1) {
		if (null == x$2) return document.createTextNode(k$1);
		u$1 = document.createElementNS(o$1, x$2, k$1.is && k$1), c$2 && (l.__m && l.__m(t$2, e$1), c$2 = !1), e$1 = null;
	}
	if (null == x$2) b === k$1 || c$2 && u$1.data == k$1 || (u$1.data = k$1);
	else {
		if (e$1 = e$1 && n.call(u$1.childNodes), !c$2 && null != e$1) for (b = {}, a$2 = 0; a$2 < u$1.attributes.length; a$2++) b[(d$1 = u$1.attributes[a$2]).name] = d$1.value;
		for (a$2 in b) if (d$1 = b[a$2], "children" == a$2);
		else if ("dangerouslySetInnerHTML" == a$2) v$1 = d$1;
		else if (!(a$2 in k$1)) {
			if ("value" == a$2 && "defaultValue" in k$1 || "checked" == a$2 && "defaultChecked" in k$1) continue;
			j(u$1, a$2, null, d$1, o$1);
		}
		for (a$2 in k$1) d$1 = k$1[a$2], "children" == a$2 ? y$2 = d$1 : "dangerouslySetInnerHTML" == a$2 ? h$1 = d$1 : "value" == a$2 ? _$1 = d$1 : "checked" == a$2 ? m$2 = d$1 : c$2 && "function" != typeof d$1 || b[a$2] === d$1 || j(u$1, a$2, d$1, b[a$2], o$1);
		if (h$1) c$2 || v$1 && (h$1.__html == v$1.__html || h$1.__html == u$1.innerHTML) || (u$1.innerHTML = h$1.__html), t$2.__k = [];
		else if (v$1 && (u$1.innerHTML = ""), I("template" == t$2.type ? u$1.content : u$1, w(y$2) ? y$2 : [y$2], t$2, i$1, r$1, "foreignObject" == x$2 ? "http://www.w3.org/1999/xhtml" : o$1, e$1, f$1, e$1 ? e$1[0] : i$1.__k && S(i$1, 0), c$2, s$1), null != e$1) for (a$2 = e$1.length; a$2--;) g(e$1[a$2]);
		c$2 || (a$2 = "value", "progress" == x$2 && null == _$1 ? u$1.removeAttribute("value") : null != _$1 && (_$1 !== u$1[a$2] || "progress" == x$2 && !_$1 || "option" == x$2 && _$1 != b[a$2]) && j(u$1, a$2, _$1, b[a$2], o$1), a$2 = "checked", null != m$2 && m$2 != u$1[a$2] && j(u$1, a$2, m$2, b[a$2], o$1));
	}
	return u$1;
}
function B(n$1, u$1, t$2) {
	try {
		if ("function" == typeof n$1) {
			var i$1 = "function" == typeof n$1.__u;
			i$1 && n$1.__u(), i$1 && null == u$1 || (n$1.__u = n$1(u$1));
		} else n$1.current = u$1;
	} catch (n$2) {
		l.__e(n$2, t$2);
	}
}
function D(n$1, u$1, t$2) {
	var i$1, r$1;
	if (l.unmount && l.unmount(n$1), (i$1 = n$1.ref) && (i$1.current && i$1.current != n$1.__e || B(i$1, null, u$1)), null != (i$1 = n$1.__c)) {
		if (i$1.componentWillUnmount) try {
			i$1.componentWillUnmount();
		} catch (n$2) {
			l.__e(n$2, u$1);
		}
		i$1.base = i$1.__P = null;
	}
	if (i$1 = n$1.__k) for (r$1 = 0; r$1 < i$1.length; r$1++) i$1[r$1] && D(i$1[r$1], u$1, t$2 || "function" != typeof n$1.type);
	t$2 || g(n$1.__e), n$1.__c = n$1.__ = n$1.__e = void 0;
}
function E(n$1, l$1, u$1) {
	return this.constructor(n$1, u$1);
}
function G(u$1, t$2, i$1) {
	var r$1, o$1, e$1, f$1;
	t$2 == document && (t$2 = document.documentElement), l.__ && l.__(u$1, t$2), o$1 = (r$1 = "function" == typeof i$1) ? null : i$1 && i$1.__k || t$2.__k, e$1 = [], f$1 = [], O(t$2, u$1 = (!r$1 && i$1 || t$2).__k = _(k, null, [u$1]), o$1 || p, p, t$2.namespaceURI, !r$1 && i$1 ? [i$1] : o$1 ? null : t$2.firstChild ? n.call(t$2.childNodes) : null, e$1, !r$1 && i$1 ? i$1 : o$1 ? o$1.__e : t$2.firstChild, r$1, f$1), N(e$1, u$1, f$1);
}
function K(l$1, u$1, t$2) {
	var i$1, r$1, o$1, e$1, f$1 = d({}, l$1.props);
	for (o$1 in l$1.type && l$1.type.defaultProps && (e$1 = l$1.type.defaultProps), u$1) "key" == o$1 ? i$1 = u$1[o$1] : "ref" == o$1 ? r$1 = u$1[o$1] : f$1[o$1] = void 0 === u$1[o$1] && null != e$1 ? e$1[o$1] : u$1[o$1];
	return arguments.length > 2 && (f$1.children = arguments.length > 3 ? n.call(arguments, 2) : t$2), m$1(l$1.type, f$1, i$1 || l$1.key, r$1 || l$1.ref, null);
}
n = v.slice, l = { __e: function(n$1, l$1, u$1, t$2) {
	for (var i$1, r$1, o$1; l$1 = l$1.__;) if ((i$1 = l$1.__c) && !i$1.__) try {
		if ((r$1 = i$1.constructor) && null != r$1.getDerivedStateFromError && (i$1.setState(r$1.getDerivedStateFromError(n$1)), o$1 = i$1.__d), null != i$1.componentDidCatch && (i$1.componentDidCatch(n$1, t$2 || {}), o$1 = i$1.__d), o$1) return i$1.__E = i$1;
	} catch (l$2) {
		n$1 = l$2;
	}
	throw n$1;
} }, u = 0, t$1 = function(n$1) {
	return null != n$1 && null == n$1.constructor;
}, x$1.prototype.setState = function(n$1, l$1) {
	var u$1 = null != this.__s && this.__s != this.state ? this.__s : this.__s = d({}, this.state);
	"function" == typeof n$1 && (n$1 = n$1(d({}, u$1), this.props)), n$1 && d(u$1, n$1), null != n$1 && this.__v && (l$1 && this._sb.push(l$1), M(this));
}, x$1.prototype.forceUpdate = function(n$1) {
	this.__v && (this.__e = !0, n$1 && this.__h.push(n$1), M(this));
}, x$1.prototype.render = k, i = [], o = "function" == typeof Promise ? Promise.prototype.then.bind(Promise.resolve()) : setTimeout, e = function(n$1, l$1) {
	return n$1.__v.__b - l$1.__v.__b;
}, $.__r = 0, f = /(PointerCapture)$|Capture$/i, c$1 = 0, s = F(!1), a$1 = F(!0), h = 0;

//#endregion
//#region node_modules/float-tooltip/dist/float-tooltip.mjs
function _arrayLikeToArray$2(r$1, a$2) {
	(null == a$2 || a$2 > r$1.length) && (a$2 = r$1.length);
	for (var e$1 = 0, n$1 = Array(a$2); e$1 < a$2; e$1++) n$1[e$1] = r$1[e$1];
	return n$1;
}
function _arrayWithHoles$2(r$1) {
	if (Array.isArray(r$1)) return r$1;
}
function _defineProperty$1(e$1, r$1, t$2) {
	return (r$1 = _toPropertyKey$2(r$1)) in e$1 ? Object.defineProperty(e$1, r$1, {
		value: t$2,
		enumerable: true,
		configurable: true,
		writable: true
	}) : e$1[r$1] = t$2, e$1;
}
function _iterableToArrayLimit$2(r$1, l$1) {
	var t$2 = null == r$1 ? null : "undefined" != typeof Symbol && r$1[Symbol.iterator] || r$1["@@iterator"];
	if (null != t$2) {
		var e$1, n$1, i$1, u$1, a$2 = [], f$1 = true, o$1 = false;
		try {
			if (i$1 = (t$2 = t$2.call(r$1)).next, 0 === l$1);
			else for (; !(f$1 = (e$1 = i$1.call(t$2)).done) && (a$2.push(e$1.value), a$2.length !== l$1); f$1 = !0);
		} catch (r$2) {
			o$1 = true, n$1 = r$2;
		} finally {
			try {
				if (!f$1 && null != t$2.return && (u$1 = t$2.return(), Object(u$1) !== u$1)) return;
			} finally {
				if (o$1) throw n$1;
			}
		}
		return a$2;
	}
}
function _nonIterableRest$2() {
	throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function ownKeys$1(e$1, r$1) {
	var t$2 = Object.keys(e$1);
	if (Object.getOwnPropertySymbols) {
		var o$1 = Object.getOwnPropertySymbols(e$1);
		r$1 && (o$1 = o$1.filter(function(r$2) {
			return Object.getOwnPropertyDescriptor(e$1, r$2).enumerable;
		})), t$2.push.apply(t$2, o$1);
	}
	return t$2;
}
function _objectSpread2$1(e$1) {
	for (var r$1 = 1; r$1 < arguments.length; r$1++) {
		var t$2 = null != arguments[r$1] ? arguments[r$1] : {};
		r$1 % 2 ? ownKeys$1(Object(t$2), true).forEach(function(r$2) {
			_defineProperty$1(e$1, r$2, t$2[r$2]);
		}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e$1, Object.getOwnPropertyDescriptors(t$2)) : ownKeys$1(Object(t$2)).forEach(function(r$2) {
			Object.defineProperty(e$1, r$2, Object.getOwnPropertyDescriptor(t$2, r$2));
		});
	}
	return e$1;
}
function _slicedToArray$2(r$1, e$1) {
	return _arrayWithHoles$2(r$1) || _iterableToArrayLimit$2(r$1, e$1) || _unsupportedIterableToArray$2(r$1, e$1) || _nonIterableRest$2();
}
function _toPrimitive$2(t$2, r$1) {
	if ("object" != typeof t$2 || !t$2) return t$2;
	var e$1 = t$2[Symbol.toPrimitive];
	if (void 0 !== e$1) {
		var i$1 = e$1.call(t$2, r$1);
		if ("object" != typeof i$1) return i$1;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return ("string" === r$1 ? String : Number)(t$2);
}
function _toPropertyKey$2(t$2) {
	var i$1 = _toPrimitive$2(t$2, "string");
	return "symbol" == typeof i$1 ? i$1 : i$1 + "";
}
function _typeof$1(o$1) {
	"@babel/helpers - typeof";
	return _typeof$1 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o$2) {
		return typeof o$2;
	} : function(o$2) {
		return o$2 && "function" == typeof Symbol && o$2.constructor === Symbol && o$2 !== Symbol.prototype ? "symbol" : typeof o$2;
	}, _typeof$1(o$1);
}
function _unsupportedIterableToArray$2(r$1, a$2) {
	if (r$1) {
		if ("string" == typeof r$1) return _arrayLikeToArray$2(r$1, a$2);
		var t$2 = {}.toString.call(r$1).slice(8, -1);
		return "Object" === t$2 && r$1.constructor && (t$2 = r$1.constructor.name), "Map" === t$2 || "Set" === t$2 ? Array.from(r$1) : "Arguments" === t$2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t$2) ? _arrayLikeToArray$2(r$1, a$2) : void 0;
	}
}
var _reactElement2VNode = function reactElement2VNode(el) {
	if (!(_typeof$1(el) === "object")) return el;
	var res = K(el);
	if (res.props) {
		var _res$props;
		res.props = _objectSpread2$1({}, res.props);
		if (res !== null && res !== void 0 && (_res$props = res.props) !== null && _res$props !== void 0 && _res$props.children) res.props.children = Array.isArray(res.props.children) ? res.props.children.map(_reactElement2VNode) : _reactElement2VNode(res.props.children);
	}
	return res;
};
var isReactRenderable = function isReactRenderable$1(o$1) {
	return t$1(K(o$1));
};
var render = function render$1(jsx, domEl) {
	delete domEl.__k;
	G(_reactElement2VNode(jsx), domEl);
};
function styleInject$1(css, ref) {
	if (ref === void 0) ref = {};
	var insertAt = ref.insertAt;
	if (typeof document === "undefined") return;
	var head = document.head || document.getElementsByTagName("head")[0];
	var style = document.createElement("style");
	style.type = "text/css";
	if (insertAt === "top") if (head.firstChild) head.insertBefore(style, head.firstChild);
	else head.appendChild(style);
	else head.appendChild(style);
	if (style.styleSheet) style.styleSheet.cssText = css;
	else style.appendChild(document.createTextNode(css));
}
styleInject$1(".float-tooltip-kap {\n  position: absolute;\n  width: max-content; /* prevent shrinking near right edge */\n  max-width: max(50%, 150px);\n  padding: 3px 5px;\n  border-radius: 3px;\n  font: 12px sans-serif;\n  color: #eee;\n  background: rgba(0,0,0,0.6);\n  pointer-events: none;\n}\n");
var index$3 = index$1({
	props: {
		content: { "default": false },
		offsetX: { triggerUpdate: false },
		offsetY: { triggerUpdate: false }
	},
	init: function init$1(domNode, state) {
		var _ref$style = (arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}).style, style = _ref$style === void 0 ? {} : _ref$style;
		var el = select_default(!!domNode && _typeof$1(domNode) === "object" && !!domNode.node && typeof domNode.node === "function" ? domNode.node() : domNode);
		el.style("position") === "static" && el.style("position", "relative");
		state.tooltipEl = el.append("div").attr("class", "float-tooltip-kap");
		Object.entries(style).forEach(function(_ref2) {
			var _ref3 = _slicedToArray$2(_ref2, 2), k$1 = _ref3[0], v$1 = _ref3[1];
			return state.tooltipEl.style(k$1, v$1);
		});
		state.tooltipEl.style("left", "-10000px").style("display", "none");
		var evSuffix = "tooltip-".concat(Math.round(Math.random() * 0xe8d4a51000));
		state.mouseInside = false;
		el.on("mousemove.".concat(evSuffix), function(ev) {
			state.mouseInside = true;
			var mousePos = pointer_default(ev);
			var domNode$1 = el.node();
			var canvasWidth = domNode$1.offsetWidth;
			var canvasHeight = domNode$1.offsetHeight;
			var translate = [state.offsetX === null || state.offsetX === void 0 ? "-".concat(mousePos[0] / canvasWidth * 100, "%") : typeof state.offsetX === "number" ? "calc(-50% + ".concat(state.offsetX, "px)") : state.offsetX, state.offsetY === null || state.offsetY === void 0 ? canvasHeight > 130 && canvasHeight - mousePos[1] < 100 ? "calc(-100% - 6px)" : "21px" : typeof state.offsetY === "number" ? state.offsetY < 0 ? "calc(-100% - ".concat(Math.abs(state.offsetY), "px)") : "".concat(state.offsetY, "px") : state.offsetY];
			state.tooltipEl.style("left", mousePos[0] + "px").style("top", mousePos[1] + "px").style("transform", "translate(".concat(translate.join(","), ")"));
			state.content && state.tooltipEl.style("display", "inline");
		});
		el.on("mouseover.".concat(evSuffix), function() {
			state.mouseInside = true;
			state.content && state.tooltipEl.style("display", "inline");
		});
		el.on("mouseout.".concat(evSuffix), function() {
			state.mouseInside = false;
			state.tooltipEl.style("display", "none");
		});
	},
	update: function update$1(state) {
		state.tooltipEl.style("display", !!state.content && state.mouseInside ? "inline" : "none");
		if (!state.content) state.tooltipEl.text("");
		else if (state.content instanceof HTMLElement) {
			state.tooltipEl.text("");
			state.tooltipEl.append(function() {
				return state.content;
			});
		} else if (typeof state.content === "string") state.tooltipEl.html(state.content);
		else if (isReactRenderable(state.content)) {
			state.tooltipEl.text("");
			render(state.content, state.tooltipEl.node());
		} else {
			state.tooltipEl.style("display", "none");
			console.warn("Tooltip content is invalid, skipping.", state.content, state.content.toString());
		}
	}
});

//#endregion
//#region node_modules/d3-force-3d/src/center.js
function center_default(x$2, y$2, z$2) {
	var nodes, strength = 1;
	if (x$2 == null) x$2 = 0;
	if (y$2 == null) y$2 = 0;
	if (z$2 == null) z$2 = 0;
	function force() {
		var i$1, n$1 = nodes.length, node, sx = 0, sy = 0, sz = 0;
		for (i$1 = 0; i$1 < n$1; ++i$1) node = nodes[i$1], sx += node.x || 0, sy += node.y || 0, sz += node.z || 0;
		for (sx = (sx / n$1 - x$2) * strength, sy = (sy / n$1 - y$2) * strength, sz = (sz / n$1 - z$2) * strength, i$1 = 0; i$1 < n$1; ++i$1) {
			node = nodes[i$1];
			if (sx) node.x -= sx;
			if (sy) node.y -= sy;
			if (sz) node.z -= sz;
		}
	}
	force.initialize = function(_$1) {
		nodes = _$1;
	};
	force.x = function(_$1) {
		return arguments.length ? (x$2 = +_$1, force) : x$2;
	};
	force.y = function(_$1) {
		return arguments.length ? (y$2 = +_$1, force) : y$2;
	};
	force.z = function(_$1) {
		return arguments.length ? (z$2 = +_$1, force) : z$2;
	};
	force.strength = function(_$1) {
		return arguments.length ? (strength = +_$1, force) : strength;
	};
	return force;
}

//#endregion
//#region node_modules/d3-binarytree/src/add.js
function add_default$2(d$1) {
	const x$2 = +this._x.call(null, d$1);
	return add$2(this.cover(x$2), x$2, d$1);
}
function add$2(tree, x$2, d$1) {
	if (isNaN(x$2)) return tree;
	var parent, node = tree._root, leaf = { data: d$1 }, x0 = tree._x0, x1 = tree._x1, xm, xp, right, i$1, j$1;
	if (!node) return tree._root = leaf, tree;
	while (node.length) {
		if (right = x$2 >= (xm = (x0 + x1) / 2)) x0 = xm;
		else x1 = xm;
		if (parent = node, !(node = node[i$1 = +right])) return parent[i$1] = leaf, tree;
	}
	xp = +tree._x.call(null, node.data);
	if (x$2 === xp) return leaf.next = node, parent ? parent[i$1] = leaf : tree._root = leaf, tree;
	do {
		parent = parent ? parent[i$1] = new Array(2) : tree._root = new Array(2);
		if (right = x$2 >= (xm = (x0 + x1) / 2)) x0 = xm;
		else x1 = xm;
	} while ((i$1 = +right) === (j$1 = +(xp >= xm)));
	return parent[j$1] = node, parent[i$1] = leaf, tree;
}
function addAll$2(data) {
	if (!Array.isArray(data)) data = Array.from(data);
	const n$1 = data.length;
	const xz = new Float64Array(n$1);
	let x0 = Infinity, x1 = -Infinity;
	for (let i$1 = 0, x$2; i$1 < n$1; ++i$1) {
		if (isNaN(x$2 = +this._x.call(null, data[i$1]))) continue;
		xz[i$1] = x$2;
		if (x$2 < x0) x0 = x$2;
		if (x$2 > x1) x1 = x$2;
	}
	if (x0 > x1) return this;
	this.cover(x0).cover(x1);
	for (let i$1 = 0; i$1 < n$1; ++i$1) add$2(this, xz[i$1], data[i$1]);
	return this;
}

//#endregion
//#region node_modules/d3-binarytree/src/cover.js
function cover_default$2(x$2) {
	if (isNaN(x$2 = +x$2)) return this;
	var x0 = this._x0, x1 = this._x1;
	if (isNaN(x0)) x1 = (x0 = Math.floor(x$2)) + 1;
	else {
		var z$2 = x1 - x0 || 1, node = this._root, parent, i$1;
		while (x0 > x$2 || x$2 >= x1) {
			i$1 = +(x$2 < x0);
			parent = new Array(2), parent[i$1] = node, node = parent, z$2 *= 2;
			switch (i$1) {
				case 0:
					x1 = x0 + z$2;
					break;
				case 1:
					x0 = x1 - z$2;
					break;
			}
		}
		if (this._root && this._root.length) this._root = node;
	}
	this._x0 = x0;
	this._x1 = x1;
	return this;
}

//#endregion
//#region node_modules/d3-binarytree/src/data.js
function data_default$2() {
	var data = [];
	this.visit(function(node) {
		if (!node.length) do
			data.push(node.data);
		while (node = node.next);
	});
	return data;
}

//#endregion
//#region node_modules/d3-binarytree/src/extent.js
function extent_default$2(_$1) {
	return arguments.length ? this.cover(+_$1[0][0]).cover(+_$1[1][0]) : isNaN(this._x0) ? void 0 : [[this._x0], [this._x1]];
}

//#endregion
//#region node_modules/d3-binarytree/src/half.js
function half_default(node, x0, x1) {
	this.node = node;
	this.x0 = x0;
	this.x1 = x1;
}

//#endregion
//#region node_modules/d3-binarytree/src/find.js
function find_default$2(x$2, radius) {
	var data, x0 = this._x0, x1, x2, x3 = this._x1, halves = [], node = this._root, q$1, i$1;
	if (node) halves.push(new half_default(node, x0, x3));
	if (radius == null) radius = Infinity;
	else {
		x0 = x$2 - radius;
		x3 = x$2 + radius;
	}
	while (q$1 = halves.pop()) {
		if (!(node = q$1.node) || (x1 = q$1.x0) > x3 || (x2 = q$1.x1) < x0) continue;
		if (node.length) {
			var xm = (x1 + x2) / 2;
			halves.push(new half_default(node[1], xm, x2), new half_default(node[0], x1, xm));
			if (i$1 = +(x$2 >= xm)) {
				q$1 = halves[halves.length - 1];
				halves[halves.length - 1] = halves[halves.length - 1 - i$1];
				halves[halves.length - 1 - i$1] = q$1;
			}
		} else {
			var d$1 = Math.abs(x$2 - +this._x.call(null, node.data));
			if (d$1 < radius) {
				radius = d$1;
				x0 = x$2 - d$1;
				x3 = x$2 + d$1;
				data = node.data;
			}
		}
	}
	return data;
}

//#endregion
//#region node_modules/d3-binarytree/src/remove.js
function remove_default$2(d$1) {
	if (isNaN(x$2 = +this._x.call(null, d$1))) return this;
	var parent, node = this._root, retainer, previous, next, x0 = this._x0, x1 = this._x1, x$2, xm, right, i$1, j$1;
	if (!node) return this;
	if (node.length) while (true) {
		if (right = x$2 >= (xm = (x0 + x1) / 2)) x0 = xm;
		else x1 = xm;
		if (!(parent = node, node = node[i$1 = +right])) return this;
		if (!node.length) break;
		if (parent[i$1 + 1 & 1]) retainer = parent, j$1 = i$1;
	}
	while (node.data !== d$1) if (!(previous = node, node = node.next)) return this;
	if (next = node.next) delete node.next;
	if (previous) return next ? previous.next = next : delete previous.next, this;
	if (!parent) return this._root = next, this;
	next ? parent[i$1] = next : delete parent[i$1];
	if ((node = parent[0] || parent[1]) && node === (parent[1] || parent[0]) && !node.length) if (retainer) retainer[j$1] = node;
	else this._root = node;
	return this;
}
function removeAll$2(data) {
	for (var i$1 = 0, n$1 = data.length; i$1 < n$1; ++i$1) this.remove(data[i$1]);
	return this;
}

//#endregion
//#region node_modules/d3-binarytree/src/root.js
function root_default$2() {
	return this._root;
}

//#endregion
//#region node_modules/d3-binarytree/src/size.js
function size_default$2() {
	var size = 0;
	this.visit(function(node) {
		if (!node.length) do
			++size;
		while (node = node.next);
	});
	return size;
}

//#endregion
//#region node_modules/d3-binarytree/src/visit.js
function visit_default$2(callback) {
	var halves = [], q$1, node = this._root, child, x0, x1;
	if (node) halves.push(new half_default(node, this._x0, this._x1));
	while (q$1 = halves.pop()) if (!callback(node = q$1.node, x0 = q$1.x0, x1 = q$1.x1) && node.length) {
		var xm = (x0 + x1) / 2;
		if (child = node[1]) halves.push(new half_default(child, xm, x1));
		if (child = node[0]) halves.push(new half_default(child, x0, xm));
	}
	return this;
}

//#endregion
//#region node_modules/d3-binarytree/src/visitAfter.js
function visitAfter_default$2(callback) {
	var halves = [], next = [], q$1;
	if (this._root) halves.push(new half_default(this._root, this._x0, this._x1));
	while (q$1 = halves.pop()) {
		var node = q$1.node;
		if (node.length) {
			var child, x0 = q$1.x0, x1 = q$1.x1, xm = (x0 + x1) / 2;
			if (child = node[0]) halves.push(new half_default(child, x0, xm));
			if (child = node[1]) halves.push(new half_default(child, xm, x1));
		}
		next.push(q$1);
	}
	while (q$1 = next.pop()) callback(q$1.node, q$1.x0, q$1.x1);
	return this;
}

//#endregion
//#region node_modules/d3-binarytree/src/x.js
function defaultX$2(d$1) {
	return d$1[0];
}
function x_default$2(_$1) {
	return arguments.length ? (this._x = _$1, this) : this._x;
}

//#endregion
//#region node_modules/d3-binarytree/src/binarytree.js
function binarytree(nodes, x$2) {
	var tree = new Binarytree(x$2 == null ? defaultX$2 : x$2, NaN, NaN);
	return nodes == null ? tree : tree.addAll(nodes);
}
function Binarytree(x$2, x0, x1) {
	this._x = x$2;
	this._x0 = x0;
	this._x1 = x1;
	this._root = void 0;
}
function leaf_copy$2(leaf) {
	var copy = { data: leaf.data }, next = copy;
	while (leaf = leaf.next) next = next.next = { data: leaf.data };
	return copy;
}
var treeProto$2 = binarytree.prototype = Binarytree.prototype;
treeProto$2.copy = function() {
	var copy = new Binarytree(this._x, this._x0, this._x1), node = this._root, nodes, child;
	if (!node) return copy;
	if (!node.length) return copy._root = leaf_copy$2(node), copy;
	nodes = [{
		source: node,
		target: copy._root = new Array(2)
	}];
	while (node = nodes.pop()) for (var i$1 = 0; i$1 < 2; ++i$1) if (child = node.source[i$1]) if (child.length) nodes.push({
		source: child,
		target: node.target[i$1] = new Array(2)
	});
	else node.target[i$1] = leaf_copy$2(child);
	return copy;
};
treeProto$2.add = add_default$2;
treeProto$2.addAll = addAll$2;
treeProto$2.cover = cover_default$2;
treeProto$2.data = data_default$2;
treeProto$2.extent = extent_default$2;
treeProto$2.find = find_default$2;
treeProto$2.remove = remove_default$2;
treeProto$2.removeAll = removeAll$2;
treeProto$2.root = root_default$2;
treeProto$2.size = size_default$2;
treeProto$2.visit = visit_default$2;
treeProto$2.visitAfter = visitAfter_default$2;
treeProto$2.x = x_default$2;

//#endregion
//#region node_modules/d3-quadtree/src/add.js
function add_default$1(d$1) {
	const x$2 = +this._x.call(null, d$1), y$2 = +this._y.call(null, d$1);
	return add$1(this.cover(x$2, y$2), x$2, y$2, d$1);
}
function add$1(tree, x$2, y$2, d$1) {
	if (isNaN(x$2) || isNaN(y$2)) return tree;
	var parent, node = tree._root, leaf = { data: d$1 }, x0 = tree._x0, y0 = tree._y0, x1 = tree._x1, y1 = tree._y1, xm, ym, xp, yp, right, bottom, i$1, j$1;
	if (!node) return tree._root = leaf, tree;
	while (node.length) {
		if (right = x$2 >= (xm = (x0 + x1) / 2)) x0 = xm;
		else x1 = xm;
		if (bottom = y$2 >= (ym = (y0 + y1) / 2)) y0 = ym;
		else y1 = ym;
		if (parent = node, !(node = node[i$1 = bottom << 1 | right])) return parent[i$1] = leaf, tree;
	}
	xp = +tree._x.call(null, node.data);
	yp = +tree._y.call(null, node.data);
	if (x$2 === xp && y$2 === yp) return leaf.next = node, parent ? parent[i$1] = leaf : tree._root = leaf, tree;
	do {
		parent = parent ? parent[i$1] = new Array(4) : tree._root = new Array(4);
		if (right = x$2 >= (xm = (x0 + x1) / 2)) x0 = xm;
		else x1 = xm;
		if (bottom = y$2 >= (ym = (y0 + y1) / 2)) y0 = ym;
		else y1 = ym;
	} while ((i$1 = bottom << 1 | right) === (j$1 = (yp >= ym) << 1 | xp >= xm));
	return parent[j$1] = node, parent[i$1] = leaf, tree;
}
function addAll$1(data) {
	var d$1, i$1, n$1 = data.length, x$2, y$2, xz = new Array(n$1), yz = new Array(n$1), x0 = Infinity, y0 = Infinity, x1 = -Infinity, y1 = -Infinity;
	for (i$1 = 0; i$1 < n$1; ++i$1) {
		if (isNaN(x$2 = +this._x.call(null, d$1 = data[i$1])) || isNaN(y$2 = +this._y.call(null, d$1))) continue;
		xz[i$1] = x$2;
		yz[i$1] = y$2;
		if (x$2 < x0) x0 = x$2;
		if (x$2 > x1) x1 = x$2;
		if (y$2 < y0) y0 = y$2;
		if (y$2 > y1) y1 = y$2;
	}
	if (x0 > x1 || y0 > y1) return this;
	this.cover(x0, y0).cover(x1, y1);
	for (i$1 = 0; i$1 < n$1; ++i$1) add$1(this, xz[i$1], yz[i$1], data[i$1]);
	return this;
}

//#endregion
//#region node_modules/d3-quadtree/src/cover.js
function cover_default$1(x$2, y$2) {
	if (isNaN(x$2 = +x$2) || isNaN(y$2 = +y$2)) return this;
	var x0 = this._x0, y0 = this._y0, x1 = this._x1, y1 = this._y1;
	if (isNaN(x0)) {
		x1 = (x0 = Math.floor(x$2)) + 1;
		y1 = (y0 = Math.floor(y$2)) + 1;
	} else {
		var z$2 = x1 - x0 || 1, node = this._root, parent, i$1;
		while (x0 > x$2 || x$2 >= x1 || y0 > y$2 || y$2 >= y1) {
			i$1 = (y$2 < y0) << 1 | x$2 < x0;
			parent = new Array(4), parent[i$1] = node, node = parent, z$2 *= 2;
			switch (i$1) {
				case 0:
					x1 = x0 + z$2, y1 = y0 + z$2;
					break;
				case 1:
					x0 = x1 - z$2, y1 = y0 + z$2;
					break;
				case 2:
					x1 = x0 + z$2, y0 = y1 - z$2;
					break;
				case 3:
					x0 = x1 - z$2, y0 = y1 - z$2;
					break;
			}
		}
		if (this._root && this._root.length) this._root = node;
	}
	this._x0 = x0;
	this._y0 = y0;
	this._x1 = x1;
	this._y1 = y1;
	return this;
}

//#endregion
//#region node_modules/d3-quadtree/src/data.js
function data_default$1() {
	var data = [];
	this.visit(function(node) {
		if (!node.length) do
			data.push(node.data);
		while (node = node.next);
	});
	return data;
}

//#endregion
//#region node_modules/d3-quadtree/src/extent.js
function extent_default$1(_$1) {
	return arguments.length ? this.cover(+_$1[0][0], +_$1[0][1]).cover(+_$1[1][0], +_$1[1][1]) : isNaN(this._x0) ? void 0 : [[this._x0, this._y0], [this._x1, this._y1]];
}

//#endregion
//#region node_modules/d3-quadtree/src/quad.js
function quad_default(node, x0, y0, x1, y1) {
	this.node = node;
	this.x0 = x0;
	this.y0 = y0;
	this.x1 = x1;
	this.y1 = y1;
}

//#endregion
//#region node_modules/d3-quadtree/src/find.js
function find_default$1(x$2, y$2, radius) {
	var data, x0 = this._x0, y0 = this._y0, x1, y1, x2, y2, x3 = this._x1, y3 = this._y1, quads = [], node = this._root, q$1, i$1;
	if (node) quads.push(new quad_default(node, x0, y0, x3, y3));
	if (radius == null) radius = Infinity;
	else {
		x0 = x$2 - radius, y0 = y$2 - radius;
		x3 = x$2 + radius, y3 = y$2 + radius;
		radius *= radius;
	}
	while (q$1 = quads.pop()) {
		if (!(node = q$1.node) || (x1 = q$1.x0) > x3 || (y1 = q$1.y0) > y3 || (x2 = q$1.x1) < x0 || (y2 = q$1.y1) < y0) continue;
		if (node.length) {
			var xm = (x1 + x2) / 2, ym = (y1 + y2) / 2;
			quads.push(new quad_default(node[3], xm, ym, x2, y2), new quad_default(node[2], x1, ym, xm, y2), new quad_default(node[1], xm, y1, x2, ym), new quad_default(node[0], x1, y1, xm, ym));
			if (i$1 = (y$2 >= ym) << 1 | x$2 >= xm) {
				q$1 = quads[quads.length - 1];
				quads[quads.length - 1] = quads[quads.length - 1 - i$1];
				quads[quads.length - 1 - i$1] = q$1;
			}
		} else {
			var dx = x$2 - +this._x.call(null, node.data), dy = y$2 - +this._y.call(null, node.data), d2 = dx * dx + dy * dy;
			if (d2 < radius) {
				var d$1 = Math.sqrt(radius = d2);
				x0 = x$2 - d$1, y0 = y$2 - d$1;
				x3 = x$2 + d$1, y3 = y$2 + d$1;
				data = node.data;
			}
		}
	}
	return data;
}

//#endregion
//#region node_modules/d3-quadtree/src/remove.js
function remove_default$1(d$1) {
	if (isNaN(x$2 = +this._x.call(null, d$1)) || isNaN(y$2 = +this._y.call(null, d$1))) return this;
	var parent, node = this._root, retainer, previous, next, x0 = this._x0, y0 = this._y0, x1 = this._x1, y1 = this._y1, x$2, y$2, xm, ym, right, bottom, i$1, j$1;
	if (!node) return this;
	if (node.length) while (true) {
		if (right = x$2 >= (xm = (x0 + x1) / 2)) x0 = xm;
		else x1 = xm;
		if (bottom = y$2 >= (ym = (y0 + y1) / 2)) y0 = ym;
		else y1 = ym;
		if (!(parent = node, node = node[i$1 = bottom << 1 | right])) return this;
		if (!node.length) break;
		if (parent[i$1 + 1 & 3] || parent[i$1 + 2 & 3] || parent[i$1 + 3 & 3]) retainer = parent, j$1 = i$1;
	}
	while (node.data !== d$1) if (!(previous = node, node = node.next)) return this;
	if (next = node.next) delete node.next;
	if (previous) return next ? previous.next = next : delete previous.next, this;
	if (!parent) return this._root = next, this;
	next ? parent[i$1] = next : delete parent[i$1];
	if ((node = parent[0] || parent[1] || parent[2] || parent[3]) && node === (parent[3] || parent[2] || parent[1] || parent[0]) && !node.length) if (retainer) retainer[j$1] = node;
	else this._root = node;
	return this;
}
function removeAll$1(data) {
	for (var i$1 = 0, n$1 = data.length; i$1 < n$1; ++i$1) this.remove(data[i$1]);
	return this;
}

//#endregion
//#region node_modules/d3-quadtree/src/root.js
function root_default$1() {
	return this._root;
}

//#endregion
//#region node_modules/d3-quadtree/src/size.js
function size_default$1() {
	var size = 0;
	this.visit(function(node) {
		if (!node.length) do
			++size;
		while (node = node.next);
	});
	return size;
}

//#endregion
//#region node_modules/d3-quadtree/src/visit.js
function visit_default$1(callback) {
	var quads = [], q$1, node = this._root, child, x0, y0, x1, y1;
	if (node) quads.push(new quad_default(node, this._x0, this._y0, this._x1, this._y1));
	while (q$1 = quads.pop()) if (!callback(node = q$1.node, x0 = q$1.x0, y0 = q$1.y0, x1 = q$1.x1, y1 = q$1.y1) && node.length) {
		var xm = (x0 + x1) / 2, ym = (y0 + y1) / 2;
		if (child = node[3]) quads.push(new quad_default(child, xm, ym, x1, y1));
		if (child = node[2]) quads.push(new quad_default(child, x0, ym, xm, y1));
		if (child = node[1]) quads.push(new quad_default(child, xm, y0, x1, ym));
		if (child = node[0]) quads.push(new quad_default(child, x0, y0, xm, ym));
	}
	return this;
}

//#endregion
//#region node_modules/d3-quadtree/src/visitAfter.js
function visitAfter_default$1(callback) {
	var quads = [], next = [], q$1;
	if (this._root) quads.push(new quad_default(this._root, this._x0, this._y0, this._x1, this._y1));
	while (q$1 = quads.pop()) {
		var node = q$1.node;
		if (node.length) {
			var child, x0 = q$1.x0, y0 = q$1.y0, x1 = q$1.x1, y1 = q$1.y1, xm = (x0 + x1) / 2, ym = (y0 + y1) / 2;
			if (child = node[0]) quads.push(new quad_default(child, x0, y0, xm, ym));
			if (child = node[1]) quads.push(new quad_default(child, xm, y0, x1, ym));
			if (child = node[2]) quads.push(new quad_default(child, x0, ym, xm, y1));
			if (child = node[3]) quads.push(new quad_default(child, xm, ym, x1, y1));
		}
		next.push(q$1);
	}
	while (q$1 = next.pop()) callback(q$1.node, q$1.x0, q$1.y0, q$1.x1, q$1.y1);
	return this;
}

//#endregion
//#region node_modules/d3-quadtree/src/x.js
function defaultX$1(d$1) {
	return d$1[0];
}
function x_default$1(_$1) {
	return arguments.length ? (this._x = _$1, this) : this._x;
}

//#endregion
//#region node_modules/d3-quadtree/src/y.js
function defaultY$1(d$1) {
	return d$1[1];
}
function y_default$1(_$1) {
	return arguments.length ? (this._y = _$1, this) : this._y;
}

//#endregion
//#region node_modules/d3-quadtree/src/quadtree.js
function quadtree(nodes, x$2, y$2) {
	var tree = new Quadtree(x$2 == null ? defaultX$1 : x$2, y$2 == null ? defaultY$1 : y$2, NaN, NaN, NaN, NaN);
	return nodes == null ? tree : tree.addAll(nodes);
}
function Quadtree(x$2, y$2, x0, y0, x1, y1) {
	this._x = x$2;
	this._y = y$2;
	this._x0 = x0;
	this._y0 = y0;
	this._x1 = x1;
	this._y1 = y1;
	this._root = void 0;
}
function leaf_copy$1(leaf) {
	var copy = { data: leaf.data }, next = copy;
	while (leaf = leaf.next) next = next.next = { data: leaf.data };
	return copy;
}
var treeProto$1 = quadtree.prototype = Quadtree.prototype;
treeProto$1.copy = function() {
	var copy = new Quadtree(this._x, this._y, this._x0, this._y0, this._x1, this._y1), node = this._root, nodes, child;
	if (!node) return copy;
	if (!node.length) return copy._root = leaf_copy$1(node), copy;
	nodes = [{
		source: node,
		target: copy._root = new Array(4)
	}];
	while (node = nodes.pop()) for (var i$1 = 0; i$1 < 4; ++i$1) if (child = node.source[i$1]) if (child.length) nodes.push({
		source: child,
		target: node.target[i$1] = new Array(4)
	});
	else node.target[i$1] = leaf_copy$1(child);
	return copy;
};
treeProto$1.add = add_default$1;
treeProto$1.addAll = addAll$1;
treeProto$1.cover = cover_default$1;
treeProto$1.data = data_default$1;
treeProto$1.extent = extent_default$1;
treeProto$1.find = find_default$1;
treeProto$1.remove = remove_default$1;
treeProto$1.removeAll = removeAll$1;
treeProto$1.root = root_default$1;
treeProto$1.size = size_default$1;
treeProto$1.visit = visit_default$1;
treeProto$1.visitAfter = visitAfter_default$1;
treeProto$1.x = x_default$1;
treeProto$1.y = y_default$1;

//#endregion
//#region node_modules/d3-octree/src/add.js
function add_default(d$1) {
	const x$2 = +this._x.call(null, d$1), y$2 = +this._y.call(null, d$1), z$2 = +this._z.call(null, d$1);
	return add(this.cover(x$2, y$2, z$2), x$2, y$2, z$2, d$1);
}
function add(tree, x$2, y$2, z$2, d$1) {
	if (isNaN(x$2) || isNaN(y$2) || isNaN(z$2)) return tree;
	var parent, node = tree._root, leaf = { data: d$1 }, x0 = tree._x0, y0 = tree._y0, z0 = tree._z0, x1 = tree._x1, y1 = tree._y1, z1 = tree._z1, xm, ym, zm, xp, yp, zp, right, bottom, deep, i$1, j$1;
	if (!node) return tree._root = leaf, tree;
	while (node.length) {
		if (right = x$2 >= (xm = (x0 + x1) / 2)) x0 = xm;
		else x1 = xm;
		if (bottom = y$2 >= (ym = (y0 + y1) / 2)) y0 = ym;
		else y1 = ym;
		if (deep = z$2 >= (zm = (z0 + z1) / 2)) z0 = zm;
		else z1 = zm;
		if (parent = node, !(node = node[i$1 = deep << 2 | bottom << 1 | right])) return parent[i$1] = leaf, tree;
	}
	xp = +tree._x.call(null, node.data);
	yp = +tree._y.call(null, node.data);
	zp = +tree._z.call(null, node.data);
	if (x$2 === xp && y$2 === yp && z$2 === zp) return leaf.next = node, parent ? parent[i$1] = leaf : tree._root = leaf, tree;
	do {
		parent = parent ? parent[i$1] = new Array(8) : tree._root = new Array(8);
		if (right = x$2 >= (xm = (x0 + x1) / 2)) x0 = xm;
		else x1 = xm;
		if (bottom = y$2 >= (ym = (y0 + y1) / 2)) y0 = ym;
		else y1 = ym;
		if (deep = z$2 >= (zm = (z0 + z1) / 2)) z0 = zm;
		else z1 = zm;
	} while ((i$1 = deep << 2 | bottom << 1 | right) === (j$1 = (zp >= zm) << 2 | (yp >= ym) << 1 | xp >= xm));
	return parent[j$1] = node, parent[i$1] = leaf, tree;
}
function addAll(data) {
	if (!Array.isArray(data)) data = Array.from(data);
	const n$1 = data.length;
	const xz = new Float64Array(n$1);
	const yz = new Float64Array(n$1);
	const zz = new Float64Array(n$1);
	let x0 = Infinity, y0 = Infinity, z0 = Infinity, x1 = -Infinity, y1 = -Infinity, z1 = -Infinity;
	for (let i$1 = 0, d$1, x$2, y$2, z$2; i$1 < n$1; ++i$1) {
		if (isNaN(x$2 = +this._x.call(null, d$1 = data[i$1])) || isNaN(y$2 = +this._y.call(null, d$1)) || isNaN(z$2 = +this._z.call(null, d$1))) continue;
		xz[i$1] = x$2;
		yz[i$1] = y$2;
		zz[i$1] = z$2;
		if (x$2 < x0) x0 = x$2;
		if (x$2 > x1) x1 = x$2;
		if (y$2 < y0) y0 = y$2;
		if (y$2 > y1) y1 = y$2;
		if (z$2 < z0) z0 = z$2;
		if (z$2 > z1) z1 = z$2;
	}
	if (x0 > x1 || y0 > y1 || z0 > z1) return this;
	this.cover(x0, y0, z0).cover(x1, y1, z1);
	for (let i$1 = 0; i$1 < n$1; ++i$1) add(this, xz[i$1], yz[i$1], zz[i$1], data[i$1]);
	return this;
}

//#endregion
//#region node_modules/d3-octree/src/cover.js
function cover_default(x$2, y$2, z$2) {
	if (isNaN(x$2 = +x$2) || isNaN(y$2 = +y$2) || isNaN(z$2 = +z$2)) return this;
	var x0 = this._x0, y0 = this._y0, z0 = this._z0, x1 = this._x1, y1 = this._y1, z1 = this._z1;
	if (isNaN(x0)) {
		x1 = (x0 = Math.floor(x$2)) + 1;
		y1 = (y0 = Math.floor(y$2)) + 1;
		z1 = (z0 = Math.floor(z$2)) + 1;
	} else {
		var t$2 = x1 - x0 || 1, node = this._root, parent, i$1;
		while (x0 > x$2 || x$2 >= x1 || y0 > y$2 || y$2 >= y1 || z0 > z$2 || z$2 >= z1) {
			i$1 = (z$2 < z0) << 2 | (y$2 < y0) << 1 | x$2 < x0;
			parent = new Array(8), parent[i$1] = node, node = parent, t$2 *= 2;
			switch (i$1) {
				case 0:
					x1 = x0 + t$2, y1 = y0 + t$2, z1 = z0 + t$2;
					break;
				case 1:
					x0 = x1 - t$2, y1 = y0 + t$2, z1 = z0 + t$2;
					break;
				case 2:
					x1 = x0 + t$2, y0 = y1 - t$2, z1 = z0 + t$2;
					break;
				case 3:
					x0 = x1 - t$2, y0 = y1 - t$2, z1 = z0 + t$2;
					break;
				case 4:
					x1 = x0 + t$2, y1 = y0 + t$2, z0 = z1 - t$2;
					break;
				case 5:
					x0 = x1 - t$2, y1 = y0 + t$2, z0 = z1 - t$2;
					break;
				case 6:
					x1 = x0 + t$2, y0 = y1 - t$2, z0 = z1 - t$2;
					break;
				case 7:
					x0 = x1 - t$2, y0 = y1 - t$2, z0 = z1 - t$2;
					break;
			}
		}
		if (this._root && this._root.length) this._root = node;
	}
	this._x0 = x0;
	this._y0 = y0;
	this._z0 = z0;
	this._x1 = x1;
	this._y1 = y1;
	this._z1 = z1;
	return this;
}

//#endregion
//#region node_modules/d3-octree/src/data.js
function data_default() {
	var data = [];
	this.visit(function(node) {
		if (!node.length) do
			data.push(node.data);
		while (node = node.next);
	});
	return data;
}

//#endregion
//#region node_modules/d3-octree/src/extent.js
function extent_default(_$1) {
	return arguments.length ? this.cover(+_$1[0][0], +_$1[0][1], +_$1[0][2]).cover(+_$1[1][0], +_$1[1][1], +_$1[1][2]) : isNaN(this._x0) ? void 0 : [[
		this._x0,
		this._y0,
		this._z0
	], [
		this._x1,
		this._y1,
		this._z1
	]];
}

//#endregion
//#region node_modules/d3-octree/src/octant.js
function octant_default(node, x0, y0, z0, x1, y1, z1) {
	this.node = node;
	this.x0 = x0;
	this.y0 = y0;
	this.z0 = z0;
	this.x1 = x1;
	this.y1 = y1;
	this.z1 = z1;
}

//#endregion
//#region node_modules/d3-octree/src/find.js
function find_default(x$2, y$2, z$2, radius) {
	var data, x0 = this._x0, y0 = this._y0, z0 = this._z0, x1, y1, z1, x2, y2, z2, x3 = this._x1, y3 = this._y1, z3 = this._z1, octs = [], node = this._root, q$1, i$1;
	if (node) octs.push(new octant_default(node, x0, y0, z0, x3, y3, z3));
	if (radius == null) radius = Infinity;
	else {
		x0 = x$2 - radius, y0 = y$2 - radius, z0 = z$2 - radius;
		x3 = x$2 + radius, y3 = y$2 + radius, z3 = z$2 + radius;
		radius *= radius;
	}
	while (q$1 = octs.pop()) {
		if (!(node = q$1.node) || (x1 = q$1.x0) > x3 || (y1 = q$1.y0) > y3 || (z1 = q$1.z0) > z3 || (x2 = q$1.x1) < x0 || (y2 = q$1.y1) < y0 || (z2 = q$1.z1) < z0) continue;
		if (node.length) {
			var xm = (x1 + x2) / 2, ym = (y1 + y2) / 2, zm = (z1 + z2) / 2;
			octs.push(new octant_default(node[7], xm, ym, zm, x2, y2, z2), new octant_default(node[6], x1, ym, zm, xm, y2, z2), new octant_default(node[5], xm, y1, zm, x2, ym, z2), new octant_default(node[4], x1, y1, zm, xm, ym, z2), new octant_default(node[3], xm, ym, z1, x2, y2, zm), new octant_default(node[2], x1, ym, z1, xm, y2, zm), new octant_default(node[1], xm, y1, z1, x2, ym, zm), new octant_default(node[0], x1, y1, z1, xm, ym, zm));
			if (i$1 = (z$2 >= zm) << 2 | (y$2 >= ym) << 1 | x$2 >= xm) {
				q$1 = octs[octs.length - 1];
				octs[octs.length - 1] = octs[octs.length - 1 - i$1];
				octs[octs.length - 1 - i$1] = q$1;
			}
		} else {
			var dx = x$2 - +this._x.call(null, node.data), dy = y$2 - +this._y.call(null, node.data), dz = z$2 - +this._z.call(null, node.data), d2 = dx * dx + dy * dy + dz * dz;
			if (d2 < radius) {
				var d$1 = Math.sqrt(radius = d2);
				x0 = x$2 - d$1, y0 = y$2 - d$1, z0 = z$2 - d$1;
				x3 = x$2 + d$1, y3 = y$2 + d$1, z3 = z$2 + d$1;
				data = node.data;
			}
		}
	}
	return data;
}

//#endregion
//#region node_modules/d3-octree/src/findAll.js
var distance = (x1, y1, z1, x2, y2, z2) => Math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2 + (z1 - z2) ** 2);
function findAllWithinRadius(x$2, y$2, z$2, radius) {
	const result = [];
	const xMin = x$2 - radius;
	const yMin = y$2 - radius;
	const zMin = z$2 - radius;
	const xMax = x$2 + radius;
	const yMax = y$2 + radius;
	const zMax = z$2 + radius;
	this.visit((node, x1, y1, z1, x2, y2, z2) => {
		if (!node.length) do {
			const d$1 = node.data;
			if (distance(x$2, y$2, z$2, this._x(d$1), this._y(d$1), this._z(d$1)) <= radius) result.push(d$1);
		} while (node = node.next);
		return x1 > xMax || y1 > yMax || z1 > zMax || x2 < xMin || y2 < yMin || z2 < zMin;
	});
	return result;
}

//#endregion
//#region node_modules/d3-octree/src/remove.js
function remove_default(d$1) {
	if (isNaN(x$2 = +this._x.call(null, d$1)) || isNaN(y$2 = +this._y.call(null, d$1)) || isNaN(z$2 = +this._z.call(null, d$1))) return this;
	var parent, node = this._root, retainer, previous, next, x0 = this._x0, y0 = this._y0, z0 = this._z0, x1 = this._x1, y1 = this._y1, z1 = this._z1, x$2, y$2, z$2, xm, ym, zm, right, bottom, deep, i$1, j$1;
	if (!node) return this;
	if (node.length) while (true) {
		if (right = x$2 >= (xm = (x0 + x1) / 2)) x0 = xm;
		else x1 = xm;
		if (bottom = y$2 >= (ym = (y0 + y1) / 2)) y0 = ym;
		else y1 = ym;
		if (deep = z$2 >= (zm = (z0 + z1) / 2)) z0 = zm;
		else z1 = zm;
		if (!(parent = node, node = node[i$1 = deep << 2 | bottom << 1 | right])) return this;
		if (!node.length) break;
		if (parent[i$1 + 1 & 7] || parent[i$1 + 2 & 7] || parent[i$1 + 3 & 7] || parent[i$1 + 4 & 7] || parent[i$1 + 5 & 7] || parent[i$1 + 6 & 7] || parent[i$1 + 7 & 7]) retainer = parent, j$1 = i$1;
	}
	while (node.data !== d$1) if (!(previous = node, node = node.next)) return this;
	if (next = node.next) delete node.next;
	if (previous) return next ? previous.next = next : delete previous.next, this;
	if (!parent) return this._root = next, this;
	next ? parent[i$1] = next : delete parent[i$1];
	if ((node = parent[0] || parent[1] || parent[2] || parent[3] || parent[4] || parent[5] || parent[6] || parent[7]) && node === (parent[7] || parent[6] || parent[5] || parent[4] || parent[3] || parent[2] || parent[1] || parent[0]) && !node.length) if (retainer) retainer[j$1] = node;
	else this._root = node;
	return this;
}
function removeAll(data) {
	for (var i$1 = 0, n$1 = data.length; i$1 < n$1; ++i$1) this.remove(data[i$1]);
	return this;
}

//#endregion
//#region node_modules/d3-octree/src/root.js
function root_default() {
	return this._root;
}

//#endregion
//#region node_modules/d3-octree/src/size.js
function size_default() {
	var size = 0;
	this.visit(function(node) {
		if (!node.length) do
			++size;
		while (node = node.next);
	});
	return size;
}

//#endregion
//#region node_modules/d3-octree/src/visit.js
function visit_default(callback) {
	var octs = [], q$1, node = this._root, child, x0, y0, z0, x1, y1, z1;
	if (node) octs.push(new octant_default(node, this._x0, this._y0, this._z0, this._x1, this._y1, this._z1));
	while (q$1 = octs.pop()) if (!callback(node = q$1.node, x0 = q$1.x0, y0 = q$1.y0, z0 = q$1.z0, x1 = q$1.x1, y1 = q$1.y1, z1 = q$1.z1) && node.length) {
		var xm = (x0 + x1) / 2, ym = (y0 + y1) / 2, zm = (z0 + z1) / 2;
		if (child = node[7]) octs.push(new octant_default(child, xm, ym, zm, x1, y1, z1));
		if (child = node[6]) octs.push(new octant_default(child, x0, ym, zm, xm, y1, z1));
		if (child = node[5]) octs.push(new octant_default(child, xm, y0, zm, x1, ym, z1));
		if (child = node[4]) octs.push(new octant_default(child, x0, y0, zm, xm, ym, z1));
		if (child = node[3]) octs.push(new octant_default(child, xm, ym, z0, x1, y1, zm));
		if (child = node[2]) octs.push(new octant_default(child, x0, ym, z0, xm, y1, zm));
		if (child = node[1]) octs.push(new octant_default(child, xm, y0, z0, x1, ym, zm));
		if (child = node[0]) octs.push(new octant_default(child, x0, y0, z0, xm, ym, zm));
	}
	return this;
}

//#endregion
//#region node_modules/d3-octree/src/visitAfter.js
function visitAfter_default(callback) {
	var octs = [], next = [], q$1;
	if (this._root) octs.push(new octant_default(this._root, this._x0, this._y0, this._z0, this._x1, this._y1, this._z1));
	while (q$1 = octs.pop()) {
		var node = q$1.node;
		if (node.length) {
			var child, x0 = q$1.x0, y0 = q$1.y0, z0 = q$1.z0, x1 = q$1.x1, y1 = q$1.y1, z1 = q$1.z1, xm = (x0 + x1) / 2, ym = (y0 + y1) / 2, zm = (z0 + z1) / 2;
			if (child = node[0]) octs.push(new octant_default(child, x0, y0, z0, xm, ym, zm));
			if (child = node[1]) octs.push(new octant_default(child, xm, y0, z0, x1, ym, zm));
			if (child = node[2]) octs.push(new octant_default(child, x0, ym, z0, xm, y1, zm));
			if (child = node[3]) octs.push(new octant_default(child, xm, ym, z0, x1, y1, zm));
			if (child = node[4]) octs.push(new octant_default(child, x0, y0, zm, xm, ym, z1));
			if (child = node[5]) octs.push(new octant_default(child, xm, y0, zm, x1, ym, z1));
			if (child = node[6]) octs.push(new octant_default(child, x0, ym, zm, xm, y1, z1));
			if (child = node[7]) octs.push(new octant_default(child, xm, ym, zm, x1, y1, z1));
		}
		next.push(q$1);
	}
	while (q$1 = next.pop()) callback(q$1.node, q$1.x0, q$1.y0, q$1.z0, q$1.x1, q$1.y1, q$1.z1);
	return this;
}

//#endregion
//#region node_modules/d3-octree/src/x.js
function defaultX(d$1) {
	return d$1[0];
}
function x_default(_$1) {
	return arguments.length ? (this._x = _$1, this) : this._x;
}

//#endregion
//#region node_modules/d3-octree/src/y.js
function defaultY(d$1) {
	return d$1[1];
}
function y_default(_$1) {
	return arguments.length ? (this._y = _$1, this) : this._y;
}

//#endregion
//#region node_modules/d3-octree/src/z.js
function defaultZ(d$1) {
	return d$1[2];
}
function z_default(_$1) {
	return arguments.length ? (this._z = _$1, this) : this._z;
}

//#endregion
//#region node_modules/d3-octree/src/octree.js
function octree(nodes, x$2, y$2, z$2) {
	var tree = new Octree(x$2 == null ? defaultX : x$2, y$2 == null ? defaultY : y$2, z$2 == null ? defaultZ : z$2, NaN, NaN, NaN, NaN, NaN, NaN);
	return nodes == null ? tree : tree.addAll(nodes);
}
function Octree(x$2, y$2, z$2, x0, y0, z0, x1, y1, z1) {
	this._x = x$2;
	this._y = y$2;
	this._z = z$2;
	this._x0 = x0;
	this._y0 = y0;
	this._z0 = z0;
	this._x1 = x1;
	this._y1 = y1;
	this._z1 = z1;
	this._root = void 0;
}
function leaf_copy(leaf) {
	var copy = { data: leaf.data }, next = copy;
	while (leaf = leaf.next) next = next.next = { data: leaf.data };
	return copy;
}
var treeProto = octree.prototype = Octree.prototype;
treeProto.copy = function() {
	var copy = new Octree(this._x, this._y, this._z, this._x0, this._y0, this._z0, this._x1, this._y1, this._z1), node = this._root, nodes, child;
	if (!node) return copy;
	if (!node.length) return copy._root = leaf_copy(node), copy;
	nodes = [{
		source: node,
		target: copy._root = new Array(8)
	}];
	while (node = nodes.pop()) for (var i$1 = 0; i$1 < 8; ++i$1) if (child = node.source[i$1]) if (child.length) nodes.push({
		source: child,
		target: node.target[i$1] = new Array(8)
	});
	else node.target[i$1] = leaf_copy(child);
	return copy;
};
treeProto.add = add_default;
treeProto.addAll = addAll;
treeProto.cover = cover_default;
treeProto.data = data_default;
treeProto.extent = extent_default;
treeProto.find = find_default;
treeProto.findAllWithinRadius = findAllWithinRadius;
treeProto.remove = remove_default;
treeProto.removeAll = removeAll;
treeProto.root = root_default;
treeProto.size = size_default;
treeProto.visit = visit_default;
treeProto.visitAfter = visitAfter_default;
treeProto.x = x_default;
treeProto.y = y_default;
treeProto.z = z_default;

//#endregion
//#region node_modules/d3-force-3d/src/constant.js
function constant_default(x$2) {
	return function() {
		return x$2;
	};
}

//#endregion
//#region node_modules/d3-force-3d/src/jiggle.js
function jiggle_default(random) {
	return (random() - .5) * 1e-6;
}

//#endregion
//#region node_modules/d3-force-3d/src/link.js
function index$5(d$1) {
	return d$1.index;
}
function find(nodeById, nodeId) {
	var node = nodeById.get(nodeId);
	if (!node) throw new Error("node not found: " + nodeId);
	return node;
}
function link_default(links) {
	var id$1 = index$5, strength = defaultStrength, strengths, distance$1 = constant_default(30), distances, nodes, nDim, count, bias, random, iterations = 1;
	if (links == null) links = [];
	function defaultStrength(link) {
		return 1 / Math.min(count[link.source.index], count[link.target.index]);
	}
	function force(alpha) {
		for (var k$1 = 0, n$1 = links.length; k$1 < iterations; ++k$1) for (var i$1 = 0, link, source, target, x$2 = 0, y$2 = 0, z$2 = 0, l$1, b; i$1 < n$1; ++i$1) {
			link = links[i$1], source = link.source, target = link.target;
			x$2 = target.x + target.vx - source.x - source.vx || jiggle_default(random);
			if (nDim > 1) y$2 = target.y + target.vy - source.y - source.vy || jiggle_default(random);
			if (nDim > 2) z$2 = target.z + target.vz - source.z - source.vz || jiggle_default(random);
			l$1 = Math.sqrt(x$2 * x$2 + y$2 * y$2 + z$2 * z$2);
			l$1 = (l$1 - distances[i$1]) / l$1 * alpha * strengths[i$1];
			x$2 *= l$1, y$2 *= l$1, z$2 *= l$1;
			target.vx -= x$2 * (b = bias[i$1]);
			if (nDim > 1) target.vy -= y$2 * b;
			if (nDim > 2) target.vz -= z$2 * b;
			source.vx += x$2 * (b = 1 - b);
			if (nDim > 1) source.vy += y$2 * b;
			if (nDim > 2) source.vz += z$2 * b;
		}
	}
	function initialize() {
		if (!nodes) return;
		var i$1, n$1 = nodes.length, m$2 = links.length, nodeById = new Map(nodes.map((d$1, i$2) => [id$1(d$1, i$2, nodes), d$1])), link;
		for (i$1 = 0, count = new Array(n$1); i$1 < m$2; ++i$1) {
			link = links[i$1], link.index = i$1;
			if (typeof link.source !== "object") link.source = find(nodeById, link.source);
			if (typeof link.target !== "object") link.target = find(nodeById, link.target);
			count[link.source.index] = (count[link.source.index] || 0) + 1;
			count[link.target.index] = (count[link.target.index] || 0) + 1;
		}
		for (i$1 = 0, bias = new Array(m$2); i$1 < m$2; ++i$1) link = links[i$1], bias[i$1] = count[link.source.index] / (count[link.source.index] + count[link.target.index]);
		strengths = new Array(m$2), initializeStrength();
		distances = new Array(m$2), initializeDistance();
	}
	function initializeStrength() {
		if (!nodes) return;
		for (var i$1 = 0, n$1 = links.length; i$1 < n$1; ++i$1) strengths[i$1] = +strength(links[i$1], i$1, links);
	}
	function initializeDistance() {
		if (!nodes) return;
		for (var i$1 = 0, n$1 = links.length; i$1 < n$1; ++i$1) distances[i$1] = +distance$1(links[i$1], i$1, links);
	}
	force.initialize = function(_nodes, ...args) {
		nodes = _nodes;
		random = args.find((arg) => typeof arg === "function") || Math.random;
		nDim = args.find((arg) => [
			1,
			2,
			3
		].includes(arg)) || 2;
		initialize();
	};
	force.links = function(_$1) {
		return arguments.length ? (links = _$1, initialize(), force) : links;
	};
	force.id = function(_$1) {
		return arguments.length ? (id$1 = _$1, force) : id$1;
	};
	force.iterations = function(_$1) {
		return arguments.length ? (iterations = +_$1, force) : iterations;
	};
	force.strength = function(_$1) {
		return arguments.length ? (strength = typeof _$1 === "function" ? _$1 : constant_default(+_$1), initializeStrength(), force) : strength;
	};
	force.distance = function(_$1) {
		return arguments.length ? (distance$1 = typeof _$1 === "function" ? _$1 : constant_default(+_$1), initializeDistance(), force) : distance$1;
	};
	return force;
}

//#endregion
//#region node_modules/d3-force-3d/src/lcg.js
var a = 1664525;
var c = 1013904223;
var m = 4294967296;
function lcg_default() {
	let s$1 = 1;
	return () => (s$1 = (a * s$1 + c) % m) / m;
}

//#endregion
//#region node_modules/d3-force-3d/src/simulation.js
var MAX_DIMENSIONS = 3;
function x(d$1) {
	return d$1.x;
}
function y(d$1) {
	return d$1.y;
}
function z(d$1) {
	return d$1.z;
}
var initialRadius = 10, initialAngleRoll = Math.PI * (3 - Math.sqrt(5)), initialAngleYaw = Math.PI * 20 / (9 + Math.sqrt(221));
function simulation_default(nodes, numDimensions) {
	numDimensions = numDimensions || 2;
	var nDim = Math.min(MAX_DIMENSIONS, Math.max(1, Math.round(numDimensions))), simulation, alpha = 1, alphaMin = .001, alphaDecay = 1 - Math.pow(alphaMin, 1 / 300), alphaTarget = 0, velocityDecay = .6, forces = /* @__PURE__ */ new Map(), stepper = timer(step), event = dispatch_default("tick", "end"), random = lcg_default();
	if (nodes == null) nodes = [];
	function step() {
		tick();
		event.call("tick", simulation);
		if (alpha < alphaMin) {
			stepper.stop();
			event.call("end", simulation);
		}
	}
	function tick(iterations) {
		var i$1, n$1 = nodes.length, node;
		if (iterations === void 0) iterations = 1;
		for (var k$1 = 0; k$1 < iterations; ++k$1) {
			alpha += (alphaTarget - alpha) * alphaDecay;
			forces.forEach(function(force) {
				force(alpha);
			});
			for (i$1 = 0; i$1 < n$1; ++i$1) {
				node = nodes[i$1];
				if (node.fx == null) node.x += node.vx *= velocityDecay;
				else node.x = node.fx, node.vx = 0;
				if (nDim > 1) if (node.fy == null) node.y += node.vy *= velocityDecay;
				else node.y = node.fy, node.vy = 0;
				if (nDim > 2) if (node.fz == null) node.z += node.vz *= velocityDecay;
				else node.z = node.fz, node.vz = 0;
			}
		}
		return simulation;
	}
	function initializeNodes() {
		for (var i$1 = 0, n$1 = nodes.length, node; i$1 < n$1; ++i$1) {
			node = nodes[i$1], node.index = i$1;
			if (node.fx != null) node.x = node.fx;
			if (node.fy != null) node.y = node.fy;
			if (node.fz != null) node.z = node.fz;
			if (isNaN(node.x) || nDim > 1 && isNaN(node.y) || nDim > 2 && isNaN(node.z)) {
				var radius = initialRadius * (nDim > 2 ? Math.cbrt(.5 + i$1) : nDim > 1 ? Math.sqrt(.5 + i$1) : i$1), rollAngle = i$1 * initialAngleRoll, yawAngle = i$1 * initialAngleYaw;
				if (nDim === 1) node.x = radius;
				else if (nDim === 2) {
					node.x = radius * Math.cos(rollAngle);
					node.y = radius * Math.sin(rollAngle);
				} else {
					node.x = radius * Math.sin(rollAngle) * Math.cos(yawAngle);
					node.y = radius * Math.cos(rollAngle);
					node.z = radius * Math.sin(rollAngle) * Math.sin(yawAngle);
				}
			}
			if (isNaN(node.vx) || nDim > 1 && isNaN(node.vy) || nDim > 2 && isNaN(node.vz)) {
				node.vx = 0;
				if (nDim > 1) node.vy = 0;
				if (nDim > 2) node.vz = 0;
			}
		}
	}
	function initializeForce(force) {
		if (force.initialize) force.initialize(nodes, random, nDim);
		return force;
	}
	initializeNodes();
	return simulation = {
		tick,
		restart: function() {
			return stepper.restart(step), simulation;
		},
		stop: function() {
			return stepper.stop(), simulation;
		},
		numDimensions: function(_$1) {
			return arguments.length ? (nDim = Math.min(MAX_DIMENSIONS, Math.max(1, Math.round(_$1))), forces.forEach(initializeForce), simulation) : nDim;
		},
		nodes: function(_$1) {
			return arguments.length ? (nodes = _$1, initializeNodes(), forces.forEach(initializeForce), simulation) : nodes;
		},
		alpha: function(_$1) {
			return arguments.length ? (alpha = +_$1, simulation) : alpha;
		},
		alphaMin: function(_$1) {
			return arguments.length ? (alphaMin = +_$1, simulation) : alphaMin;
		},
		alphaDecay: function(_$1) {
			return arguments.length ? (alphaDecay = +_$1, simulation) : +alphaDecay;
		},
		alphaTarget: function(_$1) {
			return arguments.length ? (alphaTarget = +_$1, simulation) : alphaTarget;
		},
		velocityDecay: function(_$1) {
			return arguments.length ? (velocityDecay = 1 - _$1, simulation) : 1 - velocityDecay;
		},
		randomSource: function(_$1) {
			return arguments.length ? (random = _$1, forces.forEach(initializeForce), simulation) : random;
		},
		force: function(name, _$1) {
			return arguments.length > 1 ? (_$1 == null ? forces.delete(name) : forces.set(name, initializeForce(_$1)), simulation) : forces.get(name);
		},
		find: function() {
			var args = Array.prototype.slice.call(arguments);
			var x$2 = args.shift() || 0, y$2 = (nDim > 1 ? args.shift() : null) || 0, z$2 = (nDim > 2 ? args.shift() : null) || 0, radius = args.shift() || Infinity;
			var i$1 = 0, n$1 = nodes.length, dx, dy, dz, d2, node, closest;
			radius *= radius;
			for (i$1 = 0; i$1 < n$1; ++i$1) {
				node = nodes[i$1];
				dx = x$2 - node.x;
				dy = y$2 - (node.y || 0);
				dz = z$2 - (node.z || 0);
				d2 = dx * dx + dy * dy + dz * dz;
				if (d2 < radius) closest = node, radius = d2;
			}
			return closest;
		},
		on: function(name, _$1) {
			return arguments.length > 1 ? (event.on(name, _$1), simulation) : event.on(name);
		}
	};
}

//#endregion
//#region node_modules/d3-force-3d/src/manyBody.js
function manyBody_default() {
	var nodes, nDim, node, random, alpha, strength = constant_default(-30), strengths, distanceMin2 = 1, distanceMax2 = Infinity, theta2 = .81;
	function force(_$1) {
		var i$1, n$1 = nodes.length, tree = (nDim === 1 ? binarytree(nodes, x) : nDim === 2 ? quadtree(nodes, x, y) : nDim === 3 ? octree(nodes, x, y, z) : null).visitAfter(accumulate);
		for (alpha = _$1, i$1 = 0; i$1 < n$1; ++i$1) node = nodes[i$1], tree.visit(apply);
	}
	function initialize() {
		if (!nodes) return;
		var i$1, n$1 = nodes.length, node$1;
		strengths = new Array(n$1);
		for (i$1 = 0; i$1 < n$1; ++i$1) node$1 = nodes[i$1], strengths[node$1.index] = +strength(node$1, i$1, nodes);
	}
	function accumulate(treeNode) {
		var strength$1 = 0, q$1, c$2, weight = 0, x$2, y$2, z$2, i$1;
		var numChildren = treeNode.length;
		if (numChildren) {
			for (x$2 = y$2 = z$2 = i$1 = 0; i$1 < numChildren; ++i$1) if ((q$1 = treeNode[i$1]) && (c$2 = Math.abs(q$1.value))) strength$1 += q$1.value, weight += c$2, x$2 += c$2 * (q$1.x || 0), y$2 += c$2 * (q$1.y || 0), z$2 += c$2 * (q$1.z || 0);
			strength$1 *= Math.sqrt(4 / numChildren);
			treeNode.x = x$2 / weight;
			if (nDim > 1) treeNode.y = y$2 / weight;
			if (nDim > 2) treeNode.z = z$2 / weight;
		} else {
			q$1 = treeNode;
			q$1.x = q$1.data.x;
			if (nDim > 1) q$1.y = q$1.data.y;
			if (nDim > 2) q$1.z = q$1.data.z;
			do
				strength$1 += strengths[q$1.data.index];
			while (q$1 = q$1.next);
		}
		treeNode.value = strength$1;
	}
	function apply(treeNode, x1, arg1, arg2, arg3) {
		if (!treeNode.value) return true;
		var x2 = [
			arg1,
			arg2,
			arg3
		][nDim - 1];
		var x$2 = treeNode.x - node.x, y$2 = nDim > 1 ? treeNode.y - node.y : 0, z$2 = nDim > 2 ? treeNode.z - node.z : 0, w$1 = x2 - x1, l$1 = x$2 * x$2 + y$2 * y$2 + z$2 * z$2;
		if (w$1 * w$1 / theta2 < l$1) {
			if (l$1 < distanceMax2) {
				if (x$2 === 0) x$2 = jiggle_default(random), l$1 += x$2 * x$2;
				if (nDim > 1 && y$2 === 0) y$2 = jiggle_default(random), l$1 += y$2 * y$2;
				if (nDim > 2 && z$2 === 0) z$2 = jiggle_default(random), l$1 += z$2 * z$2;
				if (l$1 < distanceMin2) l$1 = Math.sqrt(distanceMin2 * l$1);
				node.vx += x$2 * treeNode.value * alpha / l$1;
				if (nDim > 1) node.vy += y$2 * treeNode.value * alpha / l$1;
				if (nDim > 2) node.vz += z$2 * treeNode.value * alpha / l$1;
			}
			return true;
		} else if (treeNode.length || l$1 >= distanceMax2) return;
		if (treeNode.data !== node || treeNode.next) {
			if (x$2 === 0) x$2 = jiggle_default(random), l$1 += x$2 * x$2;
			if (nDim > 1 && y$2 === 0) y$2 = jiggle_default(random), l$1 += y$2 * y$2;
			if (nDim > 2 && z$2 === 0) z$2 = jiggle_default(random), l$1 += z$2 * z$2;
			if (l$1 < distanceMin2) l$1 = Math.sqrt(distanceMin2 * l$1);
		}
		do
			if (treeNode.data !== node) {
				w$1 = strengths[treeNode.data.index] * alpha / l$1;
				node.vx += x$2 * w$1;
				if (nDim > 1) node.vy += y$2 * w$1;
				if (nDim > 2) node.vz += z$2 * w$1;
			}
		while (treeNode = treeNode.next);
	}
	force.initialize = function(_nodes, ...args) {
		nodes = _nodes;
		random = args.find((arg) => typeof arg === "function") || Math.random;
		nDim = args.find((arg) => [
			1,
			2,
			3
		].includes(arg)) || 2;
		initialize();
	};
	force.strength = function(_$1) {
		return arguments.length ? (strength = typeof _$1 === "function" ? _$1 : constant_default(+_$1), initialize(), force) : strength;
	};
	force.distanceMin = function(_$1) {
		return arguments.length ? (distanceMin2 = _$1 * _$1, force) : Math.sqrt(distanceMin2);
	};
	force.distanceMax = function(_$1) {
		return arguments.length ? (distanceMax2 = _$1 * _$1, force) : Math.sqrt(distanceMax2);
	};
	force.theta = function(_$1) {
		return arguments.length ? (theta2 = _$1 * _$1, force) : Math.sqrt(theta2);
	};
	return force;
}

//#endregion
//#region node_modules/d3-force-3d/src/radial.js
function radial_default(radius, x$2, y$2, z$2) {
	var nodes, nDim, strength = constant_default(.1), strengths, radiuses;
	if (typeof radius !== "function") radius = constant_default(+radius);
	if (x$2 == null) x$2 = 0;
	if (y$2 == null) y$2 = 0;
	if (z$2 == null) z$2 = 0;
	function force(alpha) {
		for (var i$1 = 0, n$1 = nodes.length; i$1 < n$1; ++i$1) {
			var node = nodes[i$1], dx = node.x - x$2 || 1e-6, dy = (node.y || 0) - y$2 || 1e-6, dz = (node.z || 0) - z$2 || 1e-6, r$1 = Math.sqrt(dx * dx + dy * dy + dz * dz), k$1 = (radiuses[i$1] - r$1) * strengths[i$1] * alpha / r$1;
			node.vx += dx * k$1;
			if (nDim > 1) node.vy += dy * k$1;
			if (nDim > 2) node.vz += dz * k$1;
		}
	}
	function initialize() {
		if (!nodes) return;
		var i$1, n$1 = nodes.length;
		strengths = new Array(n$1);
		radiuses = new Array(n$1);
		for (i$1 = 0; i$1 < n$1; ++i$1) {
			radiuses[i$1] = +radius(nodes[i$1], i$1, nodes);
			strengths[i$1] = isNaN(radiuses[i$1]) ? 0 : +strength(nodes[i$1], i$1, nodes);
		}
	}
	force.initialize = function(initNodes, ...args) {
		nodes = initNodes;
		nDim = args.find((arg) => [
			1,
			2,
			3
		].includes(arg)) || 2;
		initialize();
	};
	force.strength = function(_$1) {
		return arguments.length ? (strength = typeof _$1 === "function" ? _$1 : constant_default(+_$1), initialize(), force) : strength;
	};
	force.radius = function(_$1) {
		return arguments.length ? (radius = typeof _$1 === "function" ? _$1 : constant_default(+_$1), initialize(), force) : radius;
	};
	force.x = function(_$1) {
		return arguments.length ? (x$2 = +_$1, force) : x$2;
	};
	force.y = function(_$1) {
		return arguments.length ? (y$2 = +_$1, force) : y$2;
	};
	force.z = function(_$1) {
		return arguments.length ? (z$2 = +_$1, force) : z$2;
	};
	return force;
}

//#endregion
//#region node_modules/bezier-js/src/utils.js
var { abs: abs$1, cos: cos$1, sin: sin$1, acos: acos$1, atan2, sqrt: sqrt$1, pow } = Math;
function crt(v$1) {
	return v$1 < 0 ? -pow(-v$1, 1 / 3) : pow(v$1, 1 / 3);
}
var pi$1 = Math.PI, tau = 2 * pi$1, quart = pi$1 / 2, epsilon = 1e-6, nMax = Number.MAX_SAFE_INTEGER || 9007199254740991, nMin = Number.MIN_SAFE_INTEGER || -9007199254740991, ZERO = {
	x: 0,
	y: 0,
	z: 0
};
var utils = {
	Tvalues: [
		-.06405689286260563,
		.06405689286260563,
		-.1911188674736163,
		.1911188674736163,
		-.3150426796961634,
		.3150426796961634,
		-.4337935076260451,
		.4337935076260451,
		-.5454214713888396,
		.5454214713888396,
		-.6480936519369755,
		.6480936519369755,
		-.7401241915785544,
		.7401241915785544,
		-.820001985973903,
		.820001985973903,
		-.8864155270044011,
		.8864155270044011,
		-.9382745520027328,
		.9382745520027328,
		-.9747285559713095,
		.9747285559713095,
		-.9951872199970213,
		.9951872199970213
	],
	Cvalues: [
		.12793819534675216,
		.12793819534675216,
		.1258374563468283,
		.1258374563468283,
		.12167047292780339,
		.12167047292780339,
		.1155056680537256,
		.1155056680537256,
		.10744427011596563,
		.10744427011596563,
		.09761865210411388,
		.09761865210411388,
		.08619016153195327,
		.08619016153195327,
		.0733464814110803,
		.0733464814110803,
		.05929858491543678,
		.05929858491543678,
		.04427743881741981,
		.04427743881741981,
		.028531388628933663,
		.028531388628933663,
		.0123412297999872,
		.0123412297999872
	],
	arcfn: function(t$2, derivativeFn) {
		const d$1 = derivativeFn(t$2);
		let l$1 = d$1.x * d$1.x + d$1.y * d$1.y;
		if (typeof d$1.z !== "undefined") l$1 += d$1.z * d$1.z;
		return sqrt$1(l$1);
	},
	compute: function(t$2, points, _3d) {
		if (t$2 === 0) {
			points[0].t = 0;
			return points[0];
		}
		const order = points.length - 1;
		if (t$2 === 1) {
			points[order].t = 1;
			return points[order];
		}
		const mt = 1 - t$2;
		let p$1 = points;
		if (order === 0) {
			points[0].t = t$2;
			return points[0];
		}
		if (order === 1) {
			const ret = {
				x: mt * p$1[0].x + t$2 * p$1[1].x,
				y: mt * p$1[0].y + t$2 * p$1[1].y,
				t: t$2
			};
			if (_3d) ret.z = mt * p$1[0].z + t$2 * p$1[1].z;
			return ret;
		}
		if (order < 4) {
			let mt2 = mt * mt, t2 = t$2 * t$2, a$2, b, c$2, d$1 = 0;
			if (order === 2) {
				p$1 = [
					p$1[0],
					p$1[1],
					p$1[2],
					ZERO
				];
				a$2 = mt2;
				b = mt * t$2 * 2;
				c$2 = t2;
			} else if (order === 3) {
				a$2 = mt2 * mt;
				b = mt2 * t$2 * 3;
				c$2 = mt * t2 * 3;
				d$1 = t$2 * t2;
			}
			const ret = {
				x: a$2 * p$1[0].x + b * p$1[1].x + c$2 * p$1[2].x + d$1 * p$1[3].x,
				y: a$2 * p$1[0].y + b * p$1[1].y + c$2 * p$1[2].y + d$1 * p$1[3].y,
				t: t$2
			};
			if (_3d) ret.z = a$2 * p$1[0].z + b * p$1[1].z + c$2 * p$1[2].z + d$1 * p$1[3].z;
			return ret;
		}
		const dCpts = JSON.parse(JSON.stringify(points));
		while (dCpts.length > 1) {
			for (let i$1 = 0; i$1 < dCpts.length - 1; i$1++) {
				dCpts[i$1] = {
					x: dCpts[i$1].x + (dCpts[i$1 + 1].x - dCpts[i$1].x) * t$2,
					y: dCpts[i$1].y + (dCpts[i$1 + 1].y - dCpts[i$1].y) * t$2
				};
				if (typeof dCpts[i$1].z !== "undefined") dCpts[i$1].z = dCpts[i$1].z + (dCpts[i$1 + 1].z - dCpts[i$1].z) * t$2;
			}
			dCpts.splice(dCpts.length - 1, 1);
		}
		dCpts[0].t = t$2;
		return dCpts[0];
	},
	computeWithRatios: function(t$2, points, ratios, _3d) {
		const mt = 1 - t$2, r$1 = ratios, p$1 = points;
		let f1 = r$1[0], f2 = r$1[1], f3 = r$1[2], f4 = r$1[3], d$1;
		f1 *= mt;
		f2 *= t$2;
		if (p$1.length === 2) {
			d$1 = f1 + f2;
			return {
				x: (f1 * p$1[0].x + f2 * p$1[1].x) / d$1,
				y: (f1 * p$1[0].y + f2 * p$1[1].y) / d$1,
				z: !_3d ? false : (f1 * p$1[0].z + f2 * p$1[1].z) / d$1,
				t: t$2
			};
		}
		f1 *= mt;
		f2 *= 2 * mt;
		f3 *= t$2 * t$2;
		if (p$1.length === 3) {
			d$1 = f1 + f2 + f3;
			return {
				x: (f1 * p$1[0].x + f2 * p$1[1].x + f3 * p$1[2].x) / d$1,
				y: (f1 * p$1[0].y + f2 * p$1[1].y + f3 * p$1[2].y) / d$1,
				z: !_3d ? false : (f1 * p$1[0].z + f2 * p$1[1].z + f3 * p$1[2].z) / d$1,
				t: t$2
			};
		}
		f1 *= mt;
		f2 *= 1.5 * mt;
		f3 *= 3 * mt;
		f4 *= t$2 * t$2 * t$2;
		if (p$1.length === 4) {
			d$1 = f1 + f2 + f3 + f4;
			return {
				x: (f1 * p$1[0].x + f2 * p$1[1].x + f3 * p$1[2].x + f4 * p$1[3].x) / d$1,
				y: (f1 * p$1[0].y + f2 * p$1[1].y + f3 * p$1[2].y + f4 * p$1[3].y) / d$1,
				z: !_3d ? false : (f1 * p$1[0].z + f2 * p$1[1].z + f3 * p$1[2].z + f4 * p$1[3].z) / d$1,
				t: t$2
			};
		}
	},
	derive: function(points, _3d) {
		const dpoints = [];
		for (let p$1 = points, d$1 = p$1.length, c$2 = d$1 - 1; d$1 > 1; d$1--, c$2--) {
			const list = [];
			for (let j$1 = 0, dpt; j$1 < c$2; j$1++) {
				dpt = {
					x: c$2 * (p$1[j$1 + 1].x - p$1[j$1].x),
					y: c$2 * (p$1[j$1 + 1].y - p$1[j$1].y)
				};
				if (_3d) dpt.z = c$2 * (p$1[j$1 + 1].z - p$1[j$1].z);
				list.push(dpt);
			}
			dpoints.push(list);
			p$1 = list;
		}
		return dpoints;
	},
	between: function(v$1, m$2, M$1) {
		return m$2 <= v$1 && v$1 <= M$1 || utils.approximately(v$1, m$2) || utils.approximately(v$1, M$1);
	},
	approximately: function(a$2, b, precision) {
		return abs$1(a$2 - b) <= (precision || epsilon);
	},
	length: function(derivativeFn) {
		const z$2 = .5, len = utils.Tvalues.length;
		let sum$1 = 0;
		for (let i$1 = 0, t$2; i$1 < len; i$1++) {
			t$2 = z$2 * utils.Tvalues[i$1] + z$2;
			sum$1 += utils.Cvalues[i$1] * utils.arcfn(t$2, derivativeFn);
		}
		return z$2 * sum$1;
	},
	map: function(v$1, ds, de, ts, te) {
		const d1 = de - ds;
		return ts + (te - ts) * ((v$1 - ds) / d1);
	},
	lerp: function(r$1, v1, v2) {
		const ret = {
			x: v1.x + r$1 * (v2.x - v1.x),
			y: v1.y + r$1 * (v2.y - v1.y)
		};
		if (v1.z !== void 0 && v2.z !== void 0) ret.z = v1.z + r$1 * (v2.z - v1.z);
		return ret;
	},
	pointToString: function(p$1) {
		let s$1 = p$1.x + "/" + p$1.y;
		if (typeof p$1.z !== "undefined") s$1 += "/" + p$1.z;
		return s$1;
	},
	pointsToString: function(points) {
		return "[" + points.map(utils.pointToString).join(", ") + "]";
	},
	copy: function(obj) {
		return JSON.parse(JSON.stringify(obj));
	},
	angle: function(o$1, v1, v2) {
		const dx1 = v1.x - o$1.x, dy1 = v1.y - o$1.y, dx2 = v2.x - o$1.x, dy2 = v2.y - o$1.y;
		return atan2(dx1 * dy2 - dy1 * dx2, dx1 * dx2 + dy1 * dy2);
	},
	round: function(v$1, d$1) {
		const s$1 = "" + v$1;
		const pos = s$1.indexOf(".");
		return parseFloat(s$1.substring(0, pos + 1 + d$1));
	},
	dist: function(p1, p2) {
		const dx = p1.x - p2.x, dy = p1.y - p2.y;
		return sqrt$1(dx * dx + dy * dy);
	},
	closest: function(LUT, point) {
		let mdist = pow(2, 63), mpos, d$1;
		LUT.forEach(function(p$1, idx) {
			d$1 = utils.dist(point, p$1);
			if (d$1 < mdist) {
				mdist = d$1;
				mpos = idx;
			}
		});
		return {
			mdist,
			mpos
		};
	},
	abcratio: function(t$2, n$1) {
		if (n$1 !== 2 && n$1 !== 3) return false;
		if (typeof t$2 === "undefined") t$2 = .5;
		else if (t$2 === 0 || t$2 === 1) return t$2;
		const bottom = pow(t$2, n$1) + pow(1 - t$2, n$1);
		return abs$1((bottom - 1) / bottom);
	},
	projectionratio: function(t$2, n$1) {
		if (n$1 !== 2 && n$1 !== 3) return false;
		if (typeof t$2 === "undefined") t$2 = .5;
		else if (t$2 === 0 || t$2 === 1) return t$2;
		const top = pow(1 - t$2, n$1);
		return top / (pow(t$2, n$1) + top);
	},
	lli8: function(x1, y1, x2, y2, x3, y3, x4, y4) {
		const nx = (x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4), ny = (x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4), d$1 = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
		if (d$1 == 0) return false;
		return {
			x: nx / d$1,
			y: ny / d$1
		};
	},
	lli4: function(p1, p2, p3, p4) {
		const x1 = p1.x, y1 = p1.y, x2 = p2.x, y2 = p2.y, x3 = p3.x, y3 = p3.y, x4 = p4.x, y4 = p4.y;
		return utils.lli8(x1, y1, x2, y2, x3, y3, x4, y4);
	},
	lli: function(v1, v2) {
		return utils.lli4(v1, v1.c, v2, v2.c);
	},
	makeline: function(p1, p2) {
		return new Bezier(p1.x, p1.y, (p1.x + p2.x) / 2, (p1.y + p2.y) / 2, p2.x, p2.y);
	},
	findbbox: function(sections) {
		let mx = nMax, my = nMax, MX = nMin, MY = nMin;
		sections.forEach(function(s$1) {
			const bbox = s$1.bbox();
			if (mx > bbox.x.min) mx = bbox.x.min;
			if (my > bbox.y.min) my = bbox.y.min;
			if (MX < bbox.x.max) MX = bbox.x.max;
			if (MY < bbox.y.max) MY = bbox.y.max;
		});
		return {
			x: {
				min: mx,
				mid: (mx + MX) / 2,
				max: MX,
				size: MX - mx
			},
			y: {
				min: my,
				mid: (my + MY) / 2,
				max: MY,
				size: MY - my
			}
		};
	},
	shapeintersections: function(s1, bbox1, s2, bbox2, curveIntersectionThreshold) {
		if (!utils.bboxoverlap(bbox1, bbox2)) return [];
		const intersections = [];
		const a1 = [
			s1.startcap,
			s1.forward,
			s1.back,
			s1.endcap
		];
		const a2 = [
			s2.startcap,
			s2.forward,
			s2.back,
			s2.endcap
		];
		a1.forEach(function(l1) {
			if (l1.virtual) return;
			a2.forEach(function(l2) {
				if (l2.virtual) return;
				const iss = l1.intersects(l2, curveIntersectionThreshold);
				if (iss.length > 0) {
					iss.c1 = l1;
					iss.c2 = l2;
					iss.s1 = s1;
					iss.s2 = s2;
					intersections.push(iss);
				}
			});
		});
		return intersections;
	},
	makeshape: function(forward, back, curveIntersectionThreshold) {
		const bpl = back.points.length;
		const fpl = forward.points.length;
		const start$1 = utils.makeline(back.points[bpl - 1], forward.points[0]);
		const end = utils.makeline(forward.points[fpl - 1], back.points[0]);
		const shape = {
			startcap: start$1,
			forward,
			back,
			endcap: end,
			bbox: utils.findbbox([
				start$1,
				forward,
				back,
				end
			])
		};
		shape.intersections = function(s2) {
			return utils.shapeintersections(shape, shape.bbox, s2, s2.bbox, curveIntersectionThreshold);
		};
		return shape;
	},
	getminmax: function(curve, d$1, list) {
		if (!list) return {
			min: 0,
			max: 0
		};
		let min$2 = nMax, max$2 = nMin, t$2, c$2;
		if (list.indexOf(0) === -1) list = [0].concat(list);
		if (list.indexOf(1) === -1) list.push(1);
		for (let i$1 = 0, len = list.length; i$1 < len; i$1++) {
			t$2 = list[i$1];
			c$2 = curve.get(t$2);
			if (c$2[d$1] < min$2) min$2 = c$2[d$1];
			if (c$2[d$1] > max$2) max$2 = c$2[d$1];
		}
		return {
			min: min$2,
			mid: (min$2 + max$2) / 2,
			max: max$2,
			size: max$2 - min$2
		};
	},
	align: function(points, line) {
		const tx = line.p1.x, ty = line.p1.y, a$2 = -atan2(line.p2.y - ty, line.p2.x - tx), d$1 = function(v$1) {
			return {
				x: (v$1.x - tx) * cos$1(a$2) - (v$1.y - ty) * sin$1(a$2),
				y: (v$1.x - tx) * sin$1(a$2) + (v$1.y - ty) * cos$1(a$2)
			};
		};
		return points.map(d$1);
	},
	roots: function(points, line) {
		line = line || {
			p1: {
				x: 0,
				y: 0
			},
			p2: {
				x: 1,
				y: 0
			}
		};
		const order = points.length - 1;
		const aligned = utils.align(points, line);
		const reduce = function(t$2) {
			return 0 <= t$2 && t$2 <= 1;
		};
		if (order === 2) {
			const a$3 = aligned[0].y, b$1 = aligned[1].y, c$3 = aligned[2].y, d$2 = a$3 - 2 * b$1 + c$3;
			if (d$2 !== 0) {
				const m1 = -sqrt$1(b$1 * b$1 - a$3 * c$3), m2 = -a$3 + b$1;
				return [-(m1 + m2) / d$2, -(-m1 + m2) / d$2].filter(reduce);
			} else if (b$1 !== c$3 && d$2 === 0) return [(2 * b$1 - c$3) / (2 * b$1 - 2 * c$3)].filter(reduce);
			return [];
		}
		const pa = aligned[0].y, pb = aligned[1].y, pc = aligned[2].y, pd = aligned[3].y;
		let d$1 = -pa + 3 * pb - 3 * pc + pd, a$2 = 3 * pa - 6 * pb + 3 * pc, b = -3 * pa + 3 * pb, c$2 = pa;
		if (utils.approximately(d$1, 0)) {
			if (utils.approximately(a$2, 0)) {
				if (utils.approximately(b, 0)) return [];
				return [-c$2 / b].filter(reduce);
			}
			const q$2 = sqrt$1(b * b - 4 * a$2 * c$2), a2 = 2 * a$2;
			return [(q$2 - b) / a2, (-b - q$2) / a2].filter(reduce);
		}
		a$2 /= d$1;
		b /= d$1;
		c$2 /= d$1;
		const p$1 = (3 * b - a$2 * a$2) / 3, p3 = p$1 / 3, q$1 = (2 * a$2 * a$2 * a$2 - 9 * a$2 * b + 27 * c$2) / 27, q2 = q$1 / 2, discriminant = q2 * q2 + p3 * p3 * p3;
		let u1, v1, x1, x2, x3;
		if (discriminant < 0) {
			const mp3 = -p$1 / 3, r$1 = sqrt$1(mp3 * mp3 * mp3), t$2 = -q$1 / (2 * r$1), phi = acos$1(t$2 < -1 ? -1 : t$2 > 1 ? 1 : t$2), t1 = 2 * crt(r$1);
			x1 = t1 * cos$1(phi / 3) - a$2 / 3;
			x2 = t1 * cos$1((phi + tau) / 3) - a$2 / 3;
			x3 = t1 * cos$1((phi + 2 * tau) / 3) - a$2 / 3;
			return [
				x1,
				x2,
				x3
			].filter(reduce);
		} else if (discriminant === 0) {
			u1 = q2 < 0 ? crt(-q2) : -crt(q2);
			x1 = 2 * u1 - a$2 / 3;
			x2 = -u1 - a$2 / 3;
			return [x1, x2].filter(reduce);
		} else {
			const sd = sqrt$1(discriminant);
			u1 = crt(-q2 + sd);
			v1 = crt(q2 + sd);
			return [u1 - v1 - a$2 / 3].filter(reduce);
		}
	},
	droots: function(p$1) {
		if (p$1.length === 3) {
			const a$2 = p$1[0], b = p$1[1], c$2 = p$1[2], d$1 = a$2 - 2 * b + c$2;
			if (d$1 !== 0) {
				const m1 = -sqrt$1(b * b - a$2 * c$2), m2 = -a$2 + b;
				return [-(m1 + m2) / d$1, -(-m1 + m2) / d$1];
			} else if (b !== c$2 && d$1 === 0) return [(2 * b - c$2) / (2 * (b - c$2))];
			return [];
		}
		if (p$1.length === 2) {
			const a$2 = p$1[0], b = p$1[1];
			if (a$2 !== b) return [a$2 / (a$2 - b)];
			return [];
		}
		return [];
	},
	curvature: function(t$2, d1, d2, _3d, kOnly) {
		let num, dnm, adk, dk, k$1 = 0, r$1 = 0;
		const d$1 = utils.compute(t$2, d1);
		const dd = utils.compute(t$2, d2);
		const qdsum = d$1.x * d$1.x + d$1.y * d$1.y;
		if (_3d) {
			num = sqrt$1(pow(d$1.y * dd.z - dd.y * d$1.z, 2) + pow(d$1.z * dd.x - dd.z * d$1.x, 2) + pow(d$1.x * dd.y - dd.x * d$1.y, 2));
			dnm = pow(qdsum + d$1.z * d$1.z, 3 / 2);
		} else {
			num = d$1.x * dd.y - d$1.y * dd.x;
			dnm = pow(qdsum, 3 / 2);
		}
		if (num === 0 || dnm === 0) return {
			k: 0,
			r: 0
		};
		k$1 = num / dnm;
		r$1 = dnm / num;
		if (!kOnly) {
			const pk = utils.curvature(t$2 - .001, d1, d2, _3d, true).k;
			const nk = utils.curvature(t$2 + .001, d1, d2, _3d, true).k;
			dk = (nk - k$1 + (k$1 - pk)) / 2;
			adk = (abs$1(nk - k$1) + abs$1(k$1 - pk)) / 2;
		}
		return {
			k: k$1,
			r: r$1,
			dk,
			adk
		};
	},
	inflections: function(points) {
		if (points.length < 4) return [];
		const p$1 = utils.align(points, {
			p1: points[0],
			p2: points.slice(-1)[0]
		}), a$2 = p$1[2].x * p$1[1].y, b = p$1[3].x * p$1[1].y, c$2 = p$1[1].x * p$1[2].y, d$1 = p$1[3].x * p$1[2].y, v1 = 18 * (-3 * a$2 + 2 * b + 3 * c$2 - d$1), v2 = 18 * (3 * a$2 - b - 3 * c$2), v3 = 18 * (c$2 - a$2);
		if (utils.approximately(v1, 0)) {
			if (!utils.approximately(v2, 0)) {
				let t$2 = -v3 / v2;
				if (0 <= t$2 && t$2 <= 1) return [t$2];
			}
			return [];
		}
		const d2 = 2 * v1;
		if (utils.approximately(d2, 0)) return [];
		const trm = v2 * v2 - 4 * v1 * v3;
		if (trm < 0) return [];
		const sq = Math.sqrt(trm);
		return [(sq - v2) / d2, -(v2 + sq) / d2].filter(function(r$1) {
			return 0 <= r$1 && r$1 <= 1;
		});
	},
	bboxoverlap: function(b1, b2) {
		const dims = ["x", "y"], len = dims.length;
		for (let i$1 = 0, dim, l$1, t$2, d$1; i$1 < len; i$1++) {
			dim = dims[i$1];
			l$1 = b1[dim].mid;
			t$2 = b2[dim].mid;
			d$1 = (b1[dim].size + b2[dim].size) / 2;
			if (abs$1(l$1 - t$2) >= d$1) return false;
		}
		return true;
	},
	expandbox: function(bbox, _bbox) {
		if (_bbox.x.min < bbox.x.min) bbox.x.min = _bbox.x.min;
		if (_bbox.y.min < bbox.y.min) bbox.y.min = _bbox.y.min;
		if (_bbox.z && _bbox.z.min < bbox.z.min) bbox.z.min = _bbox.z.min;
		if (_bbox.x.max > bbox.x.max) bbox.x.max = _bbox.x.max;
		if (_bbox.y.max > bbox.y.max) bbox.y.max = _bbox.y.max;
		if (_bbox.z && _bbox.z.max > bbox.z.max) bbox.z.max = _bbox.z.max;
		bbox.x.mid = (bbox.x.min + bbox.x.max) / 2;
		bbox.y.mid = (bbox.y.min + bbox.y.max) / 2;
		if (bbox.z) bbox.z.mid = (bbox.z.min + bbox.z.max) / 2;
		bbox.x.size = bbox.x.max - bbox.x.min;
		bbox.y.size = bbox.y.max - bbox.y.min;
		if (bbox.z) bbox.z.size = bbox.z.max - bbox.z.min;
	},
	pairiteration: function(c1, c2, curveIntersectionThreshold) {
		const c1b = c1.bbox(), c2b = c2.bbox(), r$1 = 1e5, threshold = curveIntersectionThreshold || .5;
		if (c1b.x.size + c1b.y.size < threshold && c2b.x.size + c2b.y.size < threshold) return [(r$1 * (c1._t1 + c1._t2) / 2 | 0) / r$1 + "/" + (r$1 * (c2._t1 + c2._t2) / 2 | 0) / r$1];
		let cc1 = c1.split(.5), cc2 = c2.split(.5), pairs = [
			{
				left: cc1.left,
				right: cc2.left
			},
			{
				left: cc1.left,
				right: cc2.right
			},
			{
				left: cc1.right,
				right: cc2.right
			},
			{
				left: cc1.right,
				right: cc2.left
			}
		];
		pairs = pairs.filter(function(pair) {
			return utils.bboxoverlap(pair.left.bbox(), pair.right.bbox());
		});
		let results = [];
		if (pairs.length === 0) return results;
		pairs.forEach(function(pair) {
			results = results.concat(utils.pairiteration(pair.left, pair.right, threshold));
		});
		results = results.filter(function(v$1, i$1) {
			return results.indexOf(v$1) === i$1;
		});
		return results;
	},
	getccenter: function(p1, p2, p3) {
		const dx1 = p2.x - p1.x, dy1 = p2.y - p1.y, dx2 = p3.x - p2.x, dy2 = p3.y - p2.y, dx1p = dx1 * cos$1(quart) - dy1 * sin$1(quart), dy1p = dx1 * sin$1(quart) + dy1 * cos$1(quart), dx2p = dx2 * cos$1(quart) - dy2 * sin$1(quart), dy2p = dx2 * sin$1(quart) + dy2 * cos$1(quart), mx1 = (p1.x + p2.x) / 2, my1 = (p1.y + p2.y) / 2, mx2 = (p2.x + p3.x) / 2, my2 = (p2.y + p3.y) / 2, mx1n = mx1 + dx1p, my1n = my1 + dy1p, mx2n = mx2 + dx2p, my2n = my2 + dy2p, arc = utils.lli8(mx1, my1, mx1n, my1n, mx2, my2, mx2n, my2n), r$1 = utils.dist(arc, p1);
		let s$1 = atan2(p1.y - arc.y, p1.x - arc.x), m$2 = atan2(p2.y - arc.y, p2.x - arc.x), e$1 = atan2(p3.y - arc.y, p3.x - arc.x), _$1;
		if (s$1 < e$1) {
			if (s$1 > m$2 || m$2 > e$1) s$1 += tau;
			if (s$1 > e$1) {
				_$1 = e$1;
				e$1 = s$1;
				s$1 = _$1;
			}
		} else if (e$1 < m$2 && m$2 < s$1) {
			_$1 = e$1;
			e$1 = s$1;
			s$1 = _$1;
		} else e$1 += tau;
		arc.s = s$1;
		arc.e = e$1;
		arc.r = r$1;
		return arc;
	},
	numberSort: function(a$2, b) {
		return a$2 - b;
	}
};

//#endregion
//#region node_modules/bezier-js/src/poly-bezier.js
/**
* Poly Bezier
* @param {[type]} curves [description]
*/
var PolyBezier = class PolyBezier {
	constructor(curves) {
		this.curves = [];
		this._3d = false;
		if (!!curves) {
			this.curves = curves;
			this._3d = this.curves[0]._3d;
		}
	}
	valueOf() {
		return this.toString();
	}
	toString() {
		return "[" + this.curves.map(function(curve) {
			return utils.pointsToString(curve.points);
		}).join(", ") + "]";
	}
	addCurve(curve) {
		this.curves.push(curve);
		this._3d = this._3d || curve._3d;
	}
	length() {
		return this.curves.map(function(v$1) {
			return v$1.length();
		}).reduce(function(a$2, b) {
			return a$2 + b;
		});
	}
	curve(idx) {
		return this.curves[idx];
	}
	bbox() {
		const c$2 = this.curves;
		var bbox = c$2[0].bbox();
		for (var i$1 = 1; i$1 < c$2.length; i$1++) utils.expandbox(bbox, c$2[i$1].bbox());
		return bbox;
	}
	offset(d$1) {
		const offset = [];
		this.curves.forEach(function(v$1) {
			offset.push(...v$1.offset(d$1));
		});
		return new PolyBezier(offset);
	}
};

//#endregion
//#region node_modules/bezier-js/src/bezier.js
/**
A javascript Bezier curve library by Pomax.

Based on http://pomax.github.io/bezierinfo

This code is MIT licensed.
**/
var { abs, min: min$1, max: max$1, cos, sin, acos, sqrt } = Math;
var pi = Math.PI;
/**
* Bezier curve constructor.
*
* ...docs pending...
*/
var Bezier = class Bezier {
	constructor(coords) {
		let args = coords && coords.forEach ? coords : Array.from(arguments).slice();
		let coordlen = false;
		if (typeof args[0] === "object") {
			coordlen = args.length;
			const newargs = [];
			args.forEach(function(point$1) {
				[
					"x",
					"y",
					"z"
				].forEach(function(d$1) {
					if (typeof point$1[d$1] !== "undefined") newargs.push(point$1[d$1]);
				});
			});
			args = newargs;
		}
		let higher = false;
		const len = args.length;
		if (coordlen) {
			if (coordlen > 4) {
				if (arguments.length !== 1) throw new Error("Only new Bezier(point[]) is accepted for 4th and higher order curves");
				higher = true;
			}
		} else if (len !== 6 && len !== 8 && len !== 9 && len !== 12) {
			if (arguments.length !== 1) throw new Error("Only new Bezier(point[]) is accepted for 4th and higher order curves");
		}
		const _3d = this._3d = !higher && (len === 9 || len === 12) || coords && coords[0] && typeof coords[0].z !== "undefined";
		const points = this.points = [];
		for (let idx = 0, step = _3d ? 3 : 2; idx < len; idx += step) {
			var point = {
				x: args[idx],
				y: args[idx + 1]
			};
			if (_3d) point.z = args[idx + 2];
			points.push(point);
		}
		const order = this.order = points.length - 1;
		const dims = this.dims = ["x", "y"];
		if (_3d) dims.push("z");
		this.dimlen = dims.length;
		const aligned = utils.align(points, {
			p1: points[0],
			p2: points[order]
		});
		const baselength = utils.dist(points[0], points[order]);
		this._linear = aligned.reduce((t$2, p$1) => t$2 + abs(p$1.y), 0) < baselength / 50;
		this._lut = [];
		this._t1 = 0;
		this._t2 = 1;
		this.update();
	}
	static quadraticFromPoints(p1, p2, p3, t$2) {
		if (typeof t$2 === "undefined") t$2 = .5;
		if (t$2 === 0) return new Bezier(p2, p2, p3);
		if (t$2 === 1) return new Bezier(p1, p2, p2);
		return new Bezier(p1, Bezier.getABC(2, p1, p2, p3, t$2).A, p3);
	}
	static cubicFromPoints(S$1, B$1, E$1, t$2, d1) {
		if (typeof t$2 === "undefined") t$2 = .5;
		const abc = Bezier.getABC(3, S$1, B$1, E$1, t$2);
		if (typeof d1 === "undefined") d1 = utils.dist(B$1, abc.C);
		const d2 = d1 * (1 - t$2) / t$2;
		const selen = utils.dist(S$1, E$1), lx = (E$1.x - S$1.x) / selen, ly = (E$1.y - S$1.y) / selen, bx1 = d1 * lx, by1 = d1 * ly, bx2 = d2 * lx, by2 = d2 * ly;
		const e1 = {
			x: B$1.x - bx1,
			y: B$1.y - by1
		}, e2 = {
			x: B$1.x + bx2,
			y: B$1.y + by2
		}, A$1 = abc.A, v1 = {
			x: A$1.x + (e1.x - A$1.x) / (1 - t$2),
			y: A$1.y + (e1.y - A$1.y) / (1 - t$2)
		}, v2 = {
			x: A$1.x + (e2.x - A$1.x) / t$2,
			y: A$1.y + (e2.y - A$1.y) / t$2
		};
		return new Bezier(S$1, {
			x: S$1.x + (v1.x - S$1.x) / t$2,
			y: S$1.y + (v1.y - S$1.y) / t$2
		}, {
			x: E$1.x + (v2.x - E$1.x) / (1 - t$2),
			y: E$1.y + (v2.y - E$1.y) / (1 - t$2)
		}, E$1);
	}
	static getUtils() {
		return utils;
	}
	getUtils() {
		return Bezier.getUtils();
	}
	static get PolyBezier() {
		return PolyBezier;
	}
	valueOf() {
		return this.toString();
	}
	toString() {
		return utils.pointsToString(this.points);
	}
	toSVG() {
		if (this._3d) return false;
		const p$1 = this.points, s$1 = [
			"M",
			p$1[0].x,
			p$1[0].y,
			this.order === 2 ? "Q" : "C"
		];
		for (let i$1 = 1, last = p$1.length; i$1 < last; i$1++) {
			s$1.push(p$1[i$1].x);
			s$1.push(p$1[i$1].y);
		}
		return s$1.join(" ");
	}
	setRatios(ratios) {
		if (ratios.length !== this.points.length) throw new Error("incorrect number of ratio values");
		this.ratios = ratios;
		this._lut = [];
	}
	verify() {
		const print = this.coordDigest();
		if (print !== this._print) {
			this._print = print;
			this.update();
		}
	}
	coordDigest() {
		return this.points.map(function(c$2, pos) {
			return "" + pos + c$2.x + c$2.y + (c$2.z ? c$2.z : 0);
		}).join("");
	}
	update() {
		this._lut = [];
		this.dpoints = utils.derive(this.points, this._3d);
		this.computedirection();
	}
	computedirection() {
		const points = this.points;
		this.clockwise = utils.angle(points[0], points[this.order], points[1]) > 0;
	}
	length() {
		return utils.length(this.derivative.bind(this));
	}
	static getABC(order = 2, S$1, B$1, E$1, t$2 = .5) {
		const u$1 = utils.projectionratio(t$2, order), um = 1 - u$1, C$1 = {
			x: u$1 * S$1.x + um * E$1.x,
			y: u$1 * S$1.y + um * E$1.y
		}, s$1 = utils.abcratio(t$2, order);
		return {
			A: {
				x: B$1.x + (B$1.x - C$1.x) / s$1,
				y: B$1.y + (B$1.y - C$1.y) / s$1
			},
			B: B$1,
			C: C$1,
			S: S$1,
			E: E$1
		};
	}
	getABC(t$2, B$1) {
		B$1 = B$1 || this.get(t$2);
		let S$1 = this.points[0];
		let E$1 = this.points[this.order];
		return Bezier.getABC(this.order, S$1, B$1, E$1, t$2);
	}
	getLUT(steps) {
		this.verify();
		steps = steps || 100;
		if (this._lut.length === steps + 1) return this._lut;
		this._lut = [];
		steps++;
		this._lut = [];
		for (let i$1 = 0, p$1, t$2; i$1 < steps; i$1++) {
			t$2 = i$1 / (steps - 1);
			p$1 = this.compute(t$2);
			p$1.t = t$2;
			this._lut.push(p$1);
		}
		return this._lut;
	}
	on(point, error) {
		error = error || 5;
		const lut = this.getLUT(), hits = [];
		for (let i$1 = 0, c$2, t$2 = 0; i$1 < lut.length; i$1++) {
			c$2 = lut[i$1];
			if (utils.dist(c$2, point) < error) {
				hits.push(c$2);
				t$2 += i$1 / lut.length;
			}
		}
		if (!hits.length) return false;
		return t /= hits.length;
	}
	project(point) {
		const LUT = this.getLUT(), l$1 = LUT.length - 1, closest = utils.closest(LUT, point), mpos = closest.mpos, t1 = (mpos - 1) / l$1, t2 = (mpos + 1) / l$1, step = .1 / l$1;
		let mdist = closest.mdist, t$2 = t1, ft = t$2, p$1;
		mdist += 1;
		for (let d$1; t$2 < t2 + step; t$2 += step) {
			p$1 = this.compute(t$2);
			d$1 = utils.dist(point, p$1);
			if (d$1 < mdist) {
				mdist = d$1;
				ft = t$2;
			}
		}
		ft = ft < 0 ? 0 : ft > 1 ? 1 : ft;
		p$1 = this.compute(ft);
		p$1.t = ft;
		p$1.d = mdist;
		return p$1;
	}
	get(t$2) {
		return this.compute(t$2);
	}
	point(idx) {
		return this.points[idx];
	}
	compute(t$2) {
		if (this.ratios) return utils.computeWithRatios(t$2, this.points, this.ratios, this._3d);
		return utils.compute(t$2, this.points, this._3d, this.ratios);
	}
	raise() {
		const p$1 = this.points, np = [p$1[0]], k$1 = p$1.length;
		for (let i$1 = 1, pi$2, pim; i$1 < k$1; i$1++) {
			pi$2 = p$1[i$1];
			pim = p$1[i$1 - 1];
			np[i$1] = {
				x: (k$1 - i$1) / k$1 * pi$2.x + i$1 / k$1 * pim.x,
				y: (k$1 - i$1) / k$1 * pi$2.y + i$1 / k$1 * pim.y
			};
		}
		np[k$1] = p$1[k$1 - 1];
		return new Bezier(np);
	}
	derivative(t$2) {
		return utils.compute(t$2, this.dpoints[0], this._3d);
	}
	dderivative(t$2) {
		return utils.compute(t$2, this.dpoints[1], this._3d);
	}
	align() {
		let p$1 = this.points;
		return new Bezier(utils.align(p$1, {
			p1: p$1[0],
			p2: p$1[p$1.length - 1]
		}));
	}
	curvature(t$2) {
		return utils.curvature(t$2, this.dpoints[0], this.dpoints[1], this._3d);
	}
	inflections() {
		return utils.inflections(this.points);
	}
	normal(t$2) {
		return this._3d ? this.__normal3(t$2) : this.__normal2(t$2);
	}
	__normal2(t$2) {
		const d$1 = this.derivative(t$2);
		const q$1 = sqrt(d$1.x * d$1.x + d$1.y * d$1.y);
		return {
			t: t$2,
			x: -d$1.y / q$1,
			y: d$1.x / q$1
		};
	}
	__normal3(t$2) {
		const r1 = this.derivative(t$2), r2 = this.derivative(t$2 + .01), q1 = sqrt(r1.x * r1.x + r1.y * r1.y + r1.z * r1.z), q2 = sqrt(r2.x * r2.x + r2.y * r2.y + r2.z * r2.z);
		r1.x /= q1;
		r1.y /= q1;
		r1.z /= q1;
		r2.x /= q2;
		r2.y /= q2;
		r2.z /= q2;
		const c$2 = {
			x: r2.y * r1.z - r2.z * r1.y,
			y: r2.z * r1.x - r2.x * r1.z,
			z: r2.x * r1.y - r2.y * r1.x
		};
		const m$2 = sqrt(c$2.x * c$2.x + c$2.y * c$2.y + c$2.z * c$2.z);
		c$2.x /= m$2;
		c$2.y /= m$2;
		c$2.z /= m$2;
		const R = [
			c$2.x * c$2.x,
			c$2.x * c$2.y - c$2.z,
			c$2.x * c$2.z + c$2.y,
			c$2.x * c$2.y + c$2.z,
			c$2.y * c$2.y,
			c$2.y * c$2.z - c$2.x,
			c$2.x * c$2.z - c$2.y,
			c$2.y * c$2.z + c$2.x,
			c$2.z * c$2.z
		];
		return {
			t: t$2,
			x: R[0] * r1.x + R[1] * r1.y + R[2] * r1.z,
			y: R[3] * r1.x + R[4] * r1.y + R[5] * r1.z,
			z: R[6] * r1.x + R[7] * r1.y + R[8] * r1.z
		};
	}
	hull(t$2) {
		let p$1 = this.points, _p = [], q$1 = [], idx = 0;
		q$1[idx++] = p$1[0];
		q$1[idx++] = p$1[1];
		q$1[idx++] = p$1[2];
		if (this.order === 3) q$1[idx++] = p$1[3];
		while (p$1.length > 1) {
			_p = [];
			for (let i$1 = 0, pt, l$1 = p$1.length - 1; i$1 < l$1; i$1++) {
				pt = utils.lerp(t$2, p$1[i$1], p$1[i$1 + 1]);
				q$1[idx++] = pt;
				_p.push(pt);
			}
			p$1 = _p;
		}
		return q$1;
	}
	split(t1, t2) {
		if (t1 === 0 && !!t2) return this.split(t2).left;
		if (t2 === 1) return this.split(t1).right;
		const q$1 = this.hull(t1);
		const result = {
			left: this.order === 2 ? new Bezier([
				q$1[0],
				q$1[3],
				q$1[5]
			]) : new Bezier([
				q$1[0],
				q$1[4],
				q$1[7],
				q$1[9]
			]),
			right: this.order === 2 ? new Bezier([
				q$1[5],
				q$1[4],
				q$1[2]
			]) : new Bezier([
				q$1[9],
				q$1[8],
				q$1[6],
				q$1[3]
			]),
			span: q$1
		};
		result.left._t1 = utils.map(0, 0, 1, this._t1, this._t2);
		result.left._t2 = utils.map(t1, 0, 1, this._t1, this._t2);
		result.right._t1 = utils.map(t1, 0, 1, this._t1, this._t2);
		result.right._t2 = utils.map(1, 0, 1, this._t1, this._t2);
		if (!t2) return result;
		t2 = utils.map(t2, t1, 1, 0, 1);
		return result.right.split(t2).left;
	}
	extrema() {
		const result = {};
		let roots = [];
		this.dims.forEach(function(dim) {
			let mfn = function(v$1) {
				return v$1[dim];
			};
			let p$1 = this.dpoints[0].map(mfn);
			result[dim] = utils.droots(p$1);
			if (this.order === 3) {
				p$1 = this.dpoints[1].map(mfn);
				result[dim] = result[dim].concat(utils.droots(p$1));
			}
			result[dim] = result[dim].filter(function(t$2) {
				return t$2 >= 0 && t$2 <= 1;
			});
			roots = roots.concat(result[dim].sort(utils.numberSort));
		}.bind(this));
		result.values = roots.sort(utils.numberSort).filter(function(v$1, idx) {
			return roots.indexOf(v$1) === idx;
		});
		return result;
	}
	bbox() {
		const extrema = this.extrema(), result = {};
		this.dims.forEach(function(d$1) {
			result[d$1] = utils.getminmax(this, d$1, extrema[d$1]);
		}.bind(this));
		return result;
	}
	overlaps(curve) {
		const lbbox = this.bbox(), tbbox = curve.bbox();
		return utils.bboxoverlap(lbbox, tbbox);
	}
	offset(t$2, d$1) {
		if (typeof d$1 !== "undefined") {
			const c$2 = this.get(t$2), n$1 = this.normal(t$2);
			const ret = {
				c: c$2,
				n: n$1,
				x: c$2.x + n$1.x * d$1,
				y: c$2.y + n$1.y * d$1
			};
			if (this._3d) ret.z = c$2.z + n$1.z * d$1;
			return ret;
		}
		if (this._linear) {
			const nv = this.normal(0);
			return [new Bezier(this.points.map(function(p$1) {
				const ret = {
					x: p$1.x + t$2 * nv.x,
					y: p$1.y + t$2 * nv.y
				};
				if (p$1.z && nv.z) ret.z = p$1.z + t$2 * nv.z;
				return ret;
			}))];
		}
		return this.reduce().map(function(s$1) {
			if (s$1._linear) return s$1.offset(t$2)[0];
			return s$1.scale(t$2);
		});
	}
	simple() {
		if (this.order === 3) {
			const a1 = utils.angle(this.points[0], this.points[3], this.points[1]);
			const a2 = utils.angle(this.points[0], this.points[3], this.points[2]);
			if (a1 > 0 && a2 < 0 || a1 < 0 && a2 > 0) return false;
		}
		const n1 = this.normal(0);
		const n2 = this.normal(1);
		let s$1 = n1.x * n2.x + n1.y * n2.y;
		if (this._3d) s$1 += n1.z * n2.z;
		return abs(acos(s$1)) < pi / 3;
	}
	reduce() {
		let i$1, t1 = 0, t2 = 0, step = .01, segment, pass1 = [], pass2 = [];
		let extrema = this.extrema().values;
		if (extrema.indexOf(0) === -1) extrema = [0].concat(extrema);
		if (extrema.indexOf(1) === -1) extrema.push(1);
		for (t1 = extrema[0], i$1 = 1; i$1 < extrema.length; i$1++) {
			t2 = extrema[i$1];
			segment = this.split(t1, t2);
			segment._t1 = t1;
			segment._t2 = t2;
			pass1.push(segment);
			t1 = t2;
		}
		pass1.forEach(function(p1) {
			t1 = 0;
			t2 = 0;
			while (t2 <= 1) for (t2 = t1 + step; t2 <= 1 + step; t2 += step) {
				segment = p1.split(t1, t2);
				if (!segment.simple()) {
					t2 -= step;
					if (abs(t1 - t2) < step) return [];
					segment = p1.split(t1, t2);
					segment._t1 = utils.map(t1, 0, 1, p1._t1, p1._t2);
					segment._t2 = utils.map(t2, 0, 1, p1._t1, p1._t2);
					pass2.push(segment);
					t1 = t2;
					break;
				}
			}
			if (t1 < 1) {
				segment = p1.split(t1, 1);
				segment._t1 = utils.map(t1, 0, 1, p1._t1, p1._t2);
				segment._t2 = p1._t2;
				pass2.push(segment);
			}
		});
		return pass2;
	}
	translate(v$1, d1, d2) {
		d2 = typeof d2 === "number" ? d2 : d1;
		const o$1 = this.order;
		let d$1 = this.points.map((_$1, i$1) => (1 - i$1 / o$1) * d1 + i$1 / o$1 * d2);
		return new Bezier(this.points.map((p$1, i$1) => ({
			x: p$1.x + v$1.x * d$1[i$1],
			y: p$1.y + v$1.y * d$1[i$1]
		})));
	}
	scale(d$1) {
		const order = this.order;
		let distanceFn = false;
		if (typeof d$1 === "function") distanceFn = d$1;
		if (distanceFn && order === 2) return this.raise().scale(distanceFn);
		const clockwise = this.clockwise;
		const points = this.points;
		if (this._linear) return this.translate(this.normal(0), distanceFn ? distanceFn(0) : d$1, distanceFn ? distanceFn(1) : d$1);
		const r1 = distanceFn ? distanceFn(0) : d$1;
		const r2 = distanceFn ? distanceFn(1) : d$1;
		const v$1 = [this.offset(0, 10), this.offset(1, 10)];
		const np = [];
		const o$1 = utils.lli4(v$1[0], v$1[0].c, v$1[1], v$1[1].c);
		if (!o$1) throw new Error("cannot scale this curve. Try reducing it first.");
		[0, 1].forEach(function(t$2) {
			const p$1 = np[t$2 * order] = utils.copy(points[t$2 * order]);
			p$1.x += (t$2 ? r2 : r1) * v$1[t$2].n.x;
			p$1.y += (t$2 ? r2 : r1) * v$1[t$2].n.y;
		});
		if (!distanceFn) {
			[0, 1].forEach((t$2) => {
				if (order === 2 && !!t$2) return;
				const p$1 = np[t$2 * order];
				const d$2 = this.derivative(t$2);
				const p2 = {
					x: p$1.x + d$2.x,
					y: p$1.y + d$2.y
				};
				np[t$2 + 1] = utils.lli4(p$1, p2, o$1, points[t$2 + 1]);
			});
			return new Bezier(np);
		}
		[0, 1].forEach(function(t$2) {
			if (order === 2 && !!t$2) return;
			var p$1 = points[t$2 + 1];
			var ov = {
				x: p$1.x - o$1.x,
				y: p$1.y - o$1.y
			};
			var rc = distanceFn ? distanceFn((t$2 + 1) / order) : d$1;
			if (distanceFn && !clockwise) rc = -rc;
			var m$2 = sqrt(ov.x * ov.x + ov.y * ov.y);
			ov.x /= m$2;
			ov.y /= m$2;
			np[t$2 + 1] = {
				x: p$1.x + rc * ov.x,
				y: p$1.y + rc * ov.y
			};
		});
		return new Bezier(np);
	}
	outline(d1, d2, d3, d4) {
		d2 = d2 === void 0 ? d1 : d2;
		if (this._linear) {
			const n$1 = this.normal(0);
			const start$1 = this.points[0];
			const end = this.points[this.points.length - 1];
			let s$1, mid, e$1;
			if (d3 === void 0) {
				d3 = d1;
				d4 = d2;
			}
			s$1 = {
				x: start$1.x + n$1.x * d1,
				y: start$1.y + n$1.y * d1
			};
			e$1 = {
				x: end.x + n$1.x * d3,
				y: end.y + n$1.y * d3
			};
			mid = {
				x: (s$1.x + e$1.x) / 2,
				y: (s$1.y + e$1.y) / 2
			};
			const fline = [
				s$1,
				mid,
				e$1
			];
			s$1 = {
				x: start$1.x - n$1.x * d2,
				y: start$1.y - n$1.y * d2
			};
			e$1 = {
				x: end.x - n$1.x * d4,
				y: end.y - n$1.y * d4
			};
			mid = {
				x: (s$1.x + e$1.x) / 2,
				y: (s$1.y + e$1.y) / 2
			};
			const bline = [
				e$1,
				mid,
				s$1
			];
			const ls$1 = utils.makeline(bline[2], fline[0]);
			const le$1 = utils.makeline(fline[2], bline[0]);
			return new PolyBezier([
				ls$1,
				new Bezier(fline),
				le$1,
				new Bezier(bline)
			]);
		}
		const reduced = this.reduce(), len = reduced.length, fcurves = [];
		let bcurves = [], p$1, alen = 0, tlen = this.length();
		const graduated = typeof d3 !== "undefined" && typeof d4 !== "undefined";
		function linearDistanceFunction(s$1, e$1, tlen$1, alen$1, slen) {
			return function(v$1) {
				const f1 = alen$1 / tlen$1, f2 = (alen$1 + slen) / tlen$1, d$1 = e$1 - s$1;
				return utils.map(v$1, 0, 1, s$1 + f1 * d$1, s$1 + f2 * d$1);
			};
		}
		reduced.forEach(function(segment) {
			const slen = segment.length();
			if (graduated) {
				fcurves.push(segment.scale(linearDistanceFunction(d1, d3, tlen, alen, slen)));
				bcurves.push(segment.scale(linearDistanceFunction(-d2, -d4, tlen, alen, slen)));
			} else {
				fcurves.push(segment.scale(d1));
				bcurves.push(segment.scale(-d2));
			}
			alen += slen;
		});
		bcurves = bcurves.map(function(s$1) {
			p$1 = s$1.points;
			if (p$1[3]) s$1.points = [
				p$1[3],
				p$1[2],
				p$1[1],
				p$1[0]
			];
			else s$1.points = [
				p$1[2],
				p$1[1],
				p$1[0]
			];
			return s$1;
		}).reverse();
		const fs = fcurves[0].points[0], fe = fcurves[len - 1].points[fcurves[len - 1].points.length - 1], bs = bcurves[len - 1].points[bcurves[len - 1].points.length - 1], be = bcurves[0].points[0], ls = utils.makeline(bs, fs), le = utils.makeline(fe, be);
		return new PolyBezier([ls].concat(fcurves).concat([le]).concat(bcurves));
	}
	outlineshapes(d1, d2, curveIntersectionThreshold) {
		d2 = d2 || d1;
		const outline = this.outline(d1, d2).curves;
		const shapes = [];
		for (let i$1 = 1, len = outline.length; i$1 < len / 2; i$1++) {
			const shape = utils.makeshape(outline[i$1], outline[len - i$1], curveIntersectionThreshold);
			shape.startcap.virtual = i$1 > 1;
			shape.endcap.virtual = i$1 < len / 2 - 1;
			shapes.push(shape);
		}
		return shapes;
	}
	intersects(curve, curveIntersectionThreshold) {
		if (!curve) return this.selfintersects(curveIntersectionThreshold);
		if (curve.p1 && curve.p2) return this.lineIntersects(curve);
		if (curve instanceof Bezier) curve = curve.reduce();
		return this.curveintersects(this.reduce(), curve, curveIntersectionThreshold);
	}
	lineIntersects(line) {
		const mx = min$1(line.p1.x, line.p2.x), my = min$1(line.p1.y, line.p2.y), MX = max$1(line.p1.x, line.p2.x), MY = max$1(line.p1.y, line.p2.y);
		return utils.roots(this.points, line).filter((t$2) => {
			var p$1 = this.get(t$2);
			return utils.between(p$1.x, mx, MX) && utils.between(p$1.y, my, MY);
		});
	}
	selfintersects(curveIntersectionThreshold) {
		const reduced = this.reduce(), len = reduced.length - 2, results = [];
		for (let i$1 = 0, result, left, right; i$1 < len; i$1++) {
			left = reduced.slice(i$1, i$1 + 1);
			right = reduced.slice(i$1 + 2);
			result = this.curveintersects(left, right, curveIntersectionThreshold);
			results.push(...result);
		}
		return results;
	}
	curveintersects(c1, c2, curveIntersectionThreshold) {
		const pairs = [];
		c1.forEach(function(l$1) {
			c2.forEach(function(r$1) {
				if (l$1.overlaps(r$1)) pairs.push({
					left: l$1,
					right: r$1
				});
			});
		});
		let intersections = [];
		pairs.forEach(function(pair) {
			const result = utils.pairiteration(pair.left, pair.right, curveIntersectionThreshold);
			if (result.length > 0) intersections = intersections.concat(result);
		});
		return intersections;
	}
	arcs(errorThreshold) {
		errorThreshold = errorThreshold || .5;
		return this._iterate(errorThreshold, []);
	}
	_error(pc, np1, s$1, e$1) {
		const q$1 = (e$1 - s$1) / 4, c1 = this.get(s$1 + q$1), c2 = this.get(e$1 - q$1), ref = utils.dist(pc, np1), d1 = utils.dist(pc, c1), d2 = utils.dist(pc, c2);
		return abs(d1 - ref) + abs(d2 - ref);
	}
	_iterate(errorThreshold, circles) {
		let t_s = 0, t_e = 1, safety;
		do {
			safety = 0;
			t_e = 1;
			let np1 = this.get(t_s), np2, np3, arc, prev_arc;
			let curr_good = false, prev_good = false, done;
			let t_m = t_e, prev_e = 1, step = 0;
			do {
				prev_good = curr_good;
				prev_arc = arc;
				t_m = (t_s + t_e) / 2;
				step++;
				np2 = this.get(t_m);
				np3 = this.get(t_e);
				arc = utils.getccenter(np1, np2, np3);
				arc.interval = {
					start: t_s,
					end: t_e
				};
				curr_good = this._error(arc, np1, t_s, t_e) <= errorThreshold;
				done = prev_good && !curr_good;
				if (!done) prev_e = t_e;
				if (curr_good) {
					if (t_e >= 1) {
						arc.interval.end = prev_e = 1;
						prev_arc = arc;
						if (t_e > 1) {
							let d$1 = {
								x: arc.x + arc.r * cos(arc.e),
								y: arc.y + arc.r * sin(arc.e)
							};
							arc.e += utils.angle({
								x: arc.x,
								y: arc.y
							}, d$1, this.get(1));
						}
						break;
					}
					t_e = t_e + (t_e - t_s) / 2;
				} else t_e = t_m;
			} while (!done && safety++ < 100);
			if (safety >= 100) break;
			prev_arc = prev_arc ? prev_arc : arc;
			circles.push(prev_arc);
			t_s = prev_e;
		} while (t_e < 1);
		return circles;
	}
};

//#endregion
//#region node_modules/index-array-by/dist/index-array-by.mjs
function _arrayLikeToArray$1(r$1, a$2) {
	(null == a$2 || a$2 > r$1.length) && (a$2 = r$1.length);
	for (var e$1 = 0, n$1 = Array(a$2); e$1 < a$2; e$1++) n$1[e$1] = r$1[e$1];
	return n$1;
}
function _arrayWithHoles$1(r$1) {
	if (Array.isArray(r$1)) return r$1;
}
function _arrayWithoutHoles$1(r$1) {
	if (Array.isArray(r$1)) return _arrayLikeToArray$1(r$1);
}
function _iterableToArray$1(r$1) {
	if ("undefined" != typeof Symbol && null != r$1[Symbol.iterator] || null != r$1["@@iterator"]) return Array.from(r$1);
}
function _iterableToArrayLimit$1(r$1, l$1) {
	var t$2 = null == r$1 ? null : "undefined" != typeof Symbol && r$1[Symbol.iterator] || r$1["@@iterator"];
	if (null != t$2) {
		var e$1, n$1, i$1, u$1, a$2 = [], f$1 = !0, o$1 = !1;
		try {
			if (i$1 = (t$2 = t$2.call(r$1)).next, 0 === l$1);
			else for (; !(f$1 = (e$1 = i$1.call(t$2)).done) && (a$2.push(e$1.value), a$2.length !== l$1); f$1 = !0);
		} catch (r$2) {
			o$1 = !0, n$1 = r$2;
		} finally {
			try {
				if (!f$1 && null != t$2.return && (u$1 = t$2.return(), Object(u$1) !== u$1)) return;
			} finally {
				if (o$1) throw n$1;
			}
		}
		return a$2;
	}
}
function _nonIterableRest$1() {
	throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _nonIterableSpread$1() {
	throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _objectWithoutProperties(e$1, t$2) {
	if (null == e$1) return {};
	var o$1, r$1, i$1 = _objectWithoutPropertiesLoose(e$1, t$2);
	if (Object.getOwnPropertySymbols) {
		var s$1 = Object.getOwnPropertySymbols(e$1);
		for (r$1 = 0; r$1 < s$1.length; r$1++) o$1 = s$1[r$1], t$2.includes(o$1) || {}.propertyIsEnumerable.call(e$1, o$1) && (i$1[o$1] = e$1[o$1]);
	}
	return i$1;
}
function _objectWithoutPropertiesLoose(r$1, e$1) {
	if (null == r$1) return {};
	var t$2 = {};
	for (var n$1 in r$1) if ({}.hasOwnProperty.call(r$1, n$1)) {
		if (e$1.includes(n$1)) continue;
		t$2[n$1] = r$1[n$1];
	}
	return t$2;
}
function _slicedToArray$1(r$1, e$1) {
	return _arrayWithHoles$1(r$1) || _iterableToArrayLimit$1(r$1, e$1) || _unsupportedIterableToArray$1(r$1, e$1) || _nonIterableRest$1();
}
function _toConsumableArray$1(r$1) {
	return _arrayWithoutHoles$1(r$1) || _iterableToArray$1(r$1) || _unsupportedIterableToArray$1(r$1) || _nonIterableSpread$1();
}
function _toPrimitive$1(t$2, r$1) {
	if ("object" != typeof t$2 || !t$2) return t$2;
	var e$1 = t$2[Symbol.toPrimitive];
	if (void 0 !== e$1) {
		var i$1 = e$1.call(t$2, r$1);
		if ("object" != typeof i$1) return i$1;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return String(t$2);
}
function _toPropertyKey$1(t$2) {
	var i$1 = _toPrimitive$1(t$2, "string");
	return "symbol" == typeof i$1 ? i$1 : i$1 + "";
}
function _unsupportedIterableToArray$1(r$1, a$2) {
	if (r$1) {
		if ("string" == typeof r$1) return _arrayLikeToArray$1(r$1, a$2);
		var t$2 = {}.toString.call(r$1).slice(8, -1);
		return "Object" === t$2 && r$1.constructor && (t$2 = r$1.constructor.name), "Map" === t$2 || "Set" === t$2 ? Array.from(r$1) : "Arguments" === t$2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t$2) ? _arrayLikeToArray$1(r$1, a$2) : void 0;
	}
}
var index$4 = (function() {
	var list = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
	var keyAccessors = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
	var multiItem = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
	var flattenKeys = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
	var keys = (keyAccessors instanceof Array ? keyAccessors.length ? keyAccessors : [void 0] : [keyAccessors]).map(function(key) {
		return {
			keyAccessor: key,
			isProp: !(key instanceof Function)
		};
	});
	var indexedResult = list.reduce(function(res, item) {
		var iterObj = res;
		var itemVal = item;
		keys.forEach(function(_ref, idx) {
			var keyAccessor = _ref.keyAccessor, isProp = _ref.isProp;
			var key;
			if (isProp) {
				var _itemVal = itemVal, propVal = _itemVal[keyAccessor], rest = _objectWithoutProperties(_itemVal, [keyAccessor].map(_toPropertyKey$1));
				key = propVal;
				itemVal = rest;
			} else key = keyAccessor(itemVal, idx);
			if (idx + 1 < keys.length) {
				if (!iterObj.hasOwnProperty(key)) iterObj[key] = {};
				iterObj = iterObj[key];
			} else if (multiItem) {
				if (!iterObj.hasOwnProperty(key)) iterObj[key] = [];
				iterObj[key].push(itemVal);
			} else iterObj[key] = itemVal;
		});
		return res;
	}, {});
	if (multiItem instanceof Function) (function reduce(node) {
		var level = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
		if (level === keys.length) Object.keys(node).forEach(function(k$1) {
			return node[k$1] = multiItem(node[k$1]);
		});
		else Object.values(node).forEach(function(child) {
			return reduce(child, level + 1);
		});
	})(indexedResult);
	var result = indexedResult;
	if (flattenKeys) {
		result = [];
		(function flatten(node) {
			var accKeys = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
			if (accKeys.length === keys.length) result.push({
				keys: accKeys,
				vals: node
			});
			else Object.entries(node).forEach(function(_ref2) {
				var _ref3 = _slicedToArray$1(_ref2, 2), key = _ref3[0], val = _ref3[1];
				return flatten(val, [].concat(_toConsumableArray$1(accKeys), [key]));
			});
		})(indexedResult);
		if (keyAccessors instanceof Array && keyAccessors.length === 0 && result.length === 1) result[0].keys = [];
	}
	return result;
});

//#endregion
//#region node_modules/d3-scale/src/init.js
function initRange(domain, range) {
	switch (arguments.length) {
		case 0: break;
		case 1:
			this.range(domain);
			break;
		default:
			this.range(range).domain(domain);
			break;
	}
	return this;
}

//#endregion
//#region node_modules/d3-scale/src/ordinal.js
const implicit = Symbol("implicit");
function ordinal() {
	var index$6 = new InternMap(), domain = [], range = [], unknown = implicit;
	function scale(d$1) {
		let i$1 = index$6.get(d$1);
		if (i$1 === void 0) {
			if (unknown !== implicit) return unknown;
			index$6.set(d$1, i$1 = domain.push(d$1) - 1);
		}
		return range[i$1 % range.length];
	}
	scale.domain = function(_$1) {
		if (!arguments.length) return domain.slice();
		domain = [], index$6 = new InternMap();
		for (const value of _$1) {
			if (index$6.has(value)) continue;
			index$6.set(value, domain.push(value) - 1);
		}
		return scale;
	};
	scale.range = function(_$1) {
		return arguments.length ? (range = Array.from(_$1), scale) : range.slice();
	};
	scale.unknown = function(_$1) {
		return arguments.length ? (unknown = _$1, scale) : unknown;
	};
	scale.copy = function() {
		return ordinal(domain, range).unknown(unknown);
	};
	initRange.apply(scale, arguments);
	return scale;
}

//#endregion
//#region node_modules/d3-scale-chromatic/src/colors.js
function colors_default(specifier) {
	var n$1 = specifier.length / 6 | 0, colors = new Array(n$1), i$1 = 0;
	while (i$1 < n$1) colors[i$1] = "#" + specifier.slice(i$1 * 6, ++i$1 * 6);
	return colors;
}

//#endregion
//#region node_modules/d3-scale-chromatic/src/categorical/Paired.js
var Paired_default = colors_default("a6cee31f78b4b2df8a33a02cfb9a99e31a1cfdbf6fff7f00cab2d66a3d9affff99b15928");

//#endregion
//#region node_modules/force-graph/dist/force-graph.mjs
function styleInject(css, ref) {
	if (ref === void 0) ref = {};
	var insertAt = ref.insertAt;
	if (typeof document === "undefined") return;
	var head = document.head || document.getElementsByTagName("head")[0];
	var style = document.createElement("style");
	style.type = "text/css";
	if (insertAt === "top") if (head.firstChild) head.insertBefore(style, head.firstChild);
	else head.appendChild(style);
	else head.appendChild(style);
	if (style.styleSheet) style.styleSheet.cssText = css;
	else style.appendChild(document.createTextNode(css));
}
styleInject(".force-graph-container canvas {\n  display: block;\n  user-select: none;\n  outline: none;\n  -webkit-tap-highlight-color: transparent;\n}\n\n.force-graph-container .clickable {\n  cursor: pointer;\n}\n\n.force-graph-container .grabbable {\n  cursor: move;\n  cursor: grab;\n  cursor: -moz-grab;\n  cursor: -webkit-grab;\n}\n\n.force-graph-container .grabbable:active {\n  cursor: grabbing;\n  cursor: -moz-grabbing;\n  cursor: -webkit-grabbing;\n}\n");
function _arrayLikeToArray(r$1, a$2) {
	(null == a$2 || a$2 > r$1.length) && (a$2 = r$1.length);
	for (var e$1 = 0, n$1 = Array(a$2); e$1 < a$2; e$1++) n$1[e$1] = r$1[e$1];
	return n$1;
}
function _arrayWithHoles(r$1) {
	if (Array.isArray(r$1)) return r$1;
}
function _arrayWithoutHoles(r$1) {
	if (Array.isArray(r$1)) return _arrayLikeToArray(r$1);
}
function _construct(t$2, e$1, r$1) {
	if (_isNativeReflectConstruct()) return Reflect.construct.apply(null, arguments);
	var o$1 = [null];
	o$1.push.apply(o$1, e$1);
	return new (t$2.bind.apply(t$2, o$1))();
}
function _defineProperty(e$1, r$1, t$2) {
	return (r$1 = _toPropertyKey(r$1)) in e$1 ? Object.defineProperty(e$1, r$1, {
		value: t$2,
		enumerable: true,
		configurable: true,
		writable: true
	}) : e$1[r$1] = t$2, e$1;
}
function _isNativeReflectConstruct() {
	try {
		var t$2 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
	} catch (t$3) {}
	return (_isNativeReflectConstruct = function() {
		return !!t$2;
	})();
}
function _iterableToArray(r$1) {
	if ("undefined" != typeof Symbol && null != r$1[Symbol.iterator] || null != r$1["@@iterator"]) return Array.from(r$1);
}
function _iterableToArrayLimit(r$1, l$1) {
	var t$2 = null == r$1 ? null : "undefined" != typeof Symbol && r$1[Symbol.iterator] || r$1["@@iterator"];
	if (null != t$2) {
		var e$1, n$1, i$1, u$1, a$2 = [], f$1 = true, o$1 = false;
		try {
			if (i$1 = (t$2 = t$2.call(r$1)).next, 0 === l$1);
			else for (; !(f$1 = (e$1 = i$1.call(t$2)).done) && (a$2.push(e$1.value), a$2.length !== l$1); f$1 = !0);
		} catch (r$2) {
			o$1 = true, n$1 = r$2;
		} finally {
			try {
				if (!f$1 && null != t$2.return && (u$1 = t$2.return(), Object(u$1) !== u$1)) return;
			} finally {
				if (o$1) throw n$1;
			}
		}
		return a$2;
	}
}
function _nonIterableRest() {
	throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _nonIterableSpread() {
	throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function ownKeys(e$1, r$1) {
	var t$2 = Object.keys(e$1);
	if (Object.getOwnPropertySymbols) {
		var o$1 = Object.getOwnPropertySymbols(e$1);
		r$1 && (o$1 = o$1.filter(function(r$2) {
			return Object.getOwnPropertyDescriptor(e$1, r$2).enumerable;
		})), t$2.push.apply(t$2, o$1);
	}
	return t$2;
}
function _objectSpread2(e$1) {
	for (var r$1 = 1; r$1 < arguments.length; r$1++) {
		var t$2 = null != arguments[r$1] ? arguments[r$1] : {};
		r$1 % 2 ? ownKeys(Object(t$2), true).forEach(function(r$2) {
			_defineProperty(e$1, r$2, t$2[r$2]);
		}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e$1, Object.getOwnPropertyDescriptors(t$2)) : ownKeys(Object(t$2)).forEach(function(r$2) {
			Object.defineProperty(e$1, r$2, Object.getOwnPropertyDescriptor(t$2, r$2));
		});
	}
	return e$1;
}
function _slicedToArray(r$1, e$1) {
	return _arrayWithHoles(r$1) || _iterableToArrayLimit(r$1, e$1) || _unsupportedIterableToArray(r$1, e$1) || _nonIterableRest();
}
function _toConsumableArray(r$1) {
	return _arrayWithoutHoles(r$1) || _iterableToArray(r$1) || _unsupportedIterableToArray(r$1) || _nonIterableSpread();
}
function _toPrimitive(t$2, r$1) {
	if ("object" != typeof t$2 || !t$2) return t$2;
	var e$1 = t$2[Symbol.toPrimitive];
	if (void 0 !== e$1) {
		var i$1 = e$1.call(t$2, r$1);
		if ("object" != typeof i$1) return i$1;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return ("string" === r$1 ? String : Number)(t$2);
}
function _toPropertyKey(t$2) {
	var i$1 = _toPrimitive(t$2, "string");
	return "symbol" == typeof i$1 ? i$1 : i$1 + "";
}
function _typeof(o$1) {
	"@babel/helpers - typeof";
	return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o$2) {
		return typeof o$2;
	} : function(o$2) {
		return o$2 && "function" == typeof Symbol && o$2.constructor === Symbol && o$2 !== Symbol.prototype ? "symbol" : typeof o$2;
	}, _typeof(o$1);
}
function _unsupportedIterableToArray(r$1, a$2) {
	if (r$1) {
		if ("string" == typeof r$1) return _arrayLikeToArray(r$1, a$2);
		var t$2 = {}.toString.call(r$1).slice(8, -1);
		return "Object" === t$2 && r$1.constructor && (t$2 = r$1.constructor.name), "Map" === t$2 || "Set" === t$2 ? Array.from(r$1) : "Arguments" === t$2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t$2) ? _arrayLikeToArray(r$1, a$2) : void 0;
	}
}
var autoColorScale = ordinal(Paired_default);
function autoColorObjects(objects, colorByAccessor, colorField) {
	if (!colorByAccessor || typeof colorField !== "string") return;
	objects.filter(function(obj) {
		return !obj[colorField];
	}).forEach(function(obj) {
		obj[colorField] = autoColorScale(colorByAccessor(obj));
	});
}
function getDagDepths(_ref, idAccessor) {
	var nodes = _ref.nodes, links = _ref.links;
	var _ref2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, _ref2$nodeFilter = _ref2.nodeFilter, nodeFilter = _ref2$nodeFilter === void 0 ? function() {
		return true;
	} : _ref2$nodeFilter, _ref2$onLoopError = _ref2.onLoopError, onLoopError = _ref2$onLoopError === void 0 ? function(loopIds) {
		throw "Invalid DAG structure! Found cycle in node path: ".concat(loopIds.join(" -> "), ".");
	} : _ref2$onLoopError;
	var graph = {};
	nodes.forEach(function(node) {
		return graph[idAccessor(node)] = {
			data: node,
			out: [],
			depth: -1,
			skip: !nodeFilter(node)
		};
	});
	links.forEach(function(_ref3) {
		var source = _ref3.source, target = _ref3.target;
		var sourceId = getNodeId(source);
		var targetId = getNodeId(target);
		if (!graph.hasOwnProperty(sourceId)) throw "Missing source node with id: ".concat(sourceId);
		if (!graph.hasOwnProperty(targetId)) throw "Missing target node with id: ".concat(targetId);
		var sourceNode = graph[sourceId];
		var targetNode = graph[targetId];
		sourceNode.out.push(targetNode);
		function getNodeId(node) {
			return _typeof(node) === "object" ? idAccessor(node) : node;
		}
	});
	var foundLoops = [];
	traverse(Object.values(graph));
	return Object.assign.apply(Object, [{}].concat(_toConsumableArray(Object.entries(graph).filter(function(_ref4) {
		return !_slicedToArray(_ref4, 2)[1].skip;
	}).map(function(_ref6) {
		var _ref7 = _slicedToArray(_ref6, 2), id$1 = _ref7[0], node = _ref7[1];
		return _defineProperty({}, id$1, node.depth);
	}))));
	function traverse(nodes$1) {
		var nodeStack = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
		var currentDepth = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
		var _loop = function _loop$1() {
			var node = nodes$1[i$1];
			if (nodeStack.indexOf(node) !== -1) {
				var loop = [].concat(_toConsumableArray(nodeStack.slice(nodeStack.indexOf(node))), [node]).map(function(d$1) {
					return idAccessor(d$1.data);
				});
				if (!foundLoops.some(function(foundLoop) {
					return foundLoop.length === loop.length && foundLoop.every(function(id$1, idx) {
						return id$1 === loop[idx];
					});
				})) {
					foundLoops.push(loop);
					onLoopError(loop);
				}
				return 1;
			}
			if (currentDepth > node.depth) {
				node.depth = currentDepth;
				traverse(node.out, [].concat(_toConsumableArray(nodeStack), [node]), currentDepth + (node.skip ? 0 : 1));
			}
		};
		for (var i$1 = 0, l$1 = nodes$1.length; i$1 < l$1; i$1++) if (_loop()) continue;
	}
}
var DAG_LEVEL_NODE_RATIO = 2;
var notifyRedraw = function notifyRedraw$1(_$1, state) {
	return state.onNeedsRedraw && state.onNeedsRedraw();
};
var updDataPhotons = function updDataPhotons$1(_$1, state) {
	if (!state.isShadow) {
		var linkParticlesAccessor = index$2(state.linkDirectionalParticles);
		state.graphData.links.forEach(function(link) {
			var numPhotons = Math.round(Math.abs(linkParticlesAccessor(link)));
			if (numPhotons) link.__photons = _toConsumableArray(Array(numPhotons)).map(function() {
				return {};
			});
			else delete link.__photons;
		});
	}
};
var CanvasForceGraph = index$1({
	props: {
		graphData: {
			"default": {
				nodes: [],
				links: []
			},
			onChange: function onChange(_$1, state) {
				state.engineRunning = false;
				updDataPhotons(_$1, state);
			}
		},
		dagMode: { onChange: function onChange(dagMode, state) {
			!dagMode && (state.graphData.nodes || []).forEach(function(n$1) {
				n$1.fx = n$1.fy = void 0;
			});
		} },
		dagLevelDistance: {},
		dagNodeFilter: { "default": function _default$1(node) {
			return true;
		} },
		onDagError: { triggerUpdate: false },
		nodeRelSize: {
			"default": 4,
			triggerUpdate: false,
			onChange: notifyRedraw
		},
		nodeId: { "default": "id" },
		nodeVal: {
			"default": "val",
			triggerUpdate: false,
			onChange: notifyRedraw
		},
		nodeColor: {
			"default": "color",
			triggerUpdate: false,
			onChange: notifyRedraw
		},
		nodeAutoColorBy: {},
		nodeCanvasObject: {
			triggerUpdate: false,
			onChange: notifyRedraw
		},
		nodeCanvasObjectMode: {
			"default": function _default$1() {
				return "replace";
			},
			triggerUpdate: false,
			onChange: notifyRedraw
		},
		nodeVisibility: {
			"default": true,
			triggerUpdate: false,
			onChange: notifyRedraw
		},
		linkSource: { "default": "source" },
		linkTarget: { "default": "target" },
		linkVisibility: {
			"default": true,
			triggerUpdate: false,
			onChange: notifyRedraw
		},
		linkColor: {
			"default": "color",
			triggerUpdate: false,
			onChange: notifyRedraw
		},
		linkAutoColorBy: {},
		linkLineDash: {
			triggerUpdate: false,
			onChange: notifyRedraw
		},
		linkWidth: {
			"default": 1,
			triggerUpdate: false,
			onChange: notifyRedraw
		},
		linkCurvature: {
			"default": 0,
			triggerUpdate: false,
			onChange: notifyRedraw
		},
		linkCanvasObject: {
			triggerUpdate: false,
			onChange: notifyRedraw
		},
		linkCanvasObjectMode: {
			"default": function _default$1() {
				return "replace";
			},
			triggerUpdate: false,
			onChange: notifyRedraw
		},
		linkDirectionalArrowLength: {
			"default": 0,
			triggerUpdate: false,
			onChange: notifyRedraw
		},
		linkDirectionalArrowColor: {
			triggerUpdate: false,
			onChange: notifyRedraw
		},
		linkDirectionalArrowRelPos: {
			"default": .5,
			triggerUpdate: false,
			onChange: notifyRedraw
		},
		linkDirectionalParticles: {
			"default": 0,
			triggerUpdate: false,
			onChange: updDataPhotons
		},
		linkDirectionalParticleSpeed: {
			"default": .01,
			triggerUpdate: false
		},
		linkDirectionalParticleOffset: {
			"default": 0,
			triggerUpdate: false
		},
		linkDirectionalParticleWidth: {
			"default": 4,
			triggerUpdate: false
		},
		linkDirectionalParticleColor: { triggerUpdate: false },
		linkDirectionalParticleCanvasObject: { triggerUpdate: false },
		globalScale: {
			"default": 1,
			triggerUpdate: false
		},
		d3AlphaMin: {
			"default": 0,
			triggerUpdate: false
		},
		d3AlphaDecay: {
			"default": .0228,
			triggerUpdate: false,
			onChange: function onChange(alphaDecay, state) {
				state.forceLayout.alphaDecay(alphaDecay);
			}
		},
		d3AlphaTarget: {
			"default": 0,
			triggerUpdate: false,
			onChange: function onChange(alphaTarget, state) {
				state.forceLayout.alphaTarget(alphaTarget);
			}
		},
		d3VelocityDecay: {
			"default": .4,
			triggerUpdate: false,
			onChange: function onChange(velocityDecay, state) {
				state.forceLayout.velocityDecay(velocityDecay);
			}
		},
		warmupTicks: {
			"default": 0,
			triggerUpdate: false
		},
		cooldownTicks: {
			"default": Infinity,
			triggerUpdate: false
		},
		cooldownTime: {
			"default": 15e3,
			triggerUpdate: false
		},
		onUpdate: {
			"default": function _default$1() {},
			triggerUpdate: false
		},
		onFinishUpdate: {
			"default": function _default$1() {},
			triggerUpdate: false
		},
		onEngineTick: {
			"default": function _default$1() {},
			triggerUpdate: false
		},
		onEngineStop: {
			"default": function _default$1() {},
			triggerUpdate: false
		},
		onNeedsRedraw: { triggerUpdate: false },
		isShadow: {
			"default": false,
			triggerUpdate: false
		}
	},
	methods: {
		d3Force: function d3Force(state, forceName, forceFn) {
			if (forceFn === void 0) return state.forceLayout.force(forceName);
			state.forceLayout.force(forceName, forceFn);
			return this;
		},
		d3ReheatSimulation: function d3ReheatSimulation(state) {
			state.forceLayout.alpha(1);
			this.resetCountdown();
			return this;
		},
		resetCountdown: function resetCountdown(state) {
			state.cntTicks = 0;
			state.startTickTime = /* @__PURE__ */ new Date();
			state.engineRunning = true;
			return this;
		},
		isEngineRunning: function isEngineRunning(state) {
			return !!state.engineRunning;
		},
		tickFrame: function tickFrame(state) {
			!state.isShadow && layoutTick();
			paintLinks();
			!state.isShadow && paintArrows();
			!state.isShadow && paintPhotons();
			paintNodes();
			return this;
			function layoutTick() {
				if (state.engineRunning) if (++state.cntTicks > state.cooldownTicks || /* @__PURE__ */ new Date() - state.startTickTime > state.cooldownTime || state.d3AlphaMin > 0 && state.forceLayout.alpha() < state.d3AlphaMin) {
					state.engineRunning = false;
					state.onEngineStop();
				} else {
					state.forceLayout.tick();
					state.onEngineTick();
				}
			}
			function paintNodes() {
				var getVisibility = index$2(state.nodeVisibility);
				var getVal = index$2(state.nodeVal);
				var getColor = index$2(state.nodeColor);
				var getNodeCanvasObjectMode = index$2(state.nodeCanvasObjectMode);
				var ctx = state.ctx;
				var padAmount = state.isShadow / state.globalScale;
				var visibleNodes = state.graphData.nodes.filter(getVisibility);
				ctx.save();
				visibleNodes.forEach(function(node) {
					var nodeCanvasObjectMode = getNodeCanvasObjectMode(node);
					if (state.nodeCanvasObject && (nodeCanvasObjectMode === "before" || nodeCanvasObjectMode === "replace")) {
						state.nodeCanvasObject(node, ctx, state.globalScale);
						if (nodeCanvasObjectMode === "replace") {
							ctx.restore();
							return;
						}
					}
					var r$1 = Math.sqrt(Math.max(0, getVal(node) || 1)) * state.nodeRelSize + padAmount;
					ctx.beginPath();
					ctx.arc(node.x, node.y, r$1, 0, 2 * Math.PI, false);
					ctx.fillStyle = getColor(node) || "rgba(31, 120, 180, 0.92)";
					ctx.fill();
					if (state.nodeCanvasObject && nodeCanvasObjectMode === "after") state.nodeCanvasObject(node, state.ctx, state.globalScale);
				});
				ctx.restore();
			}
			function paintLinks() {
				var getVisibility = index$2(state.linkVisibility);
				var getColor = index$2(state.linkColor);
				var getWidth = index$2(state.linkWidth);
				var getLineDash = index$2(state.linkLineDash);
				var getCurvature = index$2(state.linkCurvature);
				var getLinkCanvasObjectMode = index$2(state.linkCanvasObjectMode);
				var ctx = state.ctx;
				var padAmount = state.isShadow * 2;
				var visibleLinks = state.graphData.links.filter(getVisibility);
				visibleLinks.forEach(calcLinkControlPoints);
				var beforeCustomLinks = [], afterCustomLinks = [], defaultPaintLinks = visibleLinks;
				if (state.linkCanvasObject) {
					var replaceCustomLinks = [], otherCustomLinks = [];
					visibleLinks.forEach(function(d$1) {
						return ({
							before: beforeCustomLinks,
							after: afterCustomLinks,
							replace: replaceCustomLinks
						}[getLinkCanvasObjectMode(d$1)] || otherCustomLinks).push(d$1);
					});
					defaultPaintLinks = [].concat(_toConsumableArray(beforeCustomLinks), afterCustomLinks, otherCustomLinks);
					beforeCustomLinks = beforeCustomLinks.concat(replaceCustomLinks);
				}
				ctx.save();
				beforeCustomLinks.forEach(function(link) {
					return state.linkCanvasObject(link, ctx, state.globalScale);
				});
				ctx.restore();
				var linksPerColor = index$4(defaultPaintLinks, [
					getColor,
					getWidth,
					getLineDash
				]);
				ctx.save();
				Object.entries(linksPerColor).forEach(function(_ref) {
					var _ref2 = _slicedToArray(_ref, 2), color$1 = _ref2[0], linksPerWidth = _ref2[1];
					var lineColor = !color$1 || color$1 === "undefined" ? "rgba(0,0,0,0.15)" : color$1;
					Object.entries(linksPerWidth).forEach(function(_ref3) {
						var _ref4 = _slicedToArray(_ref3, 2), width = _ref4[0], linesPerLineDash = _ref4[1];
						var lineWidth = (width || 1) / state.globalScale + padAmount;
						Object.entries(linesPerLineDash).forEach(function(_ref5) {
							var _ref6 = _slicedToArray(_ref5, 2);
							_ref6[0];
							var links = _ref6[1];
							var lineDashSegments = getLineDash(links[0]);
							ctx.beginPath();
							links.forEach(function(link) {
								var start$1 = link.source;
								var end = link.target;
								if (!start$1 || !end || !start$1.hasOwnProperty("x") || !end.hasOwnProperty("x")) return;
								ctx.moveTo(start$1.x, start$1.y);
								var controlPoints = link.__controlPoints;
								if (!controlPoints) ctx.lineTo(end.x, end.y);
								else ctx[controlPoints.length === 2 ? "quadraticCurveTo" : "bezierCurveTo"].apply(ctx, _toConsumableArray(controlPoints).concat([end.x, end.y]));
							});
							ctx.strokeStyle = lineColor;
							ctx.lineWidth = lineWidth;
							ctx.setLineDash(lineDashSegments || []);
							ctx.stroke();
						});
					});
				});
				ctx.restore();
				ctx.save();
				afterCustomLinks.forEach(function(link) {
					return state.linkCanvasObject(link, ctx, state.globalScale);
				});
				ctx.restore();
				function calcLinkControlPoints(link) {
					var curvature = getCurvature(link);
					if (!curvature) {
						link.__controlPoints = null;
						return;
					}
					var start$1 = link.source;
					var end = link.target;
					if (!start$1 || !end || !start$1.hasOwnProperty("x") || !end.hasOwnProperty("x")) return;
					var l$1 = Math.sqrt(Math.pow(end.x - start$1.x, 2) + Math.pow(end.y - start$1.y, 2));
					if (l$1 > 0) {
						var a$2 = Math.atan2(end.y - start$1.y, end.x - start$1.x);
						var d$1 = l$1 * curvature;
						var cp = {
							x: (start$1.x + end.x) / 2 + d$1 * Math.cos(a$2 - Math.PI / 2),
							y: (start$1.y + end.y) / 2 + d$1 * Math.sin(a$2 - Math.PI / 2)
						};
						link.__controlPoints = [cp.x, cp.y];
					} else {
						var _d = curvature * 70;
						link.__controlPoints = [
							end.x,
							end.y - _d,
							end.x + _d,
							end.y
						];
					}
				}
			}
			function paintArrows() {
				var ARROW_WH_RATIO = 1.6;
				var ARROW_VLEN_RATIO = .2;
				var getLength = index$2(state.linkDirectionalArrowLength);
				var getRelPos = index$2(state.linkDirectionalArrowRelPos);
				var getVisibility = index$2(state.linkVisibility);
				var getColor = index$2(state.linkDirectionalArrowColor || state.linkColor);
				var getNodeVal = index$2(state.nodeVal);
				var ctx = state.ctx;
				ctx.save();
				state.graphData.links.filter(getVisibility).forEach(function(link) {
					var arrowLength = getLength(link);
					if (!arrowLength || arrowLength < 0) return;
					var start$1 = link.source;
					var end = link.target;
					if (!start$1 || !end || !start$1.hasOwnProperty("x") || !end.hasOwnProperty("x")) return;
					var startR = Math.sqrt(Math.max(0, getNodeVal(start$1) || 1)) * state.nodeRelSize;
					var endR = Math.sqrt(Math.max(0, getNodeVal(end) || 1)) * state.nodeRelSize;
					var arrowRelPos = Math.min(1, Math.max(0, getRelPos(link)));
					var arrowColor = getColor(link) || "rgba(0,0,0,0.28)";
					var arrowHalfWidth = arrowLength / ARROW_WH_RATIO / 2;
					var bzLine = link.__controlPoints && _construct(Bezier, [start$1.x, start$1.y].concat(_toConsumableArray(link.__controlPoints), [end.x, end.y]));
					var getCoordsAlongLine = bzLine ? function(t$2) {
						return bzLine.get(t$2);
					} : function(t$2) {
						return {
							x: start$1.x + (end.x - start$1.x) * t$2 || 0,
							y: start$1.y + (end.y - start$1.y) * t$2 || 0
						};
					};
					var lineLen = bzLine ? bzLine.length() : Math.sqrt(Math.pow(end.x - start$1.x, 2) + Math.pow(end.y - start$1.y, 2));
					var posAlongLine = startR + arrowLength + (lineLen - startR - endR - arrowLength) * arrowRelPos;
					var arrowHead = getCoordsAlongLine(posAlongLine / lineLen);
					var arrowTail = getCoordsAlongLine((posAlongLine - arrowLength) / lineLen);
					var arrowTailVertex = getCoordsAlongLine((posAlongLine - arrowLength * (1 - ARROW_VLEN_RATIO)) / lineLen);
					var arrowTailAngle = Math.atan2(arrowHead.y - arrowTail.y, arrowHead.x - arrowTail.x) - Math.PI / 2;
					ctx.beginPath();
					ctx.moveTo(arrowHead.x, arrowHead.y);
					ctx.lineTo(arrowTail.x + arrowHalfWidth * Math.cos(arrowTailAngle), arrowTail.y + arrowHalfWidth * Math.sin(arrowTailAngle));
					ctx.lineTo(arrowTailVertex.x, arrowTailVertex.y);
					ctx.lineTo(arrowTail.x - arrowHalfWidth * Math.cos(arrowTailAngle), arrowTail.y - arrowHalfWidth * Math.sin(arrowTailAngle));
					ctx.fillStyle = arrowColor;
					ctx.fill();
				});
				ctx.restore();
			}
			function paintPhotons() {
				var getNumPhotons = index$2(state.linkDirectionalParticles);
				var getSpeed = index$2(state.linkDirectionalParticleSpeed);
				var getOffset = index$2(state.linkDirectionalParticleOffset);
				var getDiameter = index$2(state.linkDirectionalParticleWidth);
				var getVisibility = index$2(state.linkVisibility);
				var getColor = index$2(state.linkDirectionalParticleColor || state.linkColor);
				var ctx = state.ctx;
				ctx.save();
				state.graphData.links.filter(getVisibility).forEach(function(link) {
					var numCyclePhotons = getNumPhotons(link);
					if (!link.hasOwnProperty("__photons") || !link.__photons.length) return;
					var start$1 = link.source;
					var end = link.target;
					if (!start$1 || !end || !start$1.hasOwnProperty("x") || !end.hasOwnProperty("x")) return;
					var particleSpeed = getSpeed(link);
					var particleOffset = Math.abs(getOffset(link));
					var photons = link.__photons || [];
					var photonR = Math.max(0, getDiameter(link) / 2) / Math.sqrt(state.globalScale);
					ctx.fillStyle = getColor(link) || "rgba(0,0,0,0.28)";
					var bzLine = link.__controlPoints ? _construct(Bezier, [start$1.x, start$1.y].concat(_toConsumableArray(link.__controlPoints), [end.x, end.y])) : null;
					var cyclePhotonIdx = 0;
					var needsCleanup = false;
					photons.forEach(function(photon) {
						var singleHop = !!photon.__singleHop;
						if (!photon.hasOwnProperty("__progressRatio")) photon.__progressRatio = singleHop ? 0 : (cyclePhotonIdx + particleOffset) / numCyclePhotons;
						!singleHop && cyclePhotonIdx++;
						photon.__progressRatio += particleSpeed;
						if (photon.__progressRatio >= 1) if (!singleHop) photon.__progressRatio = photon.__progressRatio % 1;
						else {
							needsCleanup = true;
							return;
						}
						var photonPosRatio = photon.__progressRatio;
						var coords = bzLine ? bzLine.get(photonPosRatio) : {
							x: start$1.x + (end.x - start$1.x) * photonPosRatio || 0,
							y: start$1.y + (end.y - start$1.y) * photonPosRatio || 0
						};
						if (state.linkDirectionalParticleCanvasObject) state.linkDirectionalParticleCanvasObject(coords.x, coords.y, link, ctx, state.globalScale);
						else {
							ctx.beginPath();
							ctx.arc(coords.x, coords.y, photonR, 0, 2 * Math.PI, false);
							ctx.fill();
						}
					});
					if (needsCleanup) link.__photons = link.__photons.filter(function(photon) {
						return !photon.__singleHop || photon.__progressRatio <= 1;
					});
				});
				ctx.restore();
			}
		},
		emitParticle: function emitParticle(state, link) {
			if (link) {
				!link.__photons && (link.__photons = []);
				link.__photons.push({ __singleHop: true });
			}
			return this;
		}
	},
	stateInit: function stateInit() {
		return {
			forceLayout: simulation_default().force("link", link_default()).force("charge", manyBody_default()).force("center", center_default()).force("dagRadial", null).stop(),
			engineRunning: false
		};
	},
	init: function init$1(canvasCtx, state) {
		state.ctx = canvasCtx;
	},
	update: function update$1(state, changedProps) {
		state.engineRunning = false;
		state.onUpdate();
		if (state.nodeAutoColorBy !== null) autoColorObjects(state.graphData.nodes, index$2(state.nodeAutoColorBy), state.nodeColor);
		if (state.linkAutoColorBy !== null) autoColorObjects(state.graphData.links, index$2(state.linkAutoColorBy), state.linkColor);
		state.graphData.links.forEach(function(link) {
			link.source = link[state.linkSource];
			link.target = link[state.linkTarget];
		});
		state.forceLayout.stop().alpha(1).nodes(state.graphData.nodes);
		var linkForce = state.forceLayout.force("link");
		if (linkForce) linkForce.id(function(d$1) {
			return d$1[state.nodeId];
		}).links(state.graphData.links);
		var nodeDepths = state.dagMode && getDagDepths(state.graphData, function(node) {
			return node[state.nodeId];
		}, {
			nodeFilter: state.dagNodeFilter,
			onLoopError: state.onDagError || void 0
		});
		var maxDepth = Math.max.apply(Math, _toConsumableArray(Object.values(nodeDepths || [])));
		var dagLevelDistance = state.dagLevelDistance || state.graphData.nodes.length / (maxDepth || 1) * DAG_LEVEL_NODE_RATIO * (["radialin", "radialout"].indexOf(state.dagMode) !== -1 ? .7 : 1);
		if ([
			"lr",
			"rl",
			"td",
			"bu"
		].includes(changedProps.dagMode)) {
			var resetProp = ["lr", "rl"].includes(changedProps.dagMode) ? "fx" : "fy";
			state.graphData.nodes.filter(state.dagNodeFilter).forEach(function(node) {
				return delete node[resetProp];
			});
		}
		if ([
			"lr",
			"rl",
			"td",
			"bu"
		].includes(state.dagMode)) {
			var invert = ["rl", "bu"].includes(state.dagMode);
			var fixFn = function fixFn$1(node) {
				return (nodeDepths[node[state.nodeId]] - maxDepth / 2) * dagLevelDistance * (invert ? -1 : 1);
			};
			var _resetProp = ["lr", "rl"].includes(state.dagMode) ? "fx" : "fy";
			state.graphData.nodes.filter(state.dagNodeFilter).forEach(function(node) {
				return node[_resetProp] = fixFn(node);
			});
		}
		state.forceLayout.force("dagRadial", ["radialin", "radialout"].indexOf(state.dagMode) !== -1 ? radial_default(function(node) {
			var nodeDepth = nodeDepths[node[state.nodeId]] || -1;
			return (state.dagMode === "radialin" ? maxDepth - nodeDepth : nodeDepth) * dagLevelDistance;
		}).strength(function(node) {
			return state.dagNodeFilter(node) ? 1 : 0;
		}) : null);
		for (var i$1 = 0; i$1 < state.warmupTicks && !(state.d3AlphaMin > 0 && state.forceLayout.alpha() < state.d3AlphaMin); i$1++) state.forceLayout.tick();
		this.resetCountdown();
		state.onFinishUpdate();
	}
});
function linkKapsule(kapsulePropNames, kapsuleType) {
	var propNames = kapsulePropNames instanceof Array ? kapsulePropNames : [kapsulePropNames];
	var dummyK = new kapsuleType();
	dummyK._destructor && dummyK._destructor();
	return {
		linkProp: function linkProp(prop) {
			return {
				"default": dummyK[prop](),
				onChange: function onChange(v$1, state) {
					propNames.forEach(function(propName) {
						return state[propName][prop](v$1);
					});
				},
				triggerUpdate: false
			};
		},
		linkMethod: function linkMethod(method) {
			return function(state) {
				for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) args[_key - 1] = arguments[_key];
				var returnVals = [];
				propNames.forEach(function(propName) {
					var kapsuleInstance = state[propName];
					var returnVal = kapsuleInstance[method].apply(kapsuleInstance, args);
					if (returnVal !== kapsuleInstance) returnVals.push(returnVal);
				});
				return returnVals.length ? returnVals[0] : this;
			};
		}
	};
}
var HOVER_CANVAS_THROTTLE_DELAY = 800;
var ZOOM2NODES_FACTOR = 4;
var DRAG_CLICK_TOLERANCE_PX = 5;
var bindFG = linkKapsule("forceGraph", CanvasForceGraph);
var bindBoth = linkKapsule(["forceGraph", "shadowGraph"], CanvasForceGraph);
var linkedProps = Object.assign.apply(Object, _toConsumableArray([
	"nodeColor",
	"nodeAutoColorBy",
	"nodeCanvasObject",
	"nodeCanvasObjectMode",
	"linkColor",
	"linkAutoColorBy",
	"linkLineDash",
	"linkWidth",
	"linkCanvasObject",
	"linkCanvasObjectMode",
	"linkDirectionalArrowLength",
	"linkDirectionalArrowColor",
	"linkDirectionalArrowRelPos",
	"linkDirectionalParticles",
	"linkDirectionalParticleSpeed",
	"linkDirectionalParticleOffset",
	"linkDirectionalParticleWidth",
	"linkDirectionalParticleColor",
	"linkDirectionalParticleCanvasObject",
	"dagMode",
	"dagLevelDistance",
	"dagNodeFilter",
	"onDagError",
	"d3AlphaMin",
	"d3AlphaDecay",
	"d3VelocityDecay",
	"warmupTicks",
	"cooldownTicks",
	"cooldownTime",
	"onEngineTick",
	"onEngineStop"
].map(function(p$1) {
	return _defineProperty({}, p$1, bindFG.linkProp(p$1));
})).concat(_toConsumableArray([
	"nodeRelSize",
	"nodeId",
	"nodeVal",
	"nodeVisibility",
	"linkSource",
	"linkTarget",
	"linkVisibility",
	"linkCurvature"
].map(function(p$1) {
	return _defineProperty({}, p$1, bindBoth.linkProp(p$1));
}))));
var linkedMethods = Object.assign.apply(Object, _toConsumableArray([
	"d3Force",
	"d3ReheatSimulation",
	"emitParticle"
].map(function(p$1) {
	return _defineProperty({}, p$1, bindFG.linkMethod(p$1));
})));
function adjustCanvasSize(state) {
	if (state.canvas) {
		var curWidth = state.canvas.width;
		var curHeight = state.canvas.height;
		if (curWidth === 300 && curHeight === 150) curWidth = curHeight = 0;
		var pxScale = window.devicePixelRatio;
		curWidth /= pxScale;
		curHeight /= pxScale;
		[state.canvas, state.shadowCanvas].forEach(function(canvas) {
			canvas.style.width = "".concat(state.width, "px");
			canvas.style.height = "".concat(state.height, "px");
			canvas.width = state.width * pxScale;
			canvas.height = state.height * pxScale;
			if (!curWidth && !curHeight) canvas.getContext("2d").scale(pxScale, pxScale);
		});
		var k$1 = transform(state.canvas).k;
		state.zoom.translateBy(state.zoom.__baseElem, (state.width - curWidth) / 2 / k$1, (state.height - curHeight) / 2 / k$1);
		state.needsRedraw = true;
	}
}
function resetTransform(ctx) {
	var pxRatio = window.devicePixelRatio;
	ctx.setTransform(pxRatio, 0, 0, pxRatio, 0, 0);
}
function clearCanvas(ctx, width, height) {
	ctx.save();
	resetTransform(ctx);
	ctx.clearRect(0, 0, width, height);
	ctx.restore();
}
var forceGraph = index$1({
	props: _objectSpread2({
		width: {
			"default": window.innerWidth,
			onChange: function onChange(_$1, state) {
				return adjustCanvasSize(state);
			},
			triggerUpdate: false
		},
		height: {
			"default": window.innerHeight,
			onChange: function onChange(_$1, state) {
				return adjustCanvasSize(state);
			},
			triggerUpdate: false
		},
		graphData: {
			"default": {
				nodes: [],
				links: []
			},
			onChange: function onChange(d$1, state) {
				[d$1.nodes, d$1.links].every(function(arr) {
					return (arr || []).every(function(d$2) {
						return !d$2.hasOwnProperty("__indexColor");
					});
				}) && state.colorTracker.reset();
				[{
					type: "Node",
					objs: d$1.nodes
				}, {
					type: "Link",
					objs: d$1.links
				}].forEach(hexIndex);
				state.forceGraph.graphData(d$1);
				state.shadowGraph.graphData(d$1);
				function hexIndex(_ref4) {
					var type = _ref4.type;
					_ref4.objs.filter(function(d$2) {
						if (!d$2.hasOwnProperty("__indexColor")) return true;
						var cur = state.colorTracker.lookup(d$2.__indexColor);
						return !cur || !cur.hasOwnProperty("d") || cur.d !== d$2;
					}).forEach(function(d$2) {
						d$2.__indexColor = state.colorTracker.register({
							type,
							d: d$2
						});
					});
				}
			},
			triggerUpdate: false
		},
		backgroundColor: {
			onChange: function onChange(color$1, state) {
				state.canvas && color$1 && (state.canvas.style.background = color$1);
			},
			triggerUpdate: false
		},
		nodeLabel: {
			"default": "name",
			triggerUpdate: false
		},
		nodePointerAreaPaint: {
			onChange: function onChange(paintFn, state) {
				state.shadowGraph.nodeCanvasObject(!paintFn ? null : function(node, ctx, globalScale) {
					return paintFn(node, node.__indexColor, ctx, globalScale);
				});
				state.flushShadowCanvas && state.flushShadowCanvas();
			},
			triggerUpdate: false
		},
		linkPointerAreaPaint: {
			onChange: function onChange(paintFn, state) {
				state.shadowGraph.linkCanvasObject(!paintFn ? null : function(link, ctx, globalScale) {
					return paintFn(link, link.__indexColor, ctx, globalScale);
				});
				state.flushShadowCanvas && state.flushShadowCanvas();
			},
			triggerUpdate: false
		},
		linkLabel: {
			"default": "name",
			triggerUpdate: false
		},
		linkHoverPrecision: {
			"default": 4,
			triggerUpdate: false
		},
		minZoom: {
			"default": .01,
			onChange: function onChange(minZoom, state) {
				state.zoom.scaleExtent([minZoom, state.zoom.scaleExtent()[1]]);
			},
			triggerUpdate: false
		},
		maxZoom: {
			"default": 1e3,
			onChange: function onChange(maxZoom, state) {
				state.zoom.scaleExtent([state.zoom.scaleExtent()[0], maxZoom]);
			},
			triggerUpdate: false
		},
		enableNodeDrag: {
			"default": true,
			triggerUpdate: false
		},
		enableZoomInteraction: {
			"default": true,
			triggerUpdate: false
		},
		enablePanInteraction: {
			"default": true,
			triggerUpdate: false
		},
		enableZoomPanInteraction: {
			"default": true,
			triggerUpdate: false
		},
		enablePointerInteraction: {
			"default": true,
			onChange: function onChange(_$1, state) {
				state.hoverObj = null;
			},
			triggerUpdate: false
		},
		autoPauseRedraw: {
			"default": true,
			triggerUpdate: false
		},
		onNodeDrag: {
			"default": function _default$1() {},
			triggerUpdate: false
		},
		onNodeDragEnd: {
			"default": function _default$1() {},
			triggerUpdate: false
		},
		onNodeClick: { triggerUpdate: false },
		onNodeRightClick: { triggerUpdate: false },
		onNodeHover: { triggerUpdate: false },
		onLinkClick: { triggerUpdate: false },
		onLinkRightClick: { triggerUpdate: false },
		onLinkHover: { triggerUpdate: false },
		onBackgroundClick: { triggerUpdate: false },
		onBackgroundRightClick: { triggerUpdate: false },
		showPointerCursor: {
			"default": true,
			triggerUpdate: false
		},
		onZoom: { triggerUpdate: false },
		onZoomEnd: { triggerUpdate: false },
		onRenderFramePre: { triggerUpdate: false },
		onRenderFramePost: { triggerUpdate: false }
	}, linkedProps),
	aliases: { stopAnimation: "pauseAnimation" },
	methods: _objectSpread2({
		graph2ScreenCoords: function graph2ScreenCoords(state, x$2, y$2) {
			var t$2 = transform(state.canvas);
			return {
				x: x$2 * t$2.k + t$2.x,
				y: y$2 * t$2.k + t$2.y
			};
		},
		screen2GraphCoords: function screen2GraphCoords(state, x$2, y$2) {
			var t$2 = transform(state.canvas);
			return {
				x: (x$2 - t$2.x) / t$2.k,
				y: (y$2 - t$2.y) / t$2.k
			};
		},
		centerAt: function centerAt(state, x$2, y$2, transitionDuration) {
			if (!state.canvas) return null;
			if (x$2 !== void 0 || y$2 !== void 0) {
				var finalPos = Object.assign({}, x$2 !== void 0 ? { x: x$2 } : {}, y$2 !== void 0 ? { y: y$2 } : {});
				if (!transitionDuration) setCenter(finalPos);
				else state.tweenGroup.add(new Tween(getCenter()).to(finalPos, transitionDuration).easing(Easing.Quadratic.Out).onUpdate(setCenter).start());
				return this;
			}
			return getCenter();
			function getCenter() {
				var t$2 = transform(state.canvas);
				return {
					x: (state.width / 2 - t$2.x) / t$2.k,
					y: (state.height / 2 - t$2.y) / t$2.k
				};
			}
			function setCenter(_ref5) {
				var x$3 = _ref5.x, y$3 = _ref5.y;
				state.zoom.translateTo(state.zoom.__baseElem, x$3 === void 0 ? getCenter().x : x$3, y$3 === void 0 ? getCenter().y : y$3);
				state.needsRedraw = true;
			}
		},
		zoom: function zoom(state, k$1, transitionDuration) {
			if (!state.canvas) return null;
			if (k$1 !== void 0) {
				if (!transitionDuration) setZoom(k$1);
				else state.tweenGroup.add(new Tween({ k: getZoom() }).to({ k: k$1 }, transitionDuration).easing(Easing.Quadratic.Out).onUpdate(function(_ref6) {
					var k$2 = _ref6.k;
					return setZoom(k$2);
				}).start());
				return this;
			}
			return getZoom();
			function getZoom() {
				return transform(state.canvas).k;
			}
			function setZoom(k$2) {
				state.zoom.scaleTo(state.zoom.__baseElem, k$2);
				state.needsRedraw = true;
			}
		},
		zoomToFit: function zoomToFit(state) {
			var transitionDuration = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
			var padding = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 10;
			for (var _len = arguments.length, bboxArgs = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) bboxArgs[_key - 3] = arguments[_key];
			var bbox = this.getGraphBbox.apply(this, bboxArgs);
			if (bbox) {
				var center = {
					x: (bbox.x[0] + bbox.x[1]) / 2,
					y: (bbox.y[0] + bbox.y[1]) / 2
				};
				var zoomK = Math.max(1e-12, Math.min(0xe8d4a51000, (state.width - padding * 2) / (bbox.x[1] - bbox.x[0]), (state.height - padding * 2) / (bbox.y[1] - bbox.y[0])));
				this.centerAt(center.x, center.y, transitionDuration);
				this.zoom(zoomK, transitionDuration);
			}
			return this;
		},
		getGraphBbox: function getGraphBbox(state) {
			var nodeFilter = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : function() {
				return true;
			};
			var getVal = index$2(state.nodeVal);
			var getR = function getR$1(node) {
				return Math.sqrt(Math.max(0, getVal(node) || 1)) * state.nodeRelSize;
			};
			var nodesPos = state.graphData.nodes.filter(nodeFilter).map(function(node) {
				return {
					x: node.x,
					y: node.y,
					r: getR(node)
				};
			});
			return !nodesPos.length ? null : {
				x: [min(nodesPos, function(node) {
					return node.x - node.r;
				}), max(nodesPos, function(node) {
					return node.x + node.r;
				})],
				y: [min(nodesPos, function(node) {
					return node.y - node.r;
				}), max(nodesPos, function(node) {
					return node.y + node.r;
				})]
			};
		},
		pauseAnimation: function pauseAnimation(state) {
			if (state.animationFrameRequestId) {
				cancelAnimationFrame(state.animationFrameRequestId);
				state.animationFrameRequestId = null;
			}
			return this;
		},
		resumeAnimation: function resumeAnimation(state) {
			if (!state.animationFrameRequestId) this._animationCycle();
			return this;
		},
		_destructor: function _destructor() {
			this.pauseAnimation();
			this.graphData({
				nodes: [],
				links: []
			});
		}
	}, linkedMethods),
	stateInit: function stateInit() {
		return {
			lastSetZoom: 1,
			zoom: zoom_default(),
			forceGraph: new CanvasForceGraph(),
			shadowGraph: new CanvasForceGraph().cooldownTicks(0).nodeColor("__indexColor").linkColor("__indexColor").isShadow(true),
			colorTracker: new _default(),
			tweenGroup: new Group()
		};
	},
	init: function init$1(domNode, state) {
		var _this = this;
		domNode.innerHTML = "";
		var container = document.createElement("div");
		container.classList.add("force-graph-container");
		container.style.position = "relative";
		domNode.appendChild(container);
		state.canvas = document.createElement("canvas");
		if (state.backgroundColor) state.canvas.style.background = state.backgroundColor;
		container.appendChild(state.canvas);
		state.shadowCanvas = document.createElement("canvas");
		var ctx = state.canvas.getContext("2d");
		var shadowCtx = state.shadowCanvas.getContext("2d", { willReadFrequently: true });
		var pointerPos = {
			x: -0xe8d4a51000,
			y: -0xe8d4a51000
		};
		var getObjUnderPointer = function getObjUnderPointer$1() {
			var obj = null;
			var pxScale = window.devicePixelRatio;
			var px = pointerPos.x > 0 && pointerPos.y > 0 ? shadowCtx.getImageData(pointerPos.x * pxScale, pointerPos.y * pxScale, 1, 1) : null;
			px && (obj = state.colorTracker.lookup(px.data));
			return obj;
		};
		select_default(state.canvas).call(drag_default().subject(function() {
			if (!state.enableNodeDrag) return null;
			var obj = getObjUnderPointer();
			return obj && obj.type === "Node" ? obj.d : null;
		}).on("start", function(ev) {
			var obj = ev.subject;
			obj.__initialDragPos = {
				x: obj.x,
				y: obj.y,
				fx: obj.fx,
				fy: obj.fy
			};
			if (!ev.active) {
				obj.fx = obj.x;
				obj.fy = obj.y;
			}
			state.canvas.classList.add("grabbable");
		}).on("drag", function(ev) {
			var obj = ev.subject;
			var initPos = obj.__initialDragPos;
			var dragPos = ev;
			var k$1 = transform(state.canvas).k;
			var translate = {
				x: initPos.x + (dragPos.x - initPos.x) / k$1 - obj.x,
				y: initPos.y + (dragPos.y - initPos.y) / k$1 - obj.y
			};
			["x", "y"].forEach(function(c$2) {
				return obj["f".concat(c$2)] = obj[c$2] = initPos[c$2] + (dragPos[c$2] - initPos[c$2]) / k$1;
			});
			if (!obj.__dragged && DRAG_CLICK_TOLERANCE_PX >= Math.sqrt(sum(["x", "y"].map(function(k$2) {
				return Math.pow(ev[k$2] - initPos[k$2], 2);
			})))) return;
			state.forceGraph.d3AlphaTarget(.3).resetCountdown();
			state.isPointerDragging = true;
			obj.__dragged = true;
			state.onNodeDrag(obj, translate);
		}).on("end", function(ev) {
			var obj = ev.subject;
			var initPos = obj.__initialDragPos;
			var translate = {
				x: obj.x - initPos.x,
				y: obj.y - initPos.y
			};
			if (initPos.fx === void 0) obj.fx = void 0;
			if (initPos.fy === void 0) obj.fy = void 0;
			delete obj.__initialDragPos;
			if (state.forceGraph.d3AlphaTarget()) state.forceGraph.d3AlphaTarget(0).resetCountdown();
			state.canvas.classList.remove("grabbable");
			state.isPointerDragging = false;
			if (obj.__dragged) {
				delete obj.__dragged;
				state.onNodeDragEnd(obj, translate);
			}
		}));
		state.zoom(state.zoom.__baseElem = select_default(state.canvas));
		state.zoom.__baseElem.on("dblclick.zoom", null);
		state.zoom.filter(function(ev) {
			return !ev.button && state.enableZoomPanInteraction && (ev.type !== "wheel" || index$2(state.enableZoomInteraction)(ev)) && (ev.type === "wheel" || index$2(state.enablePanInteraction)(ev));
		}).on("zoom", function(ev) {
			var t$2 = ev.transform;
			[ctx, shadowCtx].forEach(function(c$2) {
				resetTransform(c$2);
				c$2.translate(t$2.x, t$2.y);
				c$2.scale(t$2.k, t$2.k);
			});
			state.isPointerDragging = true;
			state.onZoom && state.onZoom(_objectSpread2(_objectSpread2({}, t$2), _this.centerAt()));
			state.needsRedraw = true;
		}).on("end", function(ev) {
			state.isPointerDragging = false;
			state.onZoomEnd && state.onZoomEnd(_objectSpread2(_objectSpread2({}, ev.transform), _this.centerAt()));
		});
		adjustCanvasSize(state);
		state.forceGraph.onNeedsRedraw(function() {
			return state.needsRedraw = true;
		}).onFinishUpdate(function() {
			if (transform(state.canvas).k === state.lastSetZoom && state.graphData.nodes.length) {
				state.zoom.scaleTo(state.zoom.__baseElem, state.lastSetZoom = ZOOM2NODES_FACTOR / Math.cbrt(state.graphData.nodes.length));
				state.needsRedraw = true;
			}
		});
		state.tooltip = new index$3(container);
		["pointermove", "pointerdown"].forEach(function(evType) {
			return container.addEventListener(evType, function(ev) {
				if (evType === "pointerdown") {
					state.isPointerPressed = true;
					state.pointerDownEvent = ev;
				}
				!state.isPointerDragging && ev.type === "pointermove" && state.onBackgroundClick && (ev.pressure > 0 || state.isPointerPressed) && (ev.pointerType === "mouse" || ev.movementX === void 0 || [ev.movementX, ev.movementY].some(function(m$2) {
					return Math.abs(m$2) > 1;
				})) && (state.isPointerDragging = true);
				var offset = getOffset(container);
				pointerPos.x = ev.pageX - offset.left;
				pointerPos.y = ev.pageY - offset.top;
				function getOffset(el) {
					var rect = el.getBoundingClientRect(), scrollLeft = window.pageXOffset || document.documentElement.scrollLeft, scrollTop = window.pageYOffset || document.documentElement.scrollTop;
					return {
						top: rect.top + scrollTop,
						left: rect.left + scrollLeft
					};
				}
			}, { passive: true });
		});
		container.addEventListener("pointerup", function(ev) {
			if (!state.isPointerPressed) return;
			state.isPointerPressed = false;
			if (state.isPointerDragging) {
				state.isPointerDragging = false;
				return;
			}
			var cbEvents = [ev, state.pointerDownEvent];
			requestAnimationFrame(function() {
				if (ev.button === 0) if (state.hoverObj) {
					var fn = state["on".concat(state.hoverObj.type, "Click")];
					fn && fn.apply(void 0, [state.hoverObj.d].concat(cbEvents));
				} else state.onBackgroundClick && state.onBackgroundClick.apply(state, cbEvents);
				if (ev.button === 2) if (state.hoverObj) {
					var _fn = state["on".concat(state.hoverObj.type, "RightClick")];
					_fn && _fn.apply(void 0, [state.hoverObj.d].concat(cbEvents));
				} else state.onBackgroundRightClick && state.onBackgroundRightClick.apply(state, cbEvents);
			});
		}, { passive: true });
		container.addEventListener("contextmenu", function(ev) {
			if (!state.onBackgroundRightClick && !state.onNodeRightClick && !state.onLinkRightClick) return true;
			ev.preventDefault();
			return false;
		});
		state.forceGraph(ctx);
		state.shadowGraph(shadowCtx);
		var refreshShadowCanvas = throttle_default(function() {
			clearCanvas(shadowCtx, state.width, state.height);
			state.shadowGraph.linkWidth(function(l$1) {
				return index$2(state.linkWidth)(l$1) + state.linkHoverPrecision;
			});
			var t$2 = transform(state.canvas);
			state.shadowGraph.globalScale(t$2.k).tickFrame();
		}, HOVER_CANVAS_THROTTLE_DELAY);
		state.flushShadowCanvas = refreshShadowCanvas.flush;
		(this._animationCycle = function animate() {
			var doRedraw = !state.autoPauseRedraw || !!state.needsRedraw || state.forceGraph.isEngineRunning() || state.graphData.links.some(function(d$1) {
				return d$1.__photons && d$1.__photons.length;
			});
			state.needsRedraw = false;
			if (state.enablePointerInteraction) {
				var obj = !state.isPointerDragging ? getObjUnderPointer() : null;
				if (obj !== state.hoverObj) {
					var prevObj = state.hoverObj;
					var prevObjType = prevObj ? prevObj.type : null;
					var objType = obj ? obj.type : null;
					if (prevObjType && prevObjType !== objType) {
						var fn = state["on".concat(prevObjType, "Hover")];
						fn && fn(null, prevObj.d);
					}
					if (objType) {
						var _fn2 = state["on".concat(objType, "Hover")];
						_fn2 && _fn2(obj.d, prevObjType === objType ? prevObj.d : null);
					}
					state.tooltip.content(obj ? index$2(state["".concat(obj.type.toLowerCase(), "Label")])(obj.d) || null : null);
					state.canvas.classList[(obj && state["on".concat(objType, "Click")] || !obj && state.onBackgroundClick) && index$2(state.showPointerCursor)(obj === null || obj === void 0 ? void 0 : obj.d) ? "add" : "remove"]("clickable");
					state.hoverObj = obj;
				}
				doRedraw && refreshShadowCanvas();
			}
			if (doRedraw) {
				clearCanvas(ctx, state.width, state.height);
				var globalScale = transform(state.canvas).k;
				state.onRenderFramePre && state.onRenderFramePre(ctx, globalScale);
				state.forceGraph.globalScale(globalScale).tickFrame();
				state.onRenderFramePost && state.onRenderFramePost(ctx, globalScale);
			}
			state.tweenGroup.update();
			state.animationFrameRequestId = requestAnimationFrame(animate);
		})();
	},
	update: function updateFn(state) {}
});

//#endregion
//#region node_modules/react-is/cjs/react-is.development.js
/** @license React v16.13.1
* react-is.development.js
*
* Copyright (c) Facebook, Inc. and its affiliates.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/
var require_react_is_development = /* @__PURE__ */ __commonJS({ "node_modules/react-is/cjs/react-is.development.js": ((exports) => {
	(function() {
		var hasSymbol = typeof Symbol === "function" && Symbol.for;
		var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for("react.element") : 60103;
		var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for("react.portal") : 60106;
		var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for("react.fragment") : 60107;
		var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for("react.strict_mode") : 60108;
		var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for("react.profiler") : 60114;
		var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for("react.provider") : 60109;
		var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for("react.context") : 60110;
		var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for("react.async_mode") : 60111;
		var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for("react.concurrent_mode") : 60111;
		var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for("react.forward_ref") : 60112;
		var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for("react.suspense") : 60113;
		var REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for("react.suspense_list") : 60120;
		var REACT_MEMO_TYPE = hasSymbol ? Symbol.for("react.memo") : 60115;
		var REACT_LAZY_TYPE = hasSymbol ? Symbol.for("react.lazy") : 60116;
		var REACT_BLOCK_TYPE = hasSymbol ? Symbol.for("react.block") : 60121;
		var REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for("react.fundamental") : 60117;
		var REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for("react.responder") : 60118;
		var REACT_SCOPE_TYPE = hasSymbol ? Symbol.for("react.scope") : 60119;
		function isValidElementType(type) {
			return typeof type === "string" || typeof type === "function" || type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === "object" && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE || type.$$typeof === REACT_BLOCK_TYPE);
		}
		function typeOf(object) {
			if (typeof object === "object" && object !== null) {
				var $$typeof = object.$$typeof;
				switch ($$typeof) {
					case REACT_ELEMENT_TYPE:
						var type = object.type;
						switch (type) {
							case REACT_ASYNC_MODE_TYPE:
							case REACT_CONCURRENT_MODE_TYPE:
							case REACT_FRAGMENT_TYPE:
							case REACT_PROFILER_TYPE:
							case REACT_STRICT_MODE_TYPE:
							case REACT_SUSPENSE_TYPE: return type;
							default:
								var $$typeofType = type && type.$$typeof;
								switch ($$typeofType) {
									case REACT_CONTEXT_TYPE:
									case REACT_FORWARD_REF_TYPE:
									case REACT_LAZY_TYPE:
									case REACT_MEMO_TYPE:
									case REACT_PROVIDER_TYPE: return $$typeofType;
									default: return $$typeof;
								}
						}
					case REACT_PORTAL_TYPE: return $$typeof;
				}
			}
		}
		var AsyncMode = REACT_ASYNC_MODE_TYPE;
		var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
		var ContextConsumer = REACT_CONTEXT_TYPE;
		var ContextProvider = REACT_PROVIDER_TYPE;
		var Element = REACT_ELEMENT_TYPE;
		var ForwardRef = REACT_FORWARD_REF_TYPE;
		var Fragment = REACT_FRAGMENT_TYPE;
		var Lazy = REACT_LAZY_TYPE;
		var Memo = REACT_MEMO_TYPE;
		var Portal = REACT_PORTAL_TYPE;
		var Profiler = REACT_PROFILER_TYPE;
		var StrictMode = REACT_STRICT_MODE_TYPE;
		var Suspense = REACT_SUSPENSE_TYPE;
		var hasWarnedAboutDeprecatedIsAsyncMode = false;
		function isAsyncMode(object) {
			if (!hasWarnedAboutDeprecatedIsAsyncMode) {
				hasWarnedAboutDeprecatedIsAsyncMode = true;
				console["warn"]("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.");
			}
			return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;
		}
		function isConcurrentMode(object) {
			return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;
		}
		function isContextConsumer(object) {
			return typeOf(object) === REACT_CONTEXT_TYPE;
		}
		function isContextProvider(object) {
			return typeOf(object) === REACT_PROVIDER_TYPE;
		}
		function isElement(object) {
			return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
		}
		function isForwardRef(object) {
			return typeOf(object) === REACT_FORWARD_REF_TYPE;
		}
		function isFragment(object) {
			return typeOf(object) === REACT_FRAGMENT_TYPE;
		}
		function isLazy(object) {
			return typeOf(object) === REACT_LAZY_TYPE;
		}
		function isMemo(object) {
			return typeOf(object) === REACT_MEMO_TYPE;
		}
		function isPortal(object) {
			return typeOf(object) === REACT_PORTAL_TYPE;
		}
		function isProfiler(object) {
			return typeOf(object) === REACT_PROFILER_TYPE;
		}
		function isStrictMode(object) {
			return typeOf(object) === REACT_STRICT_MODE_TYPE;
		}
		function isSuspense(object) {
			return typeOf(object) === REACT_SUSPENSE_TYPE;
		}
		exports.AsyncMode = AsyncMode;
		exports.ConcurrentMode = ConcurrentMode;
		exports.ContextConsumer = ContextConsumer;
		exports.ContextProvider = ContextProvider;
		exports.Element = Element;
		exports.ForwardRef = ForwardRef;
		exports.Fragment = Fragment;
		exports.Lazy = Lazy;
		exports.Memo = Memo;
		exports.Portal = Portal;
		exports.Profiler = Profiler;
		exports.StrictMode = StrictMode;
		exports.Suspense = Suspense;
		exports.isAsyncMode = isAsyncMode;
		exports.isConcurrentMode = isConcurrentMode;
		exports.isContextConsumer = isContextConsumer;
		exports.isContextProvider = isContextProvider;
		exports.isElement = isElement;
		exports.isForwardRef = isForwardRef;
		exports.isFragment = isFragment;
		exports.isLazy = isLazy;
		exports.isMemo = isMemo;
		exports.isPortal = isPortal;
		exports.isProfiler = isProfiler;
		exports.isStrictMode = isStrictMode;
		exports.isSuspense = isSuspense;
		exports.isValidElementType = isValidElementType;
		exports.typeOf = typeOf;
	})();
}) });

//#endregion
//#region node_modules/react-is/index.js
var require_react_is = /* @__PURE__ */ __commonJS({ "node_modules/react-is/index.js": ((exports, module) => {
	module.exports = require_react_is_development();
}) });

//#endregion
//#region node_modules/object-assign/index.js
var require_object_assign = /* @__PURE__ */ __commonJS({ "node_modules/object-assign/index.js": ((exports, module) => {
	var getOwnPropertySymbols = Object.getOwnPropertySymbols;
	var hasOwnProperty = Object.prototype.hasOwnProperty;
	var propIsEnumerable = Object.prototype.propertyIsEnumerable;
	function toObject(val) {
		if (val === null || val === void 0) throw new TypeError("Object.assign cannot be called with null or undefined");
		return Object(val);
	}
	function shouldUseNative() {
		try {
			if (!Object.assign) return false;
			var test1 = /* @__PURE__ */ new String("abc");
			test1[5] = "de";
			if (Object.getOwnPropertyNames(test1)[0] === "5") return false;
			var test2 = {};
			for (var i$1 = 0; i$1 < 10; i$1++) test2["_" + String.fromCharCode(i$1)] = i$1;
			if (Object.getOwnPropertyNames(test2).map(function(n$1) {
				return test2[n$1];
			}).join("") !== "0123456789") return false;
			var test3 = {};
			"abcdefghijklmnopqrst".split("").forEach(function(letter) {
				test3[letter] = letter;
			});
			if (Object.keys(Object.assign({}, test3)).join("") !== "abcdefghijklmnopqrst") return false;
			return true;
		} catch (err) {
			return false;
		}
	}
	module.exports = shouldUseNative() ? Object.assign : function(target, source) {
		var from;
		var to = toObject(target);
		var symbols;
		for (var s$1 = 1; s$1 < arguments.length; s$1++) {
			from = Object(arguments[s$1]);
			for (var key in from) if (hasOwnProperty.call(from, key)) to[key] = from[key];
			if (getOwnPropertySymbols) {
				symbols = getOwnPropertySymbols(from);
				for (var i$1 = 0; i$1 < symbols.length; i$1++) if (propIsEnumerable.call(from, symbols[i$1])) to[symbols[i$1]] = from[symbols[i$1]];
			}
		}
		return to;
	};
}) });

//#endregion
//#region node_modules/prop-types/lib/ReactPropTypesSecret.js
/**
* Copyright (c) 2013-present, Facebook, Inc.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/
var require_ReactPropTypesSecret = /* @__PURE__ */ __commonJS({ "node_modules/prop-types/lib/ReactPropTypesSecret.js": ((exports, module) => {
	var ReactPropTypesSecret$2 = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
	module.exports = ReactPropTypesSecret$2;
}) });

//#endregion
//#region node_modules/prop-types/lib/has.js
var require_has = /* @__PURE__ */ __commonJS({ "node_modules/prop-types/lib/has.js": ((exports, module) => {
	module.exports = Function.call.bind(Object.prototype.hasOwnProperty);
}) });

//#endregion
//#region node_modules/prop-types/checkPropTypes.js
/**
* Copyright (c) 2013-present, Facebook, Inc.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/
var require_checkPropTypes = /* @__PURE__ */ __commonJS({ "node_modules/prop-types/checkPropTypes.js": ((exports, module) => {
	var printWarning$1 = function() {};
	var ReactPropTypesSecret$1 = require_ReactPropTypesSecret();
	var loggedTypeFailures = {};
	var has$1 = require_has();
	printWarning$1 = function(text) {
		var message = "Warning: " + text;
		if (typeof console !== "undefined") console.error(message);
		try {
			throw new Error(message);
		} catch (x$2) {}
	};
	/**
	* Assert that the values match with the type specs.
	* Error messages are memorized and will only be shown once.
	*
	* @param {object} typeSpecs Map of name to a ReactPropType
	* @param {object} values Runtime values that need to be type-checked
	* @param {string} location e.g. "prop", "context", "child context"
	* @param {string} componentName Name of the component for error messages.
	* @param {?Function} getStack Returns the component stack.
	* @private
	*/
	function checkPropTypes$1(typeSpecs, values, location, componentName, getStack) {
		for (var typeSpecName in typeSpecs) if (has$1(typeSpecs, typeSpecName)) {
			var error;
			try {
				if (typeof typeSpecs[typeSpecName] !== "function") {
					var err = Error((componentName || "React class") + ": " + location + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
					err.name = "Invariant Violation";
					throw err;
				}
				error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret$1);
			} catch (ex) {
				error = ex;
			}
			if (error && !(error instanceof Error)) printWarning$1((componentName || "React class") + ": type specification of " + location + " `" + typeSpecName + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof error + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).");
			if (error instanceof Error && !(error.message in loggedTypeFailures)) {
				loggedTypeFailures[error.message] = true;
				var stack = getStack ? getStack() : "";
				printWarning$1("Failed " + location + " type: " + error.message + (stack != null ? stack : ""));
			}
		}
	}
	/**
	* Resets warning cache when testing.
	*
	* @private
	*/
	checkPropTypes$1.resetWarningCache = function() {
		loggedTypeFailures = {};
	};
	module.exports = checkPropTypes$1;
}) });

//#endregion
//#region node_modules/prop-types/factoryWithTypeCheckers.js
/**
* Copyright (c) 2013-present, Facebook, Inc.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/
var require_factoryWithTypeCheckers = /* @__PURE__ */ __commonJS({ "node_modules/prop-types/factoryWithTypeCheckers.js": ((exports, module) => {
	var ReactIs$1 = require_react_is();
	var assign = require_object_assign();
	var ReactPropTypesSecret = require_ReactPropTypesSecret();
	var has = require_has();
	var checkPropTypes = require_checkPropTypes();
	var printWarning = function() {};
	printWarning = function(text) {
		var message = "Warning: " + text;
		if (typeof console !== "undefined") console.error(message);
		try {
			throw new Error(message);
		} catch (x$2) {}
	};
	function emptyFunctionThatReturnsNull() {
		return null;
	}
	module.exports = function(isValidElement, throwOnDirectAccess$1) {
		var ITERATOR_SYMBOL = typeof Symbol === "function" && Symbol.iterator;
		var FAUX_ITERATOR_SYMBOL = "@@iterator";
		/**
		* Returns the iterator method function contained on the iterable object.
		*
		* Be sure to invoke the function with the iterable as context:
		*
		*     var iteratorFn = getIteratorFn(myIterable);
		*     if (iteratorFn) {
		*       var iterator = iteratorFn.call(myIterable);
		*       ...
		*     }
		*
		* @param {?object} maybeIterable
		* @return {?function}
		*/
		function getIteratorFn(maybeIterable) {
			var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
			if (typeof iteratorFn === "function") return iteratorFn;
		}
		/**
		* Collection of methods that allow declaration and validation of props that are
		* supplied to React components. Example usage:
		*
		*   var Props = require('ReactPropTypes');
		*   var MyArticle = React.createClass({
		*     propTypes: {
		*       // An optional string prop named "description".
		*       description: Props.string,
		*
		*       // A required enum prop named "category".
		*       category: Props.oneOf(['News','Photos']).isRequired,
		*
		*       // A prop named "dialog" that requires an instance of Dialog.
		*       dialog: Props.instanceOf(Dialog).isRequired
		*     },
		*     render: function() { ... }
		*   });
		*
		* A more formal specification of how these methods are used:
		*
		*   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)
		*   decl := ReactPropTypes.{type}(.isRequired)?
		*
		* Each and every declaration produces a function with the same signature. This
		* allows the creation of custom validation functions. For example:
		*
		*  var MyLink = React.createClass({
		*    propTypes: {
		*      // An optional string or URI prop named "href".
		*      href: function(props, propName, componentName) {
		*        var propValue = props[propName];
		*        if (propValue != null && typeof propValue !== 'string' &&
		*            !(propValue instanceof URI)) {
		*          return new Error(
		*            'Expected a string or an URI for ' + propName + ' in ' +
		*            componentName
		*          );
		*        }
		*      }
		*    },
		*    render: function() {...}
		*  });
		*
		* @internal
		*/
		var ANONYMOUS = "<<anonymous>>";
		var ReactPropTypes = {
			array: createPrimitiveTypeChecker("array"),
			bigint: createPrimitiveTypeChecker("bigint"),
			bool: createPrimitiveTypeChecker("boolean"),
			func: createPrimitiveTypeChecker("function"),
			number: createPrimitiveTypeChecker("number"),
			object: createPrimitiveTypeChecker("object"),
			string: createPrimitiveTypeChecker("string"),
			symbol: createPrimitiveTypeChecker("symbol"),
			any: createAnyTypeChecker(),
			arrayOf: createArrayOfTypeChecker,
			element: createElementTypeChecker(),
			elementType: createElementTypeTypeChecker(),
			instanceOf: createInstanceTypeChecker,
			node: createNodeChecker(),
			objectOf: createObjectOfTypeChecker,
			oneOf: createEnumTypeChecker,
			oneOfType: createUnionTypeChecker,
			shape: createShapeTypeChecker,
			exact: createStrictShapeTypeChecker
		};
		/**
		* inlined Object.is polyfill to avoid requiring consumers ship their own
		* https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
		*/
		function is(x$2, y$2) {
			if (x$2 === y$2) return x$2 !== 0 || 1 / x$2 === 1 / y$2;
			else return x$2 !== x$2 && y$2 !== y$2;
		}
		/**
		* We use an Error-like object for backward compatibility as people may call
		* PropTypes directly and inspect their output. However, we don't use real
		* Errors anymore. We don't inspect their stack anyway, and creating them
		* is prohibitively expensive if they are created too often, such as what
		* happens in oneOfType() for any type before the one that matched.
		*/
		function PropTypeError(message, data) {
			this.message = message;
			this.data = data && typeof data === "object" ? data : {};
			this.stack = "";
		}
		PropTypeError.prototype = Error.prototype;
		function createChainableTypeChecker(validate) {
			var manualPropTypeCallCache = {};
			var manualPropTypeWarningCount = 0;
			function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
				componentName = componentName || ANONYMOUS;
				propFullName = propFullName || propName;
				if (secret !== ReactPropTypesSecret) {
					if (throwOnDirectAccess$1) {
						var err = /* @__PURE__ */ new Error("Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types");
						err.name = "Invariant Violation";
						throw err;
					} else if (typeof console !== "undefined") {
						var cacheKey = componentName + ":" + propName;
						if (!manualPropTypeCallCache[cacheKey] && manualPropTypeWarningCount < 3) {
							printWarning("You are manually calling a React.PropTypes validation function for the `" + propFullName + "` prop on `" + componentName + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details.");
							manualPropTypeCallCache[cacheKey] = true;
							manualPropTypeWarningCount++;
						}
					}
				}
				if (props[propName] == null) {
					if (isRequired) {
						if (props[propName] === null) return new PropTypeError("The " + location + " `" + propFullName + "` is marked as required " + ("in `" + componentName + "`, but its value is `null`."));
						return new PropTypeError("The " + location + " `" + propFullName + "` is marked as required in " + ("`" + componentName + "`, but its value is `undefined`."));
					}
					return null;
				} else return validate(props, propName, componentName, location, propFullName);
			}
			var chainedCheckType = checkType.bind(null, false);
			chainedCheckType.isRequired = checkType.bind(null, true);
			return chainedCheckType;
		}
		function createPrimitiveTypeChecker(expectedType) {
			function validate(props, propName, componentName, location, propFullName, secret) {
				var propValue = props[propName];
				if (getPropType(propValue) !== expectedType) {
					var preciseType = getPreciseType(propValue);
					return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + preciseType + "` supplied to `" + componentName + "`, expected ") + ("`" + expectedType + "`."), { expectedType });
				}
				return null;
			}
			return createChainableTypeChecker(validate);
		}
		function createAnyTypeChecker() {
			return createChainableTypeChecker(emptyFunctionThatReturnsNull);
		}
		function createArrayOfTypeChecker(typeChecker) {
			function validate(props, propName, componentName, location, propFullName) {
				if (typeof typeChecker !== "function") return new PropTypeError("Property `" + propFullName + "` of component `" + componentName + "` has invalid PropType notation inside arrayOf.");
				var propValue = props[propName];
				if (!Array.isArray(propValue)) {
					var propType = getPropType(propValue);
					return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected an array."));
				}
				for (var i$1 = 0; i$1 < propValue.length; i$1++) {
					var error = typeChecker(propValue, i$1, componentName, location, propFullName + "[" + i$1 + "]", ReactPropTypesSecret);
					if (error instanceof Error) return error;
				}
				return null;
			}
			return createChainableTypeChecker(validate);
		}
		function createElementTypeChecker() {
			function validate(props, propName, componentName, location, propFullName) {
				var propValue = props[propName];
				if (!isValidElement(propValue)) {
					var propType = getPropType(propValue);
					return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected a single ReactElement."));
				}
				return null;
			}
			return createChainableTypeChecker(validate);
		}
		function createElementTypeTypeChecker() {
			function validate(props, propName, componentName, location, propFullName) {
				var propValue = props[propName];
				if (!ReactIs$1.isValidElementType(propValue)) {
					var propType = getPropType(propValue);
					return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected a single ReactElement type."));
				}
				return null;
			}
			return createChainableTypeChecker(validate);
		}
		function createInstanceTypeChecker(expectedClass) {
			function validate(props, propName, componentName, location, propFullName) {
				if (!(props[propName] instanceof expectedClass)) {
					var expectedClassName = expectedClass.name || ANONYMOUS;
					var actualClassName = getClassName(props[propName]);
					return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + actualClassName + "` supplied to `" + componentName + "`, expected ") + ("instance of `" + expectedClassName + "`."));
				}
				return null;
			}
			return createChainableTypeChecker(validate);
		}
		function createEnumTypeChecker(expectedValues) {
			if (!Array.isArray(expectedValues)) {
				if (arguments.length > 1) printWarning("Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z]).");
				else printWarning("Invalid argument supplied to oneOf, expected an array.");
				return emptyFunctionThatReturnsNull;
			}
			function validate(props, propName, componentName, location, propFullName) {
				var propValue = props[propName];
				for (var i$1 = 0; i$1 < expectedValues.length; i$1++) if (is(propValue, expectedValues[i$1])) return null;
				var valuesString = JSON.stringify(expectedValues, function replacer(key, value) {
					if (getPreciseType(value) === "symbol") return String(value);
					return value;
				});
				return new PropTypeError("Invalid " + location + " `" + propFullName + "` of value `" + String(propValue) + "` " + ("supplied to `" + componentName + "`, expected one of " + valuesString + "."));
			}
			return createChainableTypeChecker(validate);
		}
		function createObjectOfTypeChecker(typeChecker) {
			function validate(props, propName, componentName, location, propFullName) {
				if (typeof typeChecker !== "function") return new PropTypeError("Property `" + propFullName + "` of component `" + componentName + "` has invalid PropType notation inside objectOf.");
				var propValue = props[propName];
				var propType = getPropType(propValue);
				if (propType !== "object") return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected an object."));
				for (var key in propValue) if (has(propValue, key)) {
					var error = typeChecker(propValue, key, componentName, location, propFullName + "." + key, ReactPropTypesSecret);
					if (error instanceof Error) return error;
				}
				return null;
			}
			return createChainableTypeChecker(validate);
		}
		function createUnionTypeChecker(arrayOfTypeCheckers) {
			if (!Array.isArray(arrayOfTypeCheckers)) {
				printWarning("Invalid argument supplied to oneOfType, expected an instance of array.");
				return emptyFunctionThatReturnsNull;
			}
			for (var i$1 = 0; i$1 < arrayOfTypeCheckers.length; i$1++) {
				var checker = arrayOfTypeCheckers[i$1];
				if (typeof checker !== "function") {
					printWarning("Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + getPostfixForTypeWarning(checker) + " at index " + i$1 + ".");
					return emptyFunctionThatReturnsNull;
				}
			}
			function validate(props, propName, componentName, location, propFullName) {
				var expectedTypes = [];
				for (var i$2 = 0; i$2 < arrayOfTypeCheckers.length; i$2++) {
					var checker$1 = arrayOfTypeCheckers[i$2];
					var checkerResult = checker$1(props, propName, componentName, location, propFullName, ReactPropTypesSecret);
					if (checkerResult == null) return null;
					if (checkerResult.data && has(checkerResult.data, "expectedType")) expectedTypes.push(checkerResult.data.expectedType);
				}
				var expectedTypesMessage = expectedTypes.length > 0 ? ", expected one of type [" + expectedTypes.join(", ") + "]" : "";
				return new PropTypeError("Invalid " + location + " `" + propFullName + "` supplied to " + ("`" + componentName + "`" + expectedTypesMessage + "."));
			}
			return createChainableTypeChecker(validate);
		}
		function createNodeChecker() {
			function validate(props, propName, componentName, location, propFullName) {
				if (!isNode(props[propName])) return new PropTypeError("Invalid " + location + " `" + propFullName + "` supplied to " + ("`" + componentName + "`, expected a ReactNode."));
				return null;
			}
			return createChainableTypeChecker(validate);
		}
		function invalidValidatorError(componentName, location, propFullName, key, type) {
			return new PropTypeError((componentName || "React class") + ": " + location + " type `" + propFullName + "." + key + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + type + "`.");
		}
		function createShapeTypeChecker(shapeTypes) {
			function validate(props, propName, componentName, location, propFullName) {
				var propValue = props[propName];
				var propType = getPropType(propValue);
				if (propType !== "object") return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type `" + propType + "` " + ("supplied to `" + componentName + "`, expected `object`."));
				for (var key in shapeTypes) {
					var checker = shapeTypes[key];
					if (typeof checker !== "function") return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));
					var error = checker(propValue, key, componentName, location, propFullName + "." + key, ReactPropTypesSecret);
					if (error) return error;
				}
				return null;
			}
			return createChainableTypeChecker(validate);
		}
		function createStrictShapeTypeChecker(shapeTypes) {
			function validate(props, propName, componentName, location, propFullName) {
				var propValue = props[propName];
				var propType = getPropType(propValue);
				if (propType !== "object") return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type `" + propType + "` " + ("supplied to `" + componentName + "`, expected `object`."));
				for (var key in assign({}, props[propName], shapeTypes)) {
					var checker = shapeTypes[key];
					if (has(shapeTypes, key) && typeof checker !== "function") return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));
					if (!checker) return new PropTypeError("Invalid " + location + " `" + propFullName + "` key `" + key + "` supplied to `" + componentName + "`.\nBad object: " + JSON.stringify(props[propName], null, "  ") + "\nValid keys: " + JSON.stringify(Object.keys(shapeTypes), null, "  "));
					var error = checker(propValue, key, componentName, location, propFullName + "." + key, ReactPropTypesSecret);
					if (error) return error;
				}
				return null;
			}
			return createChainableTypeChecker(validate);
		}
		function isNode(propValue) {
			switch (typeof propValue) {
				case "number":
				case "string":
				case "undefined": return true;
				case "boolean": return !propValue;
				case "object":
					if (Array.isArray(propValue)) return propValue.every(isNode);
					if (propValue === null || isValidElement(propValue)) return true;
					var iteratorFn = getIteratorFn(propValue);
					if (iteratorFn) {
						var iterator = iteratorFn.call(propValue);
						var step;
						if (iteratorFn !== propValue.entries) {
							while (!(step = iterator.next()).done) if (!isNode(step.value)) return false;
						} else while (!(step = iterator.next()).done) {
							var entry = step.value;
							if (entry) {
								if (!isNode(entry[1])) return false;
							}
						}
					} else return false;
					return true;
				default: return false;
			}
		}
		function isSymbol$1(propType, propValue) {
			if (propType === "symbol") return true;
			if (!propValue) return false;
			if (propValue["@@toStringTag"] === "Symbol") return true;
			if (typeof Symbol === "function" && propValue instanceof Symbol) return true;
			return false;
		}
		function getPropType(propValue) {
			var propType = typeof propValue;
			if (Array.isArray(propValue)) return "array";
			if (propValue instanceof RegExp) return "object";
			if (isSymbol$1(propType, propValue)) return "symbol";
			return propType;
		}
		function getPreciseType(propValue) {
			if (typeof propValue === "undefined" || propValue === null) return "" + propValue;
			var propType = getPropType(propValue);
			if (propType === "object") {
				if (propValue instanceof Date) return "date";
				else if (propValue instanceof RegExp) return "regexp";
			}
			return propType;
		}
		function getPostfixForTypeWarning(value) {
			var type = getPreciseType(value);
			switch (type) {
				case "array":
				case "object": return "an " + type;
				case "boolean":
				case "date":
				case "regexp": return "a " + type;
				default: return type;
			}
		}
		function getClassName(propValue) {
			if (!propValue.constructor || !propValue.constructor.name) return ANONYMOUS;
			return propValue.constructor.name;
		}
		ReactPropTypes.checkPropTypes = checkPropTypes;
		ReactPropTypes.resetWarningCache = checkPropTypes.resetWarningCache;
		ReactPropTypes.PropTypes = ReactPropTypes;
		return ReactPropTypes;
	};
}) });

//#endregion
//#region node_modules/prop-types/index.js
var require_prop_types = /* @__PURE__ */ __commonJS({ "node_modules/prop-types/index.js": ((exports, module) => {
	var ReactIs = require_react_is();
	var throwOnDirectAccess = true;
	module.exports = require_factoryWithTypeCheckers()(ReactIs.isElement, throwOnDirectAccess);
}) });

//#endregion
//#region node_modules/react-force-graph-2d/dist/react-force-graph-2d.mjs
var import_prop_types = /* @__PURE__ */ __toESM(require_prop_types(), 1);
var commonPropTypes = {
	width: import_prop_types.default.number,
	height: import_prop_types.default.number,
	graphData: import_prop_types.default.shape({
		nodes: import_prop_types.default.arrayOf(import_prop_types.default.object).isRequired,
		links: import_prop_types.default.arrayOf(import_prop_types.default.object).isRequired
	}),
	backgroundColor: import_prop_types.default.string,
	nodeRelSize: import_prop_types.default.number,
	nodeId: import_prop_types.default.string,
	nodeLabel: import_prop_types.default.oneOfType([import_prop_types.default.string, import_prop_types.default.func]),
	nodeVal: import_prop_types.default.oneOfType([
		import_prop_types.default.number,
		import_prop_types.default.string,
		import_prop_types.default.func
	]),
	nodeVisibility: import_prop_types.default.oneOfType([
		import_prop_types.default.bool,
		import_prop_types.default.string,
		import_prop_types.default.func
	]),
	nodeColor: import_prop_types.default.oneOfType([import_prop_types.default.string, import_prop_types.default.func]),
	nodeAutoColorBy: import_prop_types.default.oneOfType([import_prop_types.default.string, import_prop_types.default.func]),
	onNodeHover: import_prop_types.default.func,
	onNodeClick: import_prop_types.default.func,
	linkSource: import_prop_types.default.string,
	linkTarget: import_prop_types.default.string,
	linkLabel: import_prop_types.default.oneOfType([import_prop_types.default.string, import_prop_types.default.func]),
	linkVisibility: import_prop_types.default.oneOfType([
		import_prop_types.default.bool,
		import_prop_types.default.string,
		import_prop_types.default.func
	]),
	linkColor: import_prop_types.default.oneOfType([import_prop_types.default.string, import_prop_types.default.func]),
	linkAutoColorBy: import_prop_types.default.oneOfType([import_prop_types.default.string, import_prop_types.default.func]),
	linkWidth: import_prop_types.default.oneOfType([
		import_prop_types.default.number,
		import_prop_types.default.string,
		import_prop_types.default.func
	]),
	linkCurvature: import_prop_types.default.oneOfType([
		import_prop_types.default.number,
		import_prop_types.default.string,
		import_prop_types.default.func
	]),
	linkDirectionalArrowLength: import_prop_types.default.oneOfType([
		import_prop_types.default.number,
		import_prop_types.default.string,
		import_prop_types.default.func
	]),
	linkDirectionalArrowColor: import_prop_types.default.oneOfType([import_prop_types.default.string, import_prop_types.default.func]),
	linkDirectionalArrowRelPos: import_prop_types.default.oneOfType([
		import_prop_types.default.number,
		import_prop_types.default.string,
		import_prop_types.default.func
	]),
	linkDirectionalParticles: import_prop_types.default.oneOfType([
		import_prop_types.default.number,
		import_prop_types.default.string,
		import_prop_types.default.func
	]),
	linkDirectionalParticleSpeed: import_prop_types.default.oneOfType([
		import_prop_types.default.number,
		import_prop_types.default.string,
		import_prop_types.default.func
	]),
	linkDirectionalParticleOffset: import_prop_types.default.oneOfType([
		import_prop_types.default.number,
		import_prop_types.default.string,
		import_prop_types.default.func
	]),
	linkDirectionalParticleWidth: import_prop_types.default.oneOfType([
		import_prop_types.default.number,
		import_prop_types.default.string,
		import_prop_types.default.func
	]),
	linkDirectionalParticleColor: import_prop_types.default.oneOfType([import_prop_types.default.string, import_prop_types.default.func]),
	onLinkHover: import_prop_types.default.func,
	onLinkClick: import_prop_types.default.func,
	dagMode: import_prop_types.default.oneOf([
		"td",
		"bu",
		"lr",
		"rl",
		"zin",
		"zout",
		"radialin",
		"radialout"
	]),
	dagLevelDistance: import_prop_types.default.number,
	dagNodeFilter: import_prop_types.default.func,
	onDagError: import_prop_types.default.func,
	d3AlphaMin: import_prop_types.default.number,
	d3AlphaDecay: import_prop_types.default.number,
	d3VelocityDecay: import_prop_types.default.number,
	warmupTicks: import_prop_types.default.number,
	cooldownTicks: import_prop_types.default.number,
	cooldownTime: import_prop_types.default.number,
	onEngineTick: import_prop_types.default.func,
	onEngineStop: import_prop_types.default.func,
	getGraphBbox: import_prop_types.default.func
};
var pointerBasedPropTypes = {
	zoomToFit: import_prop_types.default.func,
	onNodeRightClick: import_prop_types.default.func,
	onNodeDrag: import_prop_types.default.func,
	onNodeDragEnd: import_prop_types.default.func,
	onLinkRightClick: import_prop_types.default.func,
	linkHoverPrecision: import_prop_types.default.number,
	onBackgroundClick: import_prop_types.default.func,
	onBackgroundRightClick: import_prop_types.default.func,
	showPointerCursor: import_prop_types.default.oneOfType([import_prop_types.default.bool, import_prop_types.default.func]),
	enablePointerInteraction: import_prop_types.default.bool,
	enableNodeDrag: import_prop_types.default.bool
};
var threeBasedPropTypes = {
	showNavInfo: import_prop_types.default.bool,
	nodeOpacity: import_prop_types.default.number,
	nodeResolution: import_prop_types.default.number,
	nodeThreeObject: import_prop_types.default.oneOfType([
		import_prop_types.default.object,
		import_prop_types.default.string,
		import_prop_types.default.func
	]),
	nodeThreeObjectExtend: import_prop_types.default.oneOfType([
		import_prop_types.default.bool,
		import_prop_types.default.string,
		import_prop_types.default.func
	]),
	nodePositionUpdate: import_prop_types.default.func,
	linkOpacity: import_prop_types.default.number,
	linkResolution: import_prop_types.default.number,
	linkCurveRotation: import_prop_types.default.oneOfType([
		import_prop_types.default.number,
		import_prop_types.default.string,
		import_prop_types.default.func
	]),
	linkMaterial: import_prop_types.default.oneOfType([
		import_prop_types.default.object,
		import_prop_types.default.string,
		import_prop_types.default.func
	]),
	linkThreeObject: import_prop_types.default.oneOfType([
		import_prop_types.default.object,
		import_prop_types.default.string,
		import_prop_types.default.func
	]),
	linkThreeObjectExtend: import_prop_types.default.oneOfType([
		import_prop_types.default.bool,
		import_prop_types.default.string,
		import_prop_types.default.func
	]),
	linkPositionUpdate: import_prop_types.default.func,
	linkDirectionalArrowResolution: import_prop_types.default.number,
	linkDirectionalParticleResolution: import_prop_types.default.number,
	linkDirectionalParticleThreeObject: import_prop_types.default.oneOfType([
		import_prop_types.default.object,
		import_prop_types.default.string,
		import_prop_types.default.func
	]),
	forceEngine: import_prop_types.default.oneOf(["d3", "ngraph"]),
	ngraphPhysics: import_prop_types.default.object,
	numDimensions: import_prop_types.default.oneOf([
		1,
		2,
		3
	])
};
var ForceGraph2DPropTypes = Object.assign({}, commonPropTypes, pointerBasedPropTypes, {
	linkLineDash: import_prop_types.default.oneOfType([
		import_prop_types.default.arrayOf(import_prop_types.default.number),
		import_prop_types.default.string,
		import_prop_types.default.func
	]),
	nodeCanvasObjectMode: import_prop_types.default.oneOfType([import_prop_types.default.string, import_prop_types.default.func]),
	nodeCanvasObject: import_prop_types.default.func,
	nodePointerAreaPaint: import_prop_types.default.func,
	linkCanvasObjectMode: import_prop_types.default.oneOfType([import_prop_types.default.string, import_prop_types.default.func]),
	linkCanvasObject: import_prop_types.default.func,
	linkPointerAreaPaint: import_prop_types.default.func,
	linkDirectionalParticleCanvasObject: import_prop_types.default.func,
	autoPauseRedraw: import_prop_types.default.bool,
	minZoom: import_prop_types.default.number,
	maxZoom: import_prop_types.default.number,
	enableZoomInteraction: import_prop_types.default.oneOfType([import_prop_types.default.bool, import_prop_types.default.func]),
	enablePanInteraction: import_prop_types.default.oneOfType([import_prop_types.default.bool, import_prop_types.default.func]),
	onZoom: import_prop_types.default.func,
	onZoomEnd: import_prop_types.default.func,
	onRenderFramePre: import_prop_types.default.func,
	onRenderFramePost: import_prop_types.default.func
});
Object.assign({}, commonPropTypes, pointerBasedPropTypes, threeBasedPropTypes, {
	enableNavigationControls: import_prop_types.default.bool,
	controlType: import_prop_types.default.oneOf([
		"trackball",
		"orbit",
		"fly"
	]),
	rendererConfig: import_prop_types.default.object,
	extraRenderers: import_prop_types.default.arrayOf(import_prop_types.default.shape({ render: import_prop_types.default.func.isRequired }))
});
Object.assign({}, commonPropTypes, threeBasedPropTypes, {
	nodeDesc: import_prop_types.default.oneOfType([import_prop_types.default.string, import_prop_types.default.func]),
	linkDesc: import_prop_types.default.oneOfType([import_prop_types.default.string, import_prop_types.default.func])
});
Object.assign({}, commonPropTypes, threeBasedPropTypes, {
	markerAttrs: import_prop_types.default.object,
	yOffset: import_prop_types.default.number,
	glScale: import_prop_types.default.number
});
var ForceGraph2D = index(forceGraph, { methodNames: [
	"emitParticle",
	"d3Force",
	"d3ReheatSimulation",
	"stopAnimation",
	"pauseAnimation",
	"resumeAnimation",
	"centerAt",
	"zoom",
	"zoomToFit",
	"getGraphBbox",
	"screen2GraphCoords",
	"graph2ScreenCoords"
] });
ForceGraph2D.displayName = "ForceGraph2D";
ForceGraph2D.propTypes = ForceGraph2DPropTypes;

//#endregion
export { ForceGraph2D as default };
//# sourceMappingURL=react-force-graph-2d.js.map